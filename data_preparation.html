<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>2 데이터 준비 | 데이터 과학 라이브 북 (Data Science Live Book)</title>
  <meta name="description" content="나이에 상관없이 누구나 배울 수 있는 데이터 분석, 데이터 준비 및 머신러닝에 대한 직관적이고 실용적인 접근법!" />
  <meta name="generator" content="bookdown 0.46.2 and GitBook 2.6.7" />

  <meta property="og:title" content="2 데이터 준비 | 데이터 과학 라이브 북 (Data Science Live Book)" />
  <meta property="og:type" content="book" />
  <meta property="og:image" content="https://livebook.datascienceheroes.com/introduction/data_science_live_book_cover.png" />
  <meta property="og:description" content="나이에 상관없이 누구나 배울 수 있는 데이터 분석, 데이터 준비 및 머신러닝에 대한 직관적이고 실용적인 접근법!" />
  <meta name="github-repo" content="pablo14/data-science-live-book" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="2 데이터 준비 | 데이터 과학 라이브 북 (Data Science Live Book)" />
  <meta name="twitter:site" content="@pabloc_ds" />
  <meta name="twitter:description" content="나이에 상관없이 누구나 배울 수 있는 데이터 분석, 데이터 준비 및 머신러닝에 대한 직관적이고 실용적인 접근법!" />
  <meta name="twitter:image" content="https://livebook.datascienceheroes.com/introduction/data_science_live_book_cover.png" />

<meta name="author" content="Pablo Casas (번역: fkt)" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  <link rel="shortcut icon" href="introduction/favicon.ico" type="image/x-icon" />
<link rel="prev" href="exploratory_data_analysis.html"/>
<link rel="next" href="selecting_best_variables.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-82047152-1', 'auto');
ga('send', 'pageview');
</script>
<!-- End Google Analytics -->


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>
<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Data Science Live Book</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>서문 (Preface)</a>
<ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#종이책-킨들-amazon"><i class="fa fa-check"></i>종이책 &amp; 킨들 (Amazon)</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#왜-이-책인가요"><i class="fa fa-check"></i>왜 이 책인가요?</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#배움을-향한-여정"><i class="fa fa-check"></i>배움을 향한 여정</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#이-책이-나에게-맞을까요-이해할-수-있을까요"><i class="fa fa-check"></i>이 책이 나에게 맞을까요? 이해할 수 있을까요?</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#프로그래밍-언어"><i class="fa fa-check"></i>프로그래밍 언어</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#기계와-인공지능이-세상을-지배하게-될까요"><i class="fa fa-check"></i>기계와 인공지능이 세상을 지배하게 될까요? 😱</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#시작하려면-무엇이-필요한가요"><i class="fa fa-check"></i>시작하려면 무엇이 필요한가요?</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#연락은-어떻게-하나요"><i class="fa fa-check"></i>연락은 어떻게 하나요? 📩</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#감사의-말"><i class="fa fa-check"></i>감사의 말</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#책-정보"><i class="fa fa-check"></i>책 정보</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html"><i class="fa fa-check"></i><b>1</b> 탐색적 데이터 분석</a>
<ul>
<li class="chapter" data-level="1.1" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#profiling"><i class="fa fa-check"></i><b>1.1</b> 프로파일링: 숫자의 목소리</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#데이터셋-상태-dataset-health-status"><i class="fa fa-check"></i><b>1.1.1</b> 데이터셋 상태 {#dataset-health-status}</a></li>
<li class="chapter" data-level="1.1.2" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#범주형-변수-프로파일링-profiling-categorical-variables"><i class="fa fa-check"></i><b>1.1.2</b> 범주형 변수 프로파일링 {#profiling-categorical-variables}</a></li>
<li class="chapter" data-level="1.1.3" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#수치형-변수-프로파일링"><i class="fa fa-check"></i><b>1.1.3</b> 수치형 변수 프로파일링</a></li>
<li class="chapter" data-level="1.1.4" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#최종-생각"><i class="fa fa-check"></i><b>1.1.4</b> 최종 생각</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#상관-관계-및-관계-httpswww.google.comsearchq23correlation"><i class="fa fa-check"></i><b>1.2</b> 상관 관계 및 관계 {https://www.google.com/search?q=%23correlation}</a>
<ul>
<li class="chapter" data-level="1.2.1" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#이-장의-내용은-무엇일까요"><i class="fa fa-check"></i><b>1.2.1</b> 이 장의 내용은 무엇일까요?</a></li>
<li class="chapter" data-level="1.2.2" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#선형-상관-관계-linear-correlation"><i class="fa fa-check"></i><b>1.2.2</b> 선형 상관 관계 {#linear-correlation}</a></li>
<li class="chapter" data-level="1.2.3" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#정보-이론에-기반한-상관-관계"><i class="fa fa-check"></i><b>1.2.3</b> 정보 이론에 기반한 상관 관계</a></li>
<li class="chapter" data-level="1.2.4" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#노이즈-추가"><i class="fa fa-check"></i><b>1.2.4</b> 노이즈 추가</a></li>
<li class="chapter" data-level="1.2.5" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#비선형성-측정-mic-r2"><i class="fa fa-check"></i><b>1.2.5</b> 비선형성 측정 (MIC-R2)</a></li>
<li class="chapter" data-level="1.2.6" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#앤스콤-쿼텟에서-정보-측정하기"><i class="fa fa-check"></i><b>1.2.6</b> 앤스콤 쿼텟에서 정보 측정하기</a></li>
<li class="chapter" data-level="1.2.7" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#비단조성-측정-mas-측정"><i class="fa fa-check"></i><b>1.2.7</b> 비단조성 측정: MAS 측정</a></li>
<li class="chapter" data-level="1.2.8" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#시계열-간의-상관-관계"><i class="fa fa-check"></i><b>1.2.8</b> 시계열 간의 상관 관계</a></li>
<li class="chapter" data-level="1.2.9" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#범주형-변수의-상관-관계"><i class="fa fa-check"></i><b>1.2.9</b> 범주형 변수의 상관 관계</a></li>
<li class="chapter" data-level="1.2.10" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#정보-이론에-기반한-상관-관계-분석-selecting_best_vars_mic"><i class="fa fa-check"></i><b>1.2.10</b> 정보 이론에 기반한 상관 관계 분석 {#selecting_best_vars_mic}</a></li>
<li class="chapter" data-level="1.2.11" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#mine만-이런-기능을-제공하나요"><i class="fa fa-check"></i><b>1.2.11</b> MINE만 이런 기능을 제공하나요?</a></li>
<li class="chapter" data-level="1.2.12" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#정보-측정-일반적인-관점"><i class="fa fa-check"></i><b>1.2.12</b> 정보 측정: 일반적인 관점</a></li>
<li class="chapter" data-level="1.2.13" data-path="exploratory_data_analysis.html"><a href="exploratory_data_analysis.html#결론"><i class="fa fa-check"></i><b>1.2.13</b> 결론</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="data_preparation.html"><a href="data_preparation.html"><i class="fa fa-check"></i><b>2</b> 데이터 준비</a>
<ul>
<li class="chapter" data-level="2.1" data-path="data_preparation.html"><a href="data_preparation.html#data_types"><i class="fa fa-check"></i><b>2.1</b> 데이터 유형 처리</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="data_preparation.html"><a href="data_preparation.html#무엇에-대한-내용인가요"><i class="fa fa-check"></i><b>2.1.1</b> 무엇에 대한 내용인가요?</a></li>
<li class="chapter" data-level="2.1.2" data-path="data_preparation.html"><a href="data_preparation.html#데이터-유형의-세계"><i class="fa fa-check"></i><b>2.1.2</b> 데이터 유형의 세계</a></li>
<li class="chapter" data-level="2.1.3" data-path="data_preparation.html"><a href="data_preparation.html#알고리즘별-데이터-유형"><i class="fa fa-check"></i><b>2.1.3</b> 알고리즘별 데이터 유형</a></li>
<li class="chapter" data-level="2.1.4" data-path="data_preparation.html"><a href="data_preparation.html#범주형-변수를-숫자형으로-변환하기"><i class="fa fa-check"></i><b>2.1.4</b> 범주형 변수를 숫자형으로 변환하기</a></li>
<li class="chapter" data-level="2.1.5" data-path="data_preparation.html"><a href="data_preparation.html#범주형인가요-수치형인가요-생각해-봅시다."><i class="fa fa-check"></i><b>2.1.5</b> 범주형인가요, 수치형인가요? 생각해 봅시다.</a></li>
<li class="chapter" data-level="2.1.6" data-path="data_preparation.html"><a href="data_preparation.html#discretizing_numerical_variables"><i class="fa fa-check"></i><b>2.1.6</b> 수치형 변수 이산화 (Discretizing numerical variables)</a></li>
<li class="chapter" data-level="2.1.7" data-path="data_preparation.html"><a href="data_preparation.html#discretization_new_data"><i class="fa fa-check"></i><b>2.1.7</b> 새로운 데이터에서의 이산화</a></li>
<li class="chapter" data-level="2.1.8" data-path="data_preparation.html"><a href="data_preparation.html#data-discretization"><i class="fa fa-check"></i><b>2.1.8</b> 자동 데이터 프레임 이산화</a></li>
<li class="chapter" data-level="2.1.9" data-path="data_preparation.html"><a href="data_preparation.html#최종-생각-1"><i class="fa fa-check"></i><b>2.1.9</b> 최종 생각</a></li>
<li class="chapter" data-level="2.1.10" data-path="data_preparation.html"><a href="data_preparation.html#보너스-트랙"><i class="fa fa-check"></i><b>2.1.10</b> 보너스 트랙 💥</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="data_preparation.html"><a href="data_preparation.html#high_cardinality_descriptive_stats"><i class="fa fa-check"></i><b>2.2</b> 기술 통계에서의 고카디널리티 변수</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="data_preparation.html"><a href="data_preparation.html#무엇에-대한-내용인가요-1"><i class="fa fa-check"></i><b>2.2.1</b> 무엇에 대한 내용인가요?</a></li>
<li class="chapter" data-level="2.2.2" data-path="data_preparation.html"><a href="data_preparation.html#기술-통계에서의-고카디널리티"><i class="fa fa-check"></i><b>2.2.2</b> 기술 통계에서의 고카디널리티</a></li>
<li class="chapter" data-level="2.2.3" data-path="data_preparation.html"><a href="data_preparation.html#최종-코멘트"><i class="fa fa-check"></i><b>2.2.3</b> 최종 코멘트</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="data_preparation.html"><a href="data_preparation.html#high_cardinality_predictive_modeling"><i class="fa fa-check"></i><b>2.3</b> High Cardinality Variable in Predictive Modeling</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="data_preparation.html"><a href="data_preparation.html#무엇에-대한-내용인가요-2"><i class="fa fa-check"></i><b>2.3.1</b> 무엇에 대한 내용인가요?</a></li>
<li class="chapter" data-level="2.3.2" data-path="data_preparation.html"><a href="data_preparation.html#하지만-변수를-재그룹화하는-것이-필요할까요"><i class="fa fa-check"></i><b>2.3.2</b> 하지만 변수를 재그룹화하는 것이 필요할까요?</a></li>
<li class="chapter" data-level="2.3.3" data-path="data_preparation.html"><a href="data_preparation.html#analyze-binary-outcome-vs-categorical-variable"><i class="fa fa-check"></i><b>2.3.3</b> 사례 🔍</a></li>
<li class="chapter" data-level="2.3.4" data-path="data_preparation.html"><a href="data_preparation.html#예측-모델링을-위한-분석"><i class="fa fa-check"></i><b>2.3.4</b> 예측 모델링을 위한 분석 🔮</a></li>
<li class="chapter" data-level="2.3.5" data-path="data_preparation.html"><a href="data_preparation.html#예측-모델이-운영-환경에-있을-때-새로운-카테고리-처리하기"><i class="fa fa-check"></i><b>2.3.5</b> 예측 모델이 운영 환경에 있을 때 새로운 카테고리 처리하기</a></li>
<li class="chapter" data-level="2.3.6" data-path="data_preparation.html"><a href="data_preparation.html#예측-모델이-고카디널리티를-처리하나요-파트-1"><i class="fa fa-check"></i><b>2.3.6</b> 예측 모델이 고카디널리티를 처리하나요? 파트 1</a></li>
<li class="chapter" data-level="2.3.7" data-path="data_preparation.html"><a href="data_preparation.html#high_cardinality_in_predictive_models_part_2"><i class="fa fa-check"></i><b>2.3.7</b> 예측 모델이 고카디널리티를 처리하지 않나요? 파트 2</a></li>
<li class="chapter" data-level="2.3.8" data-path="data_preparation.html"><a href="data_preparation.html#수치형-또는-다중-공선성-타겟-변수"><i class="fa fa-check"></i><b>2.3.8</b> 수치형 또는 다중 공선성 타겟 변수 📏</a></li>
<li class="chapter" data-level="2.3.9" data-path="data_preparation.html"><a href="data_preparation.html#그룹화에서-얻은-추가-선물-은-무엇인가요"><i class="fa fa-check"></i><b>2.3.9</b> 그룹화에서 얻은 “추가 선물 🎁”은 무엇인가요?</a></li>
<li class="chapter" data-level="2.3.10" data-path="data_preparation.html"><a href="data_preparation.html#대표성-또는-샘플-크기"><i class="fa fa-check"></i><b>2.3.10</b> 대표성 또는 샘플 크기</a></li>
<li class="chapter" data-level="2.3.11" data-path="data_preparation.html"><a href="data_preparation.html#최종-생각-2"><i class="fa fa-check"></i><b>2.3.11</b> 최종 생각</a></li>
<li class="chapter" data-level="2.3.12" data-path="data_preparation.html"><a href="data_preparation.html#추가-읽기"><i class="fa fa-check"></i><b>2.3.12</b> 추가 읽기</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="data_preparation.html"><a href="data_preparation.html#treatment_outliers"><i class="fa fa-check"></i><b>2.4</b> 이상치 처리 (Treatment of outliers)</a>
<ul>
<li class="chapter" data-level="2.4.1" data-path="data_preparation.html"><a href="data_preparation.html#무엇에-대한-내용인가요-3"><i class="fa fa-check"></i><b>2.4.1</b> 무엇에 대한 내용인가요?</a></li>
<li class="chapter" data-level="2.4.2" data-path="data_preparation.html"><a href="data_preparation.html#이상치에-대한-직관"><i class="fa fa-check"></i><b>2.4.2</b> 이상치에 대한 직관</a></li>
<li class="chapter" data-level="2.4.3" data-path="data_preparation.html"><a href="data_preparation.html#덥고-추운-날씨의-경계는-어디일까요"><i class="fa fa-check"></i><b>2.4.3</b> 덥고 추운 날씨의 경계는 어디일까요?</a></li>
<li class="chapter" data-level="2.4.4" data-path="data_preparation.html"><a href="data_preparation.html#이상치의-영향"><i class="fa fa-check"></i><b>2.4.4</b> 이상치의 영향</a></li>
<li class="chapter" data-level="2.4.5" data-path="data_preparation.html"><a href="data_preparation.html#how_to_deal_with_outliers_in_r"><i class="fa fa-check"></i><b>2.4.5</b> R에서 이상치를 처리하는 방법</a></li>
<li class="chapter" data-level="2.4.6" data-path="data_preparation.html"><a href="data_preparation.html#단계-이상치를-감지하는-방법"><i class="fa fa-check"></i><b>2.4.6</b> 1단계: 이상치를 감지하는 방법 🔎</a></li>
<li class="chapter" data-level="2.4.7" data-path="data_preparation.html"><a href="data_preparation.html#단계-이상치를-어떻게-할까요"><i class="fa fa-check"></i><b>2.4.7</b> 2단계: 이상치를 어떻게 할까요? 🛠️</a></li>
<li class="chapter" data-level="2.4.8" data-path="data_preparation.html"><a href="data_preparation.html#최종-생각-3"><i class="fa fa-check"></i><b>2.4.8</b> 최종 생각</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="data_preparation.html"><a href="data_preparation.html#missing_data"><i class="fa fa-check"></i><b>2.5</b> 결측 데이터: 분석, 처리 및 대치</a>
<ul>
<li class="chapter" data-level="2.5.1" data-path="data_preparation.html"><a href="data_preparation.html#무엇에-대한-내용인가요-4"><i class="fa fa-check"></i><b>2.5.1</b> 무엇에 대한 내용인가요?</a></li>
<li class="chapter" data-level="2.5.2" data-path="data_preparation.html"><a href="data_preparation.html#빈-값이-정보를-나타낼-때"><i class="fa fa-check"></i><b>2.5.2</b> 빈 값이 정보를 나타낼 때</a></li>
<li class="chapter" data-level="2.5.3" data-path="data_preparation.html"><a href="data_preparation.html#빈-값이-진짜-빈-값일-때"><i class="fa fa-check"></i><b>2.5.3</b> 빈 값이 진짜 빈 값일 때</a></li>
<li class="chapter" data-level="2.5.4" data-path="data_preparation.html"><a href="data_preparation.html#전체-행-제외하기"><i class="fa fa-check"></i><b>2.5.4</b> 전체 행 제외하기</a></li>
<li class="chapter" data-level="2.5.5" data-path="data_preparation.html"><a href="data_preparation.html#열-제외하기"><i class="fa fa-check"></i><b>2.5.5</b> 열 제외하기</a></li>
<li class="chapter" data-level="2.5.6" data-path="data_preparation.html"><a href="data_preparation.html#범주형-변수의-빈-값-처리하기"><i class="fa fa-check"></i><b>2.5.6</b> 범주형 변수의 빈 값 처리하기</a></li>
<li class="chapter" data-level="2.5.7" data-path="data_preparation.html"><a href="data_preparation.html#결측값에-어떤-패턴이-있나요"><i class="fa fa-check"></i><b>2.5.7</b> 결측값에 어떤 패턴이 있나요?</a></li>
<li class="chapter" data-level="2.5.8" data-path="data_preparation.html"><a href="data_preparation.html#수치형-변수의-결측값-처리하기"><i class="fa fa-check"></i><b>2.5.8</b> 수치형 변수의 결측값 처리하기</a></li>
<li class="chapter" data-level="2.5.9" data-path="data_preparation.html"><a href="data_preparation.html#고급-대치-방법-advanced-imputation-methods"><i class="fa fa-check"></i><b>2.5.9</b> 고급 대치 방법 (Advanced imputation methods)</a></li>
<li class="chapter" data-level="2.5.10" data-path="data_preparation.html"><a href="data_preparation.html#결론-1"><i class="fa fa-check"></i><b>2.5.10</b> 결론</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="data_preparation.html"><a href="data_preparation.html#considerations-involving-time"><i class="fa fa-check"></i><b>2.6</b> 시간과 관련된 고려 사항</a>
<ul>
<li class="chapter" data-level="2.6.1" data-path="data_preparation.html"><a href="data_preparation.html#무엇에-대한-내용인가요-5"><i class="fa fa-check"></i><b>2.6.1</b> 무엇에 대한 내용인가요?</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html"><i class="fa fa-check"></i><b>3</b> 최적 변수 선택</a>
<ul>
<li class="chapter" data-level="3.1" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#general_aspects_selecting_best_variables"><i class="fa fa-check"></i><b>3.1</b> 최적 변수 선택의 일반적 측면</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#무엇에-대한-내용인가요-6"><i class="fa fa-check"></i><b>3.1.1</b> 무엇에 대한 내용인가요?</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#직관"><i class="fa fa-check"></i><b>3.2</b> 직관</a></li>
<li class="chapter" data-level="3.3" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#최적의-선택"><i class="fa fa-check"></i><b>3.3</b> “최적”의 선택?</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#변수-순위-더-깊이-알아보기"><i class="fa fa-check"></i><b>3.3.1</b> 변수 순위 더 깊이 알아보기</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#선택의-특성"><i class="fa fa-check"></i><b>3.4</b> 선택의 특성</a></li>
<li class="chapter" data-level="3.5" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#변수-개선하기"><i class="fa fa-check"></i><b>3.5</b> 변수 개선하기</a></li>
<li class="chapter" data-level="3.6" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#도메인-지식에-의한-정제"><i class="fa fa-check"></i><b>3.6</b> 도메인 지식에 의한 정제</a></li>
<li class="chapter" data-level="3.7" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#변수는-그룹으로-작용합니다"><i class="fa fa-check"></i><b>3.7</b> 변수는 그룹으로 작용합니다</a>
<ul>
<li class="chapter" data-level="3.7.1" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#r-사례-그룹으로-작용하는-변수"><i class="fa fa-check"></i><b>3.7.1</b> R 사례: 그룹으로 작용하는 변수</a></li>
<li class="chapter" data-level="3.7.2" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#작은-사례-정보-이론-기반"><i class="fa fa-check"></i><b>3.7.2</b> 작은 사례 (정보 이론 기반)</a></li>
<li class="chapter" data-level="3.7.3" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#결론-2"><i class="fa fa-check"></i><b>3.7.3</b> 결론</a></li>
<li class="chapter" data-level="3.7.4" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#select_features_var_rank_info"><i class="fa fa-check"></i><b>3.7.4</b> 정보 이론을 사용한 최적 특성 순위 매기기</a></li>
</ul></li>
<li class="chapter" data-level="3.8" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#입력-변수-간의-상관관계"><i class="fa fa-check"></i><b>3.8</b> 입력 변수 간의 상관관계</a></li>
<li class="chapter" data-level="3.9" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#단순하게-유지하기"><i class="fa fa-check"></i><b>3.9</b> 단순하게 유지하기</a></li>
<li class="chapter" data-level="3.10" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#클러스터링에서의-변수-선택"><i class="fa fa-check"></i><b>3.10</b> 클러스터링에서의 변수 선택?</a></li>
<li class="chapter" data-level="3.11" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#실무에서-최적-변수-선택하기"><i class="fa fa-check"></i><b>3.11</b> 실무에서 최적 변수 선택하기</a>
<ul>
<li class="chapter" data-level="3.11.1" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#짧은-답변"><i class="fa fa-check"></i><b>3.11.1</b> 짧은 답변</a></li>
<li class="chapter" data-level="3.11.2" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#긴-답변"><i class="fa fa-check"></i><b>3.11.2</b> 긴 답변</a></li>
<li class="chapter" data-level="3.11.3" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#자신만의-지식-창출하기"><i class="fa fa-check"></i><b>3.11.3</b> 자신만의 지식 창출하기</a></li>
</ul></li>
<li class="chapter" data-level="3.12" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#타겟-프로파일링"><i class="fa fa-check"></i><b>3.12</b> 타겟 프로파일링</a>
<ul>
<li class="chapter" data-level="3.12.1" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#profiling_target_cross_plot"><i class="fa fa-check"></i><b>3.12.1</b> <code>cross_plot</code> 사용하기 (dataViz)</a></li>
<li class="chapter" data-level="3.12.2" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#target-profiling-using-boxplots"><i class="fa fa-check"></i><b>3.12.2</b> 박스 플롯 사용하기</a></li>
<li class="chapter" data-level="3.12.3" data-path="selecting_best_variables.html"><a href="selecting_best_variables.html#target-profiling-using-density-histograms"><i class="fa fa-check"></i><b>3.12.3</b> 밀도 히스토그램 사용하기</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="model-performance.html"><a href="model-performance.html"><i class="fa fa-check"></i><b>4</b> 모델 성능 평가</a>
<ul>
<li class="chapter" data-level="4.1" data-path="model-performance.html"><a href="model-performance.html#knowing_the_error"><i class="fa fa-check"></i><b>4.1</b> 오차 알기</a>
<ul>
<li class="chapter" data-level="4.1.1" data-path="model-performance.html"><a href="model-performance.html#무엇에-대한-내용인가요-10"><i class="fa fa-check"></i><b>4.1.1</b> 무엇에 대한 내용인가요?</a></li>
<li class="chapter" data-level="4.1.2" data-path="model-performance.html"><a href="model-performance.html#예상치-못한-동작-줄이기"><i class="fa fa-check"></i><b>4.1.2</b> 예상치 못한 동작 줄이기</a></li>
<li class="chapter" data-level="4.1.3" data-path="model-performance.html"><a href="model-performance.html#교차-검증cross-validation-cv으로-설명해-보겠습니다"><i class="fa fa-check"></i><b>4.1.3</b> 교차 검증(Cross-Validation, CV)으로 설명해 보겠습니다</a></li>
<li class="chapter" data-level="4.1.4" data-path="model-performance.html"><a href="model-performance.html#그렇다면-오차란-무엇인가요"><i class="fa fa-check"></i><b>4.1.4</b> 그렇다면 오차란 무엇인가요?</a></li>
<li class="chapter" data-level="4.1.5" data-path="model-performance.html"><a href="model-performance.html#실무에-대한-제언이-있나요"><i class="fa fa-check"></i><b>4.1.5</b> 실무에 대한 제언이 있나요?</a></li>
<li class="chapter" data-level="4.1.6" data-path="model-performance.html"><a href="model-performance.html#잊지-마세요-데이터-준비"><i class="fa fa-check"></i><b>4.1.6</b> 잊지 마세요: 데이터 준비</a></li>
<li class="chapter" data-level="4.1.7" data-path="model-performance.html"><a href="model-performance.html#마지막-생각"><i class="fa fa-check"></i><b>4.1.7</b> 마지막 생각</a></li>
<li class="chapter" data-level="4.1.8" data-path="model-performance.html"><a href="model-performance.html#더-읽어보기"><i class="fa fa-check"></i><b>4.1.8</b> 더 읽어보기</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="model-performance.html"><a href="model-performance.html#out-of-time_validation"><i class="fa fa-check"></i><b>4.2</b> 시간 외 검증 (Out-of-Time Validation)</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="model-performance.html"><a href="model-performance.html#무엇에-대한-내용인가요-11"><i class="fa fa-check"></i><b>4.2.1</b> 무엇에 대한 내용인가요?</a></li>
<li class="chapter" data-level="4.2.2" data-path="model-performance.html"><a href="model-performance.html#어떤-종류의-데이터인가요-1"><i class="fa fa-check"></i><b>4.2.2</b> 어떤 종류의 데이터인가요?</a></li>
<li class="chapter" data-level="4.2.3" data-path="model-performance.html"><a href="model-performance.html#시간-외-검증-예시"><i class="fa fa-check"></i><b>4.2.3</b> 시간 외 검증 예시</a></li>
<li class="chapter" data-level="4.2.4" data-path="model-performance.html"><a href="model-performance.html#이득-및-리프트-분석gain-and-lift-analysis-사용하기"><i class="fa fa-check"></i><b>4.2.4</b> 이득 및 리프트 분석(Gain and Lift Analysis) 사용하기</a></li>
<li class="chapter" data-level="4.2.5" data-path="model-performance.html"><a href="model-performance.html#수치형-타겟-변수는-어떤가요"><i class="fa fa-check"></i><b>4.2.5</b> 수치형 타겟 변수는 어떤가요?</a></li>
<li class="chapter" data-level="4.2.6" data-path="model-performance.html"><a href="model-performance.html#마지막-생각-1"><i class="fa fa-check"></i><b>4.2.6</b> 마지막 생각</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="model-performance.html"><a href="model-performance.html#gain_and_lift"><i class="fa fa-check"></i><b>4.3</b> 이득 및 리프트 분석 (Gain and Lift Analysis)</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="model-performance.html"><a href="model-performance.html#무엇에-대한-내용인가요-12"><i class="fa fa-check"></i><b>4.3.1</b> 무엇에 대한 내용인가요?</a></li>
<li class="chapter" data-level="4.3.2" data-path="model-performance.html"><a href="model-performance.html#어떻게-해석하나요"><i class="fa fa-check"></i><b>4.3.2</b> 어떻게 해석하나요?</a></li>
<li class="chapter" data-level="4.3.3" data-path="model-performance.html"><a href="model-performance.html#모델을-사용하지-않는다면-어떨까요"><i class="fa fa-check"></i><b>4.3.3</b> 모델을 사용하지 않는다면 어떨까요?</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="model-performance.html"><a href="model-performance.html#scoring_data"><i class="fa fa-check"></i><b>4.4</b> 데이터 스코어링 (Scoring Data)</a>
<ul>
<li class="chapter" data-level="4.4.1" data-path="model-performance.html"><a href="model-performance.html#숨겨진-직관"><i class="fa fa-check"></i><b>4.4.1</b> 숨겨진 직관</a></li>
<li class="chapter" data-level="4.4.2" data-path="model-performance.html"><a href="model-performance.html#예제를-살펴봅시다"><i class="fa fa-check"></i><b>4.4.2</b> 예제를 살펴봅시다</a></li>
<li class="chapter" data-level="4.4.3" data-path="model-performance.html"><a href="model-performance.html#모든-것은-절단점cut-point에-달려-있습니다"><i class="fa fa-check"></i><b>4.4.3</b> 모든 것은 절단점(cut point)에 달려 있습니다 📏</a></li>
<li class="chapter" data-level="4.4.4" data-path="model-performance.html"><a href="model-performance.html#최선과-최악의-시나리오"><i class="fa fa-check"></i><b>4.4.4</b> 최선과 최악의 시나리오</a></li>
<li class="chapter" data-level="4.4.5" data-path="model-performance.html"><a href="model-performance.html#분류기-비교"><i class="fa fa-check"></i><b>4.4.5</b> 분류기 비교</a></li>
<li class="chapter" data-level="4.4.6" data-path="model-performance.html"><a href="model-performance.html#r로-직접-해보기"><i class="fa fa-check"></i><b>4.4.6</b> R로 직접 해보기!</a></li>
<li class="chapter" data-level="4.4.7" data-path="model-performance.html"><a href="model-performance.html#결론-4"><i class="fa fa-check"></i><b>4.4.7</b> 결론</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="appendix.html"><a href="appendix.html"><i class="fa fa-check"></i><b>5</b> 부록 (APPENDIX)</a>
<ul>
<li class="chapter" data-level="5.1" data-path="appendix.html"><a href="appendix.html#appendix-percentiles"><i class="fa fa-check"></i><b>5.1</b> 백분위수의 마법</a>
<ul>
<li class="chapter" data-level="5.1.1" data-path="appendix.html"><a href="appendix.html#백분위수를-계산하는-방법"><i class="fa fa-check"></i><b>5.1.1</b> 백분위수를 계산하는 방법</a></li>
<li class="chapter" data-level="5.1.2" data-path="appendix.html"><a href="appendix.html#사용자-정의-분위수-계산"><i class="fa fa-check"></i><b>5.1.2</b> 사용자 정의 분위수 계산</a></li>
<li class="chapter" data-level="5.1.3" data-path="appendix.html"><a href="appendix.html#대부분의-값이-어디에-있는지-표시하기"><i class="fa fa-check"></i><b>5.1.3</b> 대부분의 값이 어디에 있는지 표시하기</a></li>
<li class="chapter" data-level="5.1.4" data-path="appendix.html"><a href="appendix.html#백분위수-시각화"><i class="fa fa-check"></i><b>5.1.4</b> 백분위수 시각화</a></li>
<li class="chapter" data-level="5.1.5" data-path="appendix.html"><a href="appendix.html#순위-및-상위하위-x-개념"><i class="fa fa-check"></i><b>5.1.5</b> 순위 및 상위/하위 ‘X%’ 개념</a></li>
<li class="chapter" data-level="5.1.6" data-path="appendix.html"><a href="appendix.html#데이터-스코어링에서의-백분위수"><i class="fa fa-check"></i><b>5.1.6</b> 데이터 스코어링에서의 백분위수</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="appendix.html"><a href="appendix.html#funmodeling-quick-start"><i class="fa fa-check"></i><b>5.2</b> <code>funModeling</code> 퀵스타트</a>
<ul>
<li class="chapter" data-level="5.2.1" data-path="appendix.html"><a href="appendix.html#블랙박스-열어보기"><i class="fa fa-check"></i><b>5.2.1</b> 블랙박스 열어보기</a></li>
<li class="chapter" data-level="5.2.2" data-path="appendix.html"><a href="appendix.html#탐색적-데이터-분석-eda"><i class="fa fa-check"></i><b>5.2.2</b> 탐색적 데이터 분석 (EDA)</a></li>
<li class="chapter" data-level="5.2.3" data-path="appendix.html"><a href="appendix.html#상관관계"><i class="fa fa-check"></i><b>5.2.3</b> 상관관계</a></li>
<li class="chapter" data-level="5.2.4" data-path="appendix.html"><a href="appendix.html#데이터-준비"><i class="fa fa-check"></i><b>5.2.4</b> 데이터 준비</a></li>
<li class="chapter" data-level="5.2.5" data-path="appendix.html"><a href="appendix.html#이상치outliers-데이터-준비"><i class="fa fa-check"></i><b>5.2.5</b> 이상치(Outliers) 데이터 준비</a></li>
<li class="chapter" data-level="5.2.6" data-path="appendix.html"><a href="appendix.html#예측-모델-성능"><i class="fa fa-check"></i><b>5.2.6</b> 예측 모델 성능</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="6" data-path="download-book.html"><a href="download-book.html"><i class="fa fa-check"></i><b>6</b> 도서 다운로드</a></li>
<li class="chapter" data-level="" data-path="참고-문헌-references.html"><a href="참고-문헌-references.html"><i class="fa fa-check"></i>참고 문헌 (References)</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">데이터 과학 라이브 북 (Data Science Live Book)</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="data_preparation" class="section level1 hasAnchor" number="2">
<h1><span class="header-section-number">2</span> 데이터 준비<a href="data_preparation.html#data_preparation" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="data_types" class="section level2 hasAnchor" number="2.1">
<h2><span class="header-section-number">2.1</span> 데이터 유형 처리<a href="data_preparation.html#data_types" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="무엇에-대한-내용인가요" class="section level3 hasAnchor" number="2.1.1">
<h3><span class="header-section-number">2.1.1</span> 무엇에 대한 내용인가요?<a href="data_preparation.html#무엇에-대한-내용인가요" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>데이터 프로젝트를 시작할 때 가장 먼저 해야 할 일 중 하나는 각 변수에 올바른 데이터 유형을 할당하는 것입니다. 이는 간단해 보이는 작업이지만, 일부 알고리즘은 특정 데이터 유형으로 작동합니다. 여기서는 각 경우의 의미를 예시와 함께 설명하면서 이러한 변환을 다루려고 합니다.</p>
<div class="figure"><span style="display:block;" id="fig:Fibonnacci-curve"></span>
<img src="data_preparation/fibonacci_spiral.jpg" alt="피보나치 나선" height="150px"  />
<p class="caption">
Figure 2.1: 피보나치 나선
</p>
</div>
<p><em>피보나치 수열. 자연과 인체에 존재하는 숫자의 순서.</em></p>
<p><strong>이 장에서 무엇을 검토할 예정인가요?</strong></p>
<ul>
<li>올바른 데이터 유형 감지</li>
<li>범주형을 숫자형으로 변환하는 방법</li>
<li>숫자형을 범주형으로 변환하는 방법 (이산화 방법)</li>
<li>이론 및 실제적 측면 (R 예제)</li>
<li>예측 모델이 숫자형 변수를 보는 방식</li>
</ul>
</div>
<div id="데이터-유형의-세계" class="section level3 hasAnchor" number="2.1.2">
<h3><span class="header-section-number">2.1.2</span> 데이터 유형의 세계<a href="data_preparation.html#데이터-유형의-세계" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>주요 데이터 유형은 <strong>숫자형</strong>과 <strong>범주형</strong> 두 가지입니다. 범주형의 다른 이름으로는 <strong>문자열</strong>과 <strong>명목형</strong>이 있습니다.</p>
<p>범주형의 하위 집합으로 순서형 또는 R에서 <strong>정렬된(ordered)</strong> 팩터라고 불리는 유형이 있습니다. 적어도 R에서는 이 유형은 특정 순서로 범주를 그릴 때만 관련이 있습니다. R 예시는 다음과 같습니다.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="data_preparation.html#cb81-1" tabindex="-1"></a><span class="co"># 순서형 또는 정렬된 팩터 생성</span></span>
<span id="cb81-2"><a href="data_preparation.html#cb81-2" tabindex="-1"></a>var_factor<span class="ot">=</span><span class="fu">factor</span>(<span class="fu">c</span>(<span class="st">&quot;3_high&quot;</span>, <span class="st">&quot;2_mid&quot;</span>, <span class="st">&quot;1_low&quot;</span>))</span>
<span id="cb81-3"><a href="data_preparation.html#cb81-3" tabindex="-1"></a>var_ordered<span class="ot">=</span><span class="fu">factor</span>(var_factor, <span class="at">ordered =</span> T)</span>
<span id="cb81-4"><a href="data_preparation.html#cb81-4" tabindex="-1"></a>var_ordered</span></code></pre></div>
<p>숫자형과 범주형이 가장 필요하므로 이 데이터 유형에는 너무 많은 주의를 기울이지 마십시오.</p>
<div id="이진-변수-숫자형-또는-범주형" class="section level4 hasAnchor" number="2.1.2.1">
<h4><span class="header-section-number">2.1.2.1</span> 이진 변수, 숫자형 또는 범주형?<a href="data_preparation.html#이진-변수-숫자형-또는-범주형" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>이 책은 <code>0</code>이 <code>FALSE</code>이고 <code>1</code>이 <code>TRUE</code>일 때 이진 변수를 숫자형으로 사용할 것을 제안합니다. 이렇게 하면 데이터를 프로파일링하기가 더 쉽습니다.</p>
</div>
</div>
<div id="알고리즘별-데이터-유형" class="section level3 hasAnchor" number="2.1.3">
<h3><span class="header-section-number">2.1.3</span> 알고리즘별 데이터 유형<a href="data_preparation.html#알고리즘별-데이터-유형" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>일부 알고리즘은 다음과 같이 작동합니다.</p>
<ul>
<li>📊 범주형 데이터만 사용</li>
<li>📏 숫자형 데이터만 사용</li>
<li>📊📏 두 가지 유형 모두 사용</li>
</ul>
<p>또한, 모든 예측 모델이 <strong>결측값</strong>을 처리할 수 있는 것은 아닙니다.</p>
<p><strong>데이터 사이언스 라이브 북</strong>은 이 모든 상황을 다루려고 합니다.</p>
</div>
<div id="범주형-변수를-숫자형으로-변환하기" class="section level3 hasAnchor" number="2.1.4">
<h3><span class="header-section-number">2.1.4</span> 범주형 변수를 숫자형으로 변환하기<a href="data_preparation.html#범주형-변수를-숫자형으로-변환하기" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>R의 <code>caret</code> 패키지를 사용하면 모든 범주형 변수를 <strong>플래그 변수</strong>(더미 변수라고도 함)로 변환하는 것은 간단한 작업입니다.</p>
<p>원래 범주형 변수에 30개의 가능한 값이 있다면, 30개의 새 열이 생성되어 <code>0</code> 또는 <code>1</code> 값을 가지게 되며, 여기서 <code>1</code>은 해당 행에 해당 범주가 존재함을 나타냅니다.</p>
<p>R의 caret 패키지를 사용하면 이 변환은 단 두 줄의 코드만 필요합니다.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="data_preparation.html#cb82-1" tabindex="-1"></a><span class="fu">library</span>(caret) <span class="co"># dummyVars 함수 포함</span></span>
<span id="cb82-2"><a href="data_preparation.html#cb82-2" tabindex="-1"></a><span class="fu">library</span>(dplyr) <span class="co"># 데이터 정제 라이브러리</span></span>
<span id="cb82-3"><a href="data_preparation.html#cb82-3" tabindex="-1"></a><span class="fu">library</span>(funModeling) <span class="co"># df_status 함수 포함</span></span>
<span id="cb82-4"><a href="data_preparation.html#cb82-4" tabindex="-1"></a>  </span>
<span id="cb82-5"><a href="data_preparation.html#cb82-5" tabindex="-1"></a><span class="co"># 범주형 변수 확인</span></span>
<span id="cb82-6"><a href="data_preparation.html#cb82-6" tabindex="-1"></a>status<span class="ot">=</span><span class="fu">df_status</span>(heart_disease)</span></code></pre></div>
<pre><code>##                  variable q_zeros p_zeros q_na p_na q_inf p_inf    type unique
## 1                     age       0    0.00    0 0.00     0     0 integer     41
## 2                  gender       0    0.00    0 0.00     0     0  factor      2
## 3              chest_pain       0    0.00    0 0.00     0     0  factor      4
## 4  resting_blood_pressure       0    0.00    0 0.00     0     0 integer     50
## 5       serum_cholestoral       0    0.00    0 0.00     0     0 integer    152
## 6     fasting_blood_sugar     258   85.15    0 0.00     0     0  factor      2
## 7         resting_electro     151   49.83    0 0.00     0     0  factor      3
## 8          max_heart_rate       0    0.00    0 0.00     0     0 integer     91
## 9             exer_angina     204   67.33    0 0.00     0     0 integer      2
## 10                oldpeak      99   32.67    0 0.00     0     0 numeric     40
## 11                  slope       0    0.00    0 0.00     0     0 integer      3
## 12      num_vessels_flour     176   58.09    4 1.32     0     0 integer      4
## 13                   thal       0    0.00    2 0.66     0     0  factor      3
## 14 heart_disease_severity     164   54.13    0 0.00     0     0 integer      5
## 15           exter_angina     204   67.33    0 0.00     0     0  factor      2
## 16      has_heart_disease       0    0.00    0 0.00     0     0  factor      2</code></pre>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="data_preparation.html#cb84-1" tabindex="-1"></a><span class="fu">filter</span>(status,  type <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;factor&quot;</span>, <span class="st">&quot;character&quot;</span>)) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable)</span></code></pre></div>
<pre><code>##              variable
## 1              gender
## 2          chest_pain
## 3 fasting_blood_sugar
## 4     resting_electro
## 5                thal
## 6        exter_angina
## 7   has_heart_disease</code></pre>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="data_preparation.html#cb86-1" tabindex="-1"></a><span class="co"># 모든 범주형 변수(팩터 및 문자열)를 수치형 변수로 변환합니다.</span></span>
<span id="cb86-2"><a href="data_preparation.html#cb86-2" tabindex="-1"></a><span class="co"># 기존 변수를 생략하므로 변환 후에 제거할 필요가 없으며, 데이터가 바로 사용 가능합니다.</span></span>
<span id="cb86-3"><a href="data_preparation.html#cb86-3" tabindex="-1"></a>dmy <span class="ot">=</span> <span class="fu">dummyVars</span>(<span class="st">&quot; ~ .&quot;</span>, <span class="at">data =</span> heart_disease)</span>
<span id="cb86-4"><a href="data_preparation.html#cb86-4" tabindex="-1"></a>heart_disease_2 <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="fu">predict</span>(dmy, <span class="at">newdata =</span> heart_disease))</span>
<span id="cb86-5"><a href="data_preparation.html#cb86-5" tabindex="-1"></a></span>
<span id="cb86-6"><a href="data_preparation.html#cb86-6" tabindex="-1"></a><span class="co"># 새로운 수치형 데이터셋 확인:</span></span>
<span id="cb86-7"><a href="data_preparation.html#cb86-7" tabindex="-1"></a><span class="fu">colnames</span>(heart_disease_2)</span></code></pre></div>
<pre><code>##  [1] &quot;age&quot;                    &quot;gender.female&quot;          &quot;gender.male&quot;           
##  [4] &quot;chest_pain.1&quot;           &quot;chest_pain.2&quot;           &quot;chest_pain.3&quot;          
##  [7] &quot;chest_pain.4&quot;           &quot;resting_blood_pressure&quot; &quot;serum_cholestoral&quot;     
## [10] &quot;fasting_blood_sugar.0&quot;  &quot;fasting_blood_sugar.1&quot;  &quot;resting_electro.0&quot;     
## [13] &quot;resting_electro.1&quot;      &quot;resting_electro.2&quot;      &quot;max_heart_rate&quot;        
## [16] &quot;exer_angina&quot;            &quot;oldpeak&quot;                &quot;slope&quot;                 
## [19] &quot;num_vessels_flour&quot;      &quot;thal.3&quot;                 &quot;thal.6&quot;                
## [22] &quot;thal.7&quot;                 &quot;heart_disease_severity&quot; &quot;exter_angina.0&quot;        
## [25] &quot;exter_angina.1&quot;         &quot;has_heart_disease.no&quot;   &quot;has_heart_disease.yes&quot;</code></pre>
<p>원본 데이터 <code>heart_disease</code>는 범주형 변수 없이 수치형 및 더미 변수만 포함된 <code>heart_disease_2</code>로 변환되었습니다. 새로 생성된 각 변수 명에는 점(<code>.</code>) 뒤에 해당 값이 붙습니다.</p>
<p>예를 들어, 4가지 값(<code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>)을 가질 수 있는 <code>chest_pain</code> 변수의 7번째 환자(행)에 대해 변환 전후를 확인하면 다음과 같습니다.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="data_preparation.html#cb88-1" tabindex="-1"></a><span class="co"># 변환 전</span></span>
<span id="cb88-2"><a href="data_preparation.html#cb88-2" tabindex="-1"></a><span class="fu">as.numeric</span>(heart_disease[<span class="dv">7</span>, <span class="st">&quot;chest_pain&quot;</span>])</span></code></pre></div>
<pre><code>## [1] 4</code></pre>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="data_preparation.html#cb90-1" tabindex="-1"></a><span class="co"># 변환 후</span></span>
<span id="cb90-2"><a href="data_preparation.html#cb90-2" tabindex="-1"></a>heart_disease_2[<span class="dv">7</span>, <span class="fu">c</span>(<span class="st">&quot;chest_pain.1&quot;</span>, <span class="st">&quot;chest_pain.2&quot;</span>, <span class="st">&quot;chest_pain.3&quot;</span>, <span class="st">&quot;chest_pain.4&quot;</span>)]</span></code></pre></div>
<pre><code>##   chest_pain.1 chest_pain.2 chest_pain.3 chest_pain.4
## 7            0            0            0            1</code></pre>
<p>수치형 변수만 유지 및 변형하고 명목형 변수를 제외함으로써, <code>heart_disease_2</code> 데이터는 분석에 바로 사용할 준비가 되었습니다.</p>
<p><code>dummyVars</code>에 대한 더 자세한 정보: <a href="http://amunategui.github.io/dummyVar-Walkthrough/" class="uri">http://amunategui.github.io/dummyVar-Walkthrough/</a></p>
</div>
<div id="범주형인가요-수치형인가요-생각해-봅시다." class="section level3 hasAnchor" number="2.1.5">
<h3><span class="header-section-number">2.1.5</span> 범주형인가요, 수치형인가요? 생각해 봅시다.<a href="data_preparation.html#범주형인가요-수치형인가요-생각해-봅시다." class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>의 값을 가질 수 있는 <code>chest_pain</code> 변수를 생각해 보세요. 이 변수는 범주형인가요, 수치형인가요?</p>
<p>만약 값이 순서가 있다면, 즉 1 &lt; 2 &lt; 3 &lt; 4와 같이 <strong>순서(order)</strong>를 나타낸다면 수치형으로 고려될 수 있습니다.</p>
<p>의사결정 트리 모델을 만든다면, “<code>If chest_pain &gt; 2.5, then...</code>”과 같은 규칙을 발견할 수 있습니다. 이게 말이 될까요? 알고리즘은 실제 존재하지 않는 값(<code>2.5</code>)을 기준으로 변수를 분할하지만, 우리는 이를 “만약 <code>chest_pain</code>이 3 이상이라면…”으로 해석합니다.</p>
<div id="알고리즘처럼-생각하기" class="section level4 hasAnchor" number="2.1.5.1">
<h4><span class="header-section-number">2.1.5.1</span> 알고리즘처럼 생각하기<a href="data_preparation.html#알고리즘처럼-생각하기" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>두 개의 수치형 입력 변수와 하나의 이진 타겟 변수를 생각해 봅시다. 알고리즘은 각 숫자 사이에 무한한 값이 존재한다고 가정하고 두 입력 변수를 평면 위의 점으로 _인식_합니다.</p>
<p>예를 들어, <strong>서포트 벡터 머신</strong>(SVM)은 타겟 변수의 클래스를 분리하기 위해 <em>여러 개의</em> 벡터를 생성합니다. 이 벡터들을 기반으로 <strong>영역(regions)</strong>을 찾습니다. 범주형 변수를 기반으로 이러한 영역을 찾는 것이 가능할까요? 불가능합니다. 이것이 바로 SVM이 인공 신경망과 마찬가지로 수치형 변수만 지원하는 이유입니다.</p>
<div class="figure"><span style="display:block;" id="fig:Support-Vector-Machine"></span>
<img src="data_preparation/svm.png" alt="서포트 벡터 머신 (SVM)" width="200px"  />
<p class="caption">
Figure 2.2: 서포트 벡터 머신 (SVM)
</p>
</div>
<p><em>이미지 출처: ZackWeinberg</em></p>
<p>위 이미지는 세 개의 선을 보여주며, 이는 서로 다른 세 개의 결정 경계 또는 영역을 나타냅니다.</p>
<p>SVM 개념에 대한 빠른 소개를 보려면 다음 짧은 영상을 참고하세요: <a href="https://www.youtube.com/watch?v=1NxnPkZM9bc">SVM Demo</a>.</p>
<p>하지만 의사결정 트리, 랜덤 포레스트, 그레디언트 부스팅 머신과 같은 트리 기반 모델은 그 검색 공간이 영역(SVM과 동일)뿐만 아니라 범주일 수도 있기 때문에 두 가지 유형을 모두 처리할 수 있습니다. 예: “<code>if postal_code is AX441AG and age &gt; 55, then...</code>”.</p>
<p>다시 심장 질환 예제로 돌아가서, <code>chest_pain</code> 변수는 순서를 가지고 있습니다. 이 점을 활용해야 합니다. 왜냐하면 이를 범주형 변수로 변환하면 <strong>정보를 잃게 되기 때문</strong>이며, 이는 데이터 유형을 처리할 때 중요한 포인트입니다.</p>
</div>
<div id="모든-것을-범주형으로-처리하는-것이-해결책일까요" class="section level4 hasAnchor" number="2.1.5.2">
<h4><span class="header-section-number">2.1.5.2</span> 모든 것을 범주형으로 처리하는 것이 해결책일까요?<a href="data_preparation.html#모든-것을-범주형으로-처리하는-것이-해결책일까요" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>아니요… 수치형 변수는 순서 덕분에 명목형 변수보다 더 많은 정보를 담고 있습니다. 범주형 변수에서는 값들을 직접 비교할 수 없습니다. 예를 들어, <code>If postal code is higher than "AX2004-P"</code>와 같은 규칙을 만드는 것은 불가능합니다.</p>
<p>명목형 변수의 값들은 참조할 다른 변수(보통 예측할 결과값)가 있을 때만 비교될 수 있습니다.</p>
<p>예를 들어, 우편 번호 “AX2004-P”가 “MA3942-H”보다 <em>더 높은</em> 이유는 해당 지역에 사진 강의 수강에 관심 있는 사람들이 더 많기 때문일 수 있습니다.</p>
<p>또한, <strong>고카디널리티(high cardinality)</strong>는 범주형 변수에서 문제가 될 수 있습니다. 예를 들어, 수백 개의 다른 값을 포함하는 <code>postal code</code> 변수가 그렇습니다. 이 책은 <a href="data_preparation.html#high_cardinality_descriptive_stats">기술 통계량</a> 및 <a href="data_preparation.html#high_cardinality_predictive_modeling">예측 모델링</a> 장에서 고카디널리티 변수를 처리하는 방법을 다룹니다.</p>
<p>어쨌든 모든 변수를 범주형으로 변환하고 어떤 일이 일어나는지 직접 _무료 테스트_를 해볼 수 있습니다. 수치형 변수일 때의 결과와 비교해 보세요. 테스트를 위해 Kappa나 ROC 통계량과 같은 좋은 오차 측정 지표를 사용하고, 결과를 교차 검증하는 것을 잊지 마세요.</p>
</div>
<div id="범주형을-수치형-변수로-변환할-때-주의할-점" class="section level4 hasAnchor" number="2.1.5.3">
<h4><span class="header-section-number">2.1.5.3</span> 범주형을 수치형 변수로 변환할 때 주의할 점<a href="data_preparation.html#범주형을-수치형-변수로-변환할-때-주의할-점" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>범주형 변수를 수치형으로 변환해야 하는 상황을 가정해 봅시다. 이전 사례와 같이 각 범주에 다른 숫자를 할당하는 <strong>변환(transformation)</strong>을 시도해 보겠습니다.</p>
<p>이러한 변환을 할 때는 변수에 <strong>순서를 도입</strong>하게 되므로 주의해야 합니다.</p>
<p>네 개의 행을 가진 다음 데이터를 고려해 보세요. 처음 두 변수는 <code>visits</code>와 <code>postal_code</code>입니다 (이는 두 개의 입력 변수이거나, <code>visits</code>를 입력으로 하고 <code>postal_code</code>를 출력으로 사용할 때 모두 해당됩니다).</p>
<p>다음 코드는 두 가지 기준에 따라 변환된 <code>postal_code</code>에 따른 <code>visits</code>를 보여줍니다.</p>
<ul>
<li><code>transformation_1</code>: 주어진 순서에 따라 일련번호를 할당.</li>
<li><code>transformation_2</code>: <code>visits</code>의 수에 따라 숫자를 할당.</li>
</ul>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb92-1"><a href="data_preparation.html#cb92-1" tabindex="-1"></a><span class="co"># creating data -toy- sample </span></span>
<span id="cb92-2"><a href="data_preparation.html#cb92-2" tabindex="-1"></a>df_pc<span class="ot">=</span><span class="fu">data.frame</span>(<span class="at">visits=</span><span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">59</span>, <span class="dv">27</span>, <span class="dv">33</span>), <span class="at">postal_code=</span><span class="fu">c</span>(<span class="st">&quot;AA1&quot;</span>, <span class="st">&quot;BA5&quot;</span>, <span class="st">&quot;CG3&quot;</span>, <span class="st">&quot;HJ1&quot;</span>), <span class="at">transformation_1=</span><span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>), <span class="at">transformation_2=</span><span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">3</span> ))</span>
<span id="cb92-3"><a href="data_preparation.html#cb92-3" tabindex="-1"></a></span>
<span id="cb92-4"><a href="data_preparation.html#cb92-4" tabindex="-1"></a><span class="co"># printing table</span></span>
<span id="cb92-5"><a href="data_preparation.html#cb92-5" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(df_pc)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">visits</th>
<th align="left">postal_code</th>
<th align="right">transformation_1</th>
<th align="right">transformation_2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">10</td>
<td align="left">AA1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">59</td>
<td align="left">BA5</td>
<td align="right">2</td>
<td align="right">4</td>
</tr>
<tr class="odd">
<td align="right">27</td>
<td align="left">CG3</td>
<td align="right">3</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="right">33</td>
<td align="left">HJ1</td>
<td align="right">4</td>
<td align="right">3</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb93-1"><a href="data_preparation.html#cb93-1" tabindex="-1"></a><span class="fu">library</span>(gridExtra)</span>
<span id="cb93-2"><a href="data_preparation.html#cb93-2" tabindex="-1"></a></span>
<span id="cb93-3"><a href="data_preparation.html#cb93-3" tabindex="-1"></a><span class="co"># transformation 1</span></span>
<span id="cb93-4"><a href="data_preparation.html#cb93-4" tabindex="-1"></a>plot_1<span class="ot">=</span><span class="fu">ggplot</span>(df_pc, <span class="fu">aes</span>(<span class="at">x=</span>transformation_1, <span class="at">y=</span>visits, <span class="at">label=</span>postal_code)) <span class="sc">+</span>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color=</span>postal_code), <span class="at">size=</span><span class="dv">4</span>)<span class="sc">+</span> <span class="fu">geom_smooth</span>(<span class="at">method=</span>loess, <span class="at">group=</span><span class="dv">1</span>, <span class="at">se=</span><span class="cn">FALSE</span>, <span class="at">color=</span><span class="st">&quot;lightblue&quot;</span>, <span class="at">linetype=</span><span class="st">&quot;dashed&quot;</span>) <span class="sc">+</span> <span class="fu">theme_minimal</span>()  <span class="sc">+</span> <span class="fu">theme</span>(<span class="at">legend.position=</span><span class="st">&quot;none&quot;</span>) <span class="sc">+</span> <span class="fu">geom_label</span>(<span class="fu">aes</span>(<span class="at">fill =</span> <span class="fu">factor</span>(postal_code)), <span class="at">colour =</span> <span class="st">&quot;white&quot;</span>, <span class="at">fontface =</span> <span class="st">&quot;bold&quot;</span>)</span>
<span id="cb93-5"><a href="data_preparation.html#cb93-5" tabindex="-1"></a>  </span>
<span id="cb93-6"><a href="data_preparation.html#cb93-6" tabindex="-1"></a></span>
<span id="cb93-7"><a href="data_preparation.html#cb93-7" tabindex="-1"></a><span class="co"># transformation 2</span></span>
<span id="cb93-8"><a href="data_preparation.html#cb93-8" tabindex="-1"></a>plot_2<span class="ot">=</span><span class="fu">ggplot</span>(df_pc, <span class="fu">aes</span>(<span class="at">x=</span>transformation_2, <span class="at">y=</span>visits, <span class="at">label=</span>postal_code)) <span class="sc">+</span>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">color=</span>postal_code), <span class="at">size=</span><span class="dv">4</span>)<span class="sc">+</span> <span class="fu">geom_smooth</span>(<span class="at">method=</span>lm, <span class="at">group=</span><span class="dv">1</span>, <span class="at">se=</span><span class="cn">FALSE</span>, <span class="at">color=</span><span class="st">&quot;lightblue&quot;</span>, <span class="at">linetype=</span><span class="st">&quot;dashed&quot;</span>) <span class="sc">+</span> <span class="fu">theme_minimal</span>()  <span class="sc">+</span> <span class="fu">theme</span>(<span class="at">legend.position=</span><span class="st">&quot;none&quot;</span>) <span class="sc">+</span> <span class="fu">geom_label</span>(<span class="fu">aes</span>(<span class="at">fill =</span> <span class="fu">factor</span>(postal_code)), <span class="at">colour =</span> <span class="st">&quot;white&quot;</span>, <span class="at">fontface =</span> <span class="st">&quot;bold&quot;</span>)</span>
<span id="cb93-9"><a href="data_preparation.html#cb93-9" tabindex="-1"></a>  </span>
<span id="cb93-10"><a href="data_preparation.html#cb93-10" tabindex="-1"></a><span class="co"># 여러 플롯을 나란히 배치</span></span>
<span id="cb93-11"><a href="data_preparation.html#cb93-11" tabindex="-1"></a><span class="fu">grid.arrange</span>(plot_1, plot_2, <span class="at">ncol=</span><span class="dv">2</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:data-types-in-machine-learning"></span>
<img src="02_data_preparation_files/figure-html/data-types-in-machine-learning-1.png" alt="데이터 변환 비교" width="864"  />
<p class="caption">
Figure 2.3: 데이터 변환 비교
</p>
</div>
<p>네 개의 행으로 예측 모델을 구축하는 사람은 아무도 없겠지만, 이 예제의 의도는 관계가 비선형(<code>transformation_1</code>)에서 선형(<code>transformation_2</code>)으로 어떻게 변하는지 보여주기 위함입니다. 이는 예측 모델이 관계를 더 쉽게 설명하고 파악할 수 있게 해줍니다.</p>
<p>데이터 행이 수백만 개로 늘어나고 변수 수가 수백 개로 확장되어도 효과는 동일합니다. 작은 데이터로부터 배우는 것은 이러한 경우에 올바른 접근 방식입니다.</p>
</div>
</div>
<div id="discretizing_numerical_variables" class="section level3 hasAnchor" number="2.1.6">
<h3><span class="header-section-number">2.1.6</span> 수치형 변수 이산화 (Discretizing numerical variables)<a href="data_preparation.html#discretizing_numerical_variables" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>이 프로세스는 데이터를 구간(bin)으로 나누어 범주형으로 변환하는 과정입니다. 멋진 정의를 위해 _위키백과_를 인용하자면: <em>이산화(Discretization)는 연속적인 함수, 모델, 방정식을 이산적인 대응물로 옮기는 과정과 관련이 있습니다.</em></p>
<p>구간(bins)은 버킷(buckets) 또는 세그먼트(segments)라고도 불립니다. 예제를 계속 살펴보겠습니다.</p>
<div id="데이터에-대하여" class="section level4 hasAnchor" number="2.1.6.1">
<h4><span class="header-section-number">2.1.6.1</span> 데이터에 대하여<a href="data_preparation.html#데이터에-대하여" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>이 데이터는 발육 부진(stunted) 아동의 비율에 대한 정보를 담고 있습니다. 이상적인 값은 0입니다.</p>
<blockquote>
<p>이 지표는 발육 부진으로 고통받는 5세 미만 아동의 비율을 반영합니다. 발육이 부진한 아동은 질병과 사망의 위험이 더 큽니다.</p>
</blockquote>
<p>데이터 출처: <a href="https://ourworldindata.org/hunger-and-undernourishment/#undernourishment-of-children">ourworldindata.org, hunger and undernourishment</a>.</p>
<p>먼저, 간단한 <strong>데이터 준비</strong>를 해야 합니다. 각 행은 국가-연도 쌍을 나타내므로, 국가별로 가장 최신 지표 값을 가져와야 합니다.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb94-1"><a href="data_preparation.html#cb94-1" tabindex="-1"></a>data_stunting<span class="ot">=</span><span class="fu">read.csv</span>(<span class="at">file =</span> <span class="st">&quot;https://goo.gl/hFEUfN&quot;</span>, </span>
<span id="cb94-2"><a href="data_preparation.html#cb94-2" tabindex="-1"></a>                       <span class="at">header =</span> T, </span>
<span id="cb94-3"><a href="data_preparation.html#cb94-3" tabindex="-1"></a>                       <span class="at">stringsAsFactors =</span> F)</span>
<span id="cb94-4"><a href="data_preparation.html#cb94-4" tabindex="-1"></a></span>
<span id="cb94-5"><a href="data_preparation.html#cb94-5" tabindex="-1"></a><span class="co"># renaming the metric</span></span>
<span id="cb94-6"><a href="data_preparation.html#cb94-6" tabindex="-1"></a>data_stunting<span class="ot">=</span></span>
<span id="cb94-7"><a href="data_preparation.html#cb94-7" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">rename</span>(</span>
<span id="cb94-8"><a href="data_preparation.html#cb94-8" tabindex="-1"></a>    data_stunting,</span>
<span id="cb94-9"><a href="data_preparation.html#cb94-9" tabindex="-1"></a>    <span class="at">share_stunted_child=</span></span>
<span id="cb94-10"><a href="data_preparation.html#cb94-10" tabindex="-1"></a>      Share.of.stunted.children.under<span class="fl">.5</span></span>
<span id="cb94-11"><a href="data_preparation.html#cb94-11" tabindex="-1"></a>    )</span>
<span id="cb94-12"><a href="data_preparation.html#cb94-12" tabindex="-1"></a></span>
<span id="cb94-13"><a href="data_preparation.html#cb94-13" tabindex="-1"></a><span class="co"># doing the grouping mentioned before</span></span>
<span id="cb94-14"><a href="data_preparation.html#cb94-14" tabindex="-1"></a>d_stunt_grp <span class="ot">=</span> <span class="fu">group_by</span>(data_stunting, Entity) <span class="sc">%&gt;%</span> </span>
<span id="cb94-15"><a href="data_preparation.html#cb94-15" tabindex="-1"></a>  <span class="fu">filter</span>(Year <span class="sc">==</span> <span class="fu">max</span>(Year)) <span class="sc">%&gt;%</span></span>
<span id="cb94-16"><a href="data_preparation.html#cb94-16" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">summarise</span>(<span class="at">share_stunted_child=</span></span>
<span id="cb94-17"><a href="data_preparation.html#cb94-17" tabindex="-1"></a>                     <span class="fu">max</span>(share_stunted_child)</span>
<span id="cb94-18"><a href="data_preparation.html#cb94-18" tabindex="-1"></a>                   )</span></code></pre></div>
<p>가장 표준적인 구간화(binning) 기준은 다음과 같습니다.</p>
<ul>
<li>동일 간격 (Equal range)</li>
<li>동일 빈도 (Equal frequency)</li>
<li>사용자 정의 구간 (Custom bins)</li>
</ul>
<p>아래에서 각각에 대해 설명합니다.</p>
</div>
<div id="동일-간격-equal-range" class="section level4 hasAnchor" number="2.1.6.2">
<h4><span class="header-section-number">2.1.6.2</span> 동일 간격 (Equal range)<a href="data_preparation.html#동일-간격-equal-range" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>데이터 분포를 확인하는 히스토그램에서 흔히 볼 수 있는 방식이지만, 이상치에 매우 취약합니다. 예를 들어 네 개의 구간을 만들려면 (최대값 - 최소값)을 4로 나누어야 합니다.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb95-1"><a href="data_preparation.html#cb95-1" tabindex="-1"></a><span class="co"># funModeling에 equal_freq(이산화) 함수가 포함되어 있습니다.</span></span>
<span id="cb95-2"><a href="data_preparation.html#cb95-2" tabindex="-1"></a><span class="fu">library</span>(funModeling)</span>
<span id="cb95-3"><a href="data_preparation.html#cb95-3" tabindex="-1"></a></span>
<span id="cb95-4"><a href="data_preparation.html#cb95-4" tabindex="-1"></a><span class="co"># ggplot2 it provides &#39;cut_interval&#39; function used to </span></span>
<span id="cb95-5"><a href="data_preparation.html#cb95-5" tabindex="-1"></a><span class="co"># split the variables based on equal range criteria</span></span>
<span id="cb95-6"><a href="data_preparation.html#cb95-6" tabindex="-1"></a><span class="fu">library</span>(ggplot2) </span>
<span id="cb95-7"><a href="data_preparation.html#cb95-7" tabindex="-1"></a></span>
<span id="cb95-8"><a href="data_preparation.html#cb95-8" tabindex="-1"></a><span class="co"># `cut` 함수와 마찬가지로 과학적 표기법을 비활성화하려면</span></span>
<span id="cb95-9"><a href="data_preparation.html#cb95-9" tabindex="-1"></a><span class="co"># `dig.lab=9` 매개변수를 추가하세요.</span></span>
<span id="cb95-10"><a href="data_preparation.html#cb95-10" tabindex="-1"></a>d_stunt_grp<span class="sc">$</span>share_stunted_child_eq_range<span class="ot">=</span></span>
<span id="cb95-11"><a href="data_preparation.html#cb95-11" tabindex="-1"></a>  <span class="fu">cut_interval</span>(d_stunt_grp<span class="sc">$</span>share_stunted_child, <span class="at">n =</span> <span class="dv">4</span>)</span>
<span id="cb95-12"><a href="data_preparation.html#cb95-12" tabindex="-1"></a></span>
<span id="cb95-13"><a href="data_preparation.html#cb95-13" tabindex="-1"></a><span class="co"># The ‘describe’ function from Hmisc package is </span></span>
<span id="cb95-14"><a href="data_preparation.html#cb95-14" tabindex="-1"></a><span class="co"># extremely useful to profile data</span></span>
<span id="cb95-15"><a href="data_preparation.html#cb95-15" tabindex="-1"></a><span class="fu">describe</span>(d_stunt_grp<span class="sc">$</span>share_stunted_child_eq_range)</span></code></pre></div>
<pre><code>## d_stunt_grp$share_stunted_child_eq_range 
##        n  missing distinct 
##      154        0        4 
##                                                           
## Value       [1.3,15.8] (15.8,30.3] (30.3,44.8] (44.8,59.3]
## Frequency           62          45          37          10
## Proportion       0.403       0.292       0.240       0.065</code></pre>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb97-1"><a href="data_preparation.html#cb97-1" tabindex="-1"></a><span class="co"># Plotting the variable</span></span>
<span id="cb97-2"><a href="data_preparation.html#cb97-2" tabindex="-1"></a>p2<span class="ot">=</span><span class="fu">ggplot</span>(d_stunt_grp, </span>
<span id="cb97-3"><a href="data_preparation.html#cb97-3" tabindex="-1"></a>          <span class="fu">aes</span>(share_stunted_child_eq_range)</span>
<span id="cb97-4"><a href="data_preparation.html#cb97-4" tabindex="-1"></a>          ) <span class="sc">+</span></span>
<span id="cb97-5"><a href="data_preparation.html#cb97-5" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">fill=</span><span class="st">&quot;#009E73&quot;</span>) <span class="sc">+</span> </span>
<span id="cb97-6"><a href="data_preparation.html#cb97-6" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span>
<span id="cb97-7"><a href="data_preparation.html#cb97-7" tabindex="-1"></a>p2</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:equal-range-discretization"></span>
<img src="02_data_preparation_files/figure-html/equal-range-discretization-1.png" alt="동일 간격 이산화" width="384"  />
<p class="caption">
Figure 2.4: 동일 간격 이산화
</p>
</div>
<p><code>describe</code> 결과는 변수에 4개의 카테고리가 있음을 알려주며, 괄호/대괄호 사이에 각 카테고리별 총 사례 수(절대값 및 상대값)를 보여줍니다. 예를 들어, 카테고리 <code>(15.8,30.3]</code>은 <code>share_stunted_child</code> 값이 15.8(미포함)에서 30.3(포함) 사이인 모든 사례를 포함합니다.
이 구간은 <code>45</code>번 나타나며 전체 사례의 <code>29%</code>를 차지합니다.</p>
</div>
<div id="equal-frequency-binning" class="section level4 hasAnchor" number="2.1.6.3">
<h4><span class="header-section-number">2.1.6.3</span> 동일 빈도 (Equal frequency)<a href="data_preparation.html#equal-frequency-binning" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>이 기술은 백분위수(percentiles)를 기준으로 각 구간에 동일한 수의 관측치가 들어가도록 그룹화합니다. 백분위수에 대한 자세한 정보는 <a href="appendix.html#appendix-percentiles">부록 1: 백분위수의 마법</a> 장을 참조하세요.</p>
<p><code>funModeling</code> 패키지에는 이 기준에 따라 구간을 생성하는 <code>equal_freq</code> 함수가 포함되어 있습니다.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb98-1"><a href="data_preparation.html#cb98-1" tabindex="-1"></a>d_stunt_grp<span class="sc">$</span>stunt_child_ef<span class="ot">=</span></span>
<span id="cb98-2"><a href="data_preparation.html#cb98-2" tabindex="-1"></a>  <span class="fu">equal_freq</span>(<span class="at">var =</span> d_stunt_grp<span class="sc">$</span>share_stunted_child, </span>
<span id="cb98-3"><a href="data_preparation.html#cb98-3" tabindex="-1"></a>             <span class="at">n_bins =</span> <span class="dv">4</span></span>
<span id="cb98-4"><a href="data_preparation.html#cb98-4" tabindex="-1"></a>             )</span>
<span id="cb98-5"><a href="data_preparation.html#cb98-5" tabindex="-1"></a></span>
<span id="cb98-6"><a href="data_preparation.html#cb98-6" tabindex="-1"></a><span class="co"># profiling variable </span></span>
<span id="cb98-7"><a href="data_preparation.html#cb98-7" tabindex="-1"></a><span class="fu">describe</span>(d_stunt_grp<span class="sc">$</span>stunt_child_ef)</span></code></pre></div>
<pre><code>## d_stunt_grp$stunt_child_ef 
##        n  missing distinct 
##      154        0        4 
##                                                           
## Value      [ 1.3, 9.5) [ 9.5,20.8) [20.8,32.9) [32.9,59.3]
## Frequency           40          37          39          38
## Proportion       0.260       0.240       0.253       0.247</code></pre>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="data_preparation.html#cb100-1" tabindex="-1"></a>p3<span class="ot">=</span><span class="fu">ggplot</span>(d_stunt_grp, <span class="fu">aes</span>(stunt_child_ef)) <span class="sc">+</span> </span>
<span id="cb100-2"><a href="data_preparation.html#cb100-2" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">fill=</span><span class="st">&quot;#CC79A7&quot;</span>) <span class="sc">+</span> <span class="fu">theme_bw</span>()</span>
<span id="cb100-3"><a href="data_preparation.html#cb100-3" tabindex="-1"></a>p3</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:equal-frequency-discretization"></span>
<img src="02_data_preparation_files/figure-html/equal-frequency-discretization-1.png" alt="동일 빈도 예제" width="384"  />
<p class="caption">
Figure 2.5: 동일 빈도 예제
</p>
</div>
<p>이 경우, 4개의 구간을 선택했으므로 각 구간은 약 25%의 점유율을 가집니다.</p>
</div>
<div id="사용자-정의-구간-custom-bins" class="section level4 hasAnchor" number="2.1.6.4">
<h4><span class="header-section-number">2.1.6.4</span> 사용자 정의 구간 (Custom bins)<a href="data_preparation.html#사용자-정의-구간-custom-bins" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>구간을 나눌 지점을 이미 알고 있다면 <code>cut</code> 함수를 사용할 수 있습니다.</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb101-1"><a href="data_preparation.html#cb101-1" tabindex="-1"></a><span class="co"># dig.lab 매개변수는 과학적 표기법을 &quot;비활성화&quot;합니다.</span></span>
<span id="cb101-2"><a href="data_preparation.html#cb101-2" tabindex="-1"></a>d_stunt_grp<span class="sc">$</span>share_stunted_child_custom<span class="ot">=</span></span>
<span id="cb101-3"><a href="data_preparation.html#cb101-3" tabindex="-1"></a>  <span class="fu">cut</span>(d_stunt_grp<span class="sc">$</span>share_stunted_child, </span>
<span id="cb101-4"><a href="data_preparation.html#cb101-4" tabindex="-1"></a>      <span class="at">breaks =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">2</span>, <span class="fl">9.4</span>, <span class="dv">29</span>, <span class="dv">100</span>)</span>
<span id="cb101-5"><a href="data_preparation.html#cb101-5" tabindex="-1"></a>      )</span>
<span id="cb101-6"><a href="data_preparation.html#cb101-6" tabindex="-1"></a></span>
<span id="cb101-7"><a href="data_preparation.html#cb101-7" tabindex="-1"></a><span class="fu">describe</span>(d_stunt_grp<span class="sc">$</span>share_stunted_child_custom)</span></code></pre></div>
<pre><code>## d_stunt_grp$share_stunted_child_custom 
##        n  missing distinct 
##      154        0        4 
##                                               
## Value         (0,2]  (2,9.4] (9.4,29] (29,100]
## Frequency         5       35       65       49
## Proportion    0.032    0.227    0.422    0.318</code></pre>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb103-1"><a href="data_preparation.html#cb103-1" tabindex="-1"></a>p4<span class="ot">=</span><span class="fu">ggplot</span>(d_stunt_grp, <span class="fu">aes</span>(share_stunted_child_custom)) <span class="sc">+</span> </span>
<span id="cb103-2"><a href="data_preparation.html#cb103-2" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">fill=</span><span class="st">&quot;#0072B2&quot;</span>) <span class="sc">+</span> </span>
<span id="cb103-3"><a href="data_preparation.html#cb103-3" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span>
<span id="cb103-4"><a href="data_preparation.html#cb103-4" tabindex="-1"></a>p4</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:discretization-custom-bins"></span>
<img src="02_data_preparation_files/figure-html/discretization-custom-bins-1.png" alt="수동 이산화" width="384"  />
<p class="caption">
Figure 2.6: 수동 이산화
</p>
</div>
<p>각 버킷의 최대값만 정의하면 된다는 점에 유의하세요.</p>
<p>일반적으로 최소값이나 최대값을 모르는 경우가 많습니다. 그런 경우에는 <code>-Inf</code>와 <code>Inf</code> 값을 사용할 수 있습니다. 그렇지 않고 범위 밖의 값을 정의하면 <code>cut</code>은 <code>NA</code> 값을 할당합니다.</p>
<p>최소값과 최대값을 함수를 사용하여 할당하는 것이 좋은 관행입니다. 이 사례에서 변수는 백분율이므로 범위가 0에서 100 사이임을 미리 알고 있지만, ⚠️ <em>만약 범위를 모른다면 어떤 일이 벌어질까요?</em></p>
<p>함수는 절단 지점보다 낮거나 높은 값에 대해 <code>NA</code>를 반환할 것입니다. 한 가지 해결책은 변수의 최소값과 최대값을 가져오는 것입니다.</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb104-1"><a href="data_preparation.html#cb104-1" tabindex="-1"></a><span class="co"># 최소값과 최대값 가져오기</span></span>
<span id="cb104-2"><a href="data_preparation.html#cb104-2" tabindex="-1"></a>min_value<span class="ot">=</span><span class="fu">min</span>(d_stunt_grp<span class="sc">$</span>share_stunted_child)</span>
<span id="cb104-3"><a href="data_preparation.html#cb104-3" tabindex="-1"></a>max_value<span class="ot">=</span><span class="fu">max</span>(d_stunt_grp<span class="sc">$</span>share_stunted_child)</span>
<span id="cb104-4"><a href="data_preparation.html#cb104-4" tabindex="-1"></a></span>
<span id="cb104-5"><a href="data_preparation.html#cb104-5" tabindex="-1"></a><span class="co"># 최소값을 포함하려면 `include.lowest=T`로 설정하세요.</span></span>
<span id="cb104-6"><a href="data_preparation.html#cb104-6" tabindex="-1"></a><span class="co"># 그렇지 않으면 NA로 할당됩니다.</span></span>
<span id="cb104-7"><a href="data_preparation.html#cb104-7" tabindex="-1"></a>d_stunt_grp<span class="sc">$</span>share_stunted_child_custom_2<span class="ot">=</span></span>
<span id="cb104-8"><a href="data_preparation.html#cb104-8" tabindex="-1"></a>  <span class="fu">cut</span>(d_stunt_grp<span class="sc">$</span>share_stunted_child, </span>
<span id="cb104-9"><a href="data_preparation.html#cb104-9" tabindex="-1"></a>      <span class="at">breaks =</span> <span class="fu">c</span>(min_value, <span class="dv">2</span>, <span class="fl">9.4</span>, <span class="dv">29</span>, max_value), </span>
<span id="cb104-10"><a href="data_preparation.html#cb104-10" tabindex="-1"></a>      <span class="at">include.lowest =</span> T)</span>
<span id="cb104-11"><a href="data_preparation.html#cb104-11" tabindex="-1"></a></span>
<span id="cb104-12"><a href="data_preparation.html#cb104-12" tabindex="-1"></a><span class="fu">describe</span>(d_stunt_grp<span class="sc">$</span>share_stunted_child_custom_2)</span></code></pre></div>
<pre><code>## d_stunt_grp$share_stunted_child_custom_2 
##        n  missing distinct 
##      154        0        4 
##                                                   
## Value        [1.3,2]   (2,9.4]  (9.4,29] (29,59.3]
## Frequency          5        35        65        49
## Proportion     0.032     0.227     0.422     0.318</code></pre>
</div>
</div>
<div id="discretization_new_data" class="section level3 hasAnchor" number="2.1.7">
<h3><span class="header-section-number">2.1.7</span> 새로운 데이터에서의 이산화<a href="data_preparation.html#discretization_new_data" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>이러한 모든 변환은 변수의 분포를 기반으로 한 학습 데이터셋이 주어졌을 때 이루어집니다. 동일 빈도 및 동일 간격 이산화의 경우가 그렇습니다. <em>하지만 새로운 데이터가 들어온다면 어떻게 될까요?</em></p>
<p>새로운 최소값이나 최대값이 나타나면 <strong>동일 간격</strong> 방법의 구간 범위에 영향을 미칩니다.
새로운 값이 들어오면 <strong>동일 빈도</strong> 방법에서 보았듯이 백분위수를 기준으로 한 지점들이 이동하게 됩니다.</p>
<p>예를 들어, 제안된 예제에 <code>88</code>, <code>2</code>, <code>7</code>, <code>3</code>이라는 값을 가진 네 개의 사례를 추가한다고 가정해 보겠습니다.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb106-1"><a href="data_preparation.html#cb106-1" tabindex="-1"></a><span class="co"># 4개의 새로운 값이 들어오는 상황 시뮬레이션</span></span>
<span id="cb106-2"><a href="data_preparation.html#cb106-2" tabindex="-1"></a>updated_data<span class="ot">=</span><span class="fu">c</span>(d_stunt_grp<span class="sc">$</span>share_stunted_child, <span class="dv">88</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">3</span>)</span>
<span id="cb106-3"><a href="data_preparation.html#cb106-3" tabindex="-1"></a></span>
<span id="cb106-4"><a href="data_preparation.html#cb106-4" tabindex="-1"></a><span class="co"># 동일 빈도 기준 이산화</span></span>
<span id="cb106-5"><a href="data_preparation.html#cb106-5" tabindex="-1"></a>updated_data_eq_freq<span class="ot">=</span><span class="fu">equal_freq</span>(updated_data,<span class="dv">4</span>)</span>
<span id="cb106-6"><a href="data_preparation.html#cb106-6" tabindex="-1"></a></span>
<span id="cb106-7"><a href="data_preparation.html#cb106-7" tabindex="-1"></a><span class="co"># 결과는...</span></span>
<span id="cb106-8"><a href="data_preparation.html#cb106-8" tabindex="-1"></a><span class="fu">describe</span>(updated_data_eq_freq)</span></code></pre></div>
<pre><code>## updated_data_eq_freq 
##        n  missing distinct 
##      158        0        4 
##                                                           
## Value      [ 1.3, 9.3) [ 9.3,20.6) [20.6,32.9) [32.9,88.0]
## Frequency           40          39          40          39
## Proportion       0.253       0.247       0.253       0.247</code></pre>
<p>이제 이전에 생성한 구간과 비교해 보겠습니다:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb108-1"><a href="data_preparation.html#cb108-1" tabindex="-1"></a><span class="fu">describe</span>(d_stunt_grp<span class="sc">$</span>stunt_child_ef)</span></code></pre></div>
<pre><code>## d_stunt_grp$stunt_child_ef 
##        n  missing distinct 
##      154        0        4 
##                                                           
## Value      [ 1.3, 9.5) [ 9.5,20.8) [20.8,32.9) [32.9,59.3]
## Frequency           40          37          39          38
## Proportion       0.260       0.240       0.253       0.247</code></pre>
<p><strong>모든 구간이 바뀌었습니다!</strong> 😱 이들은 새로운 카테고리이기 때문에, 예측 모델은 이들을 모두 새로운 값으로 인식하여 제대로 처리하지 못할 것입니다.</p>
<p>해결책은 데이터 준비를 할 때 절단 지점(cut points)을 저장해 두는 것입니다. 그런 다음 모델을 운영 환경에서 실행할 때 사용자 정의 구간 이산화를 사용하면 모든 새로운 사례가 적절한 카테고리에 강제로 들어가게 됩니다. 이렇게 하면 예측 모델은 항상 동일한 것을 보게 됩니다.</p>
<p>해결책은 다음 섹션에 있습니다.</p>
</div>
<div id="data-discretization" class="section level3 hasAnchor" number="2.1.8">
<h3><span class="header-section-number">2.1.8</span> 자동 데이터 프레임 이산화<a href="data_preparation.html#data-discretization" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><code>funModeling</code> 패키지(버전 1.6.6 이상)는 이산화 작업을 돕기 위해 두 가지 함수인 <code>discretize_get_bins</code>와 <code>discretize_df</code>를 도입했습니다.</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb110-1"><a href="data_preparation.html#cb110-1" tabindex="-1"></a><span class="co"># 라이브러리 로드</span></span>
<span id="cb110-2"><a href="data_preparation.html#cb110-2" tabindex="-1"></a><span class="co"># install.packages(&quot;funModeling&quot;)</span></span>
<span id="cb110-3"><a href="data_preparation.html#cb110-3" tabindex="-1"></a><span class="fu">library</span>(funModeling)</span>
<span id="cb110-4"><a href="data_preparation.html#cb110-4" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span></code></pre></div>
<p>예시를 하나 살펴보겠습니다. 먼저 현재 데이터 유형을 확인합니다.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb111-1"><a href="data_preparation.html#cb111-1" tabindex="-1"></a><span class="fu">df_status</span>(heart_disease) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable, type, unique, q_na) <span class="sc">%&gt;%</span> <span class="fu">arrange</span>(type)</span></code></pre></div>
<pre><code>##                  variable q_zeros p_zeros q_na p_na q_inf p_inf    type unique
## 1                     age       0    0.00    0 0.00     0     0 integer     41
## 2                  gender       0    0.00    0 0.00     0     0  factor      2
## 3              chest_pain       0    0.00    0 0.00     0     0  factor      4
## 4  resting_blood_pressure       0    0.00    0 0.00     0     0 integer     50
## 5       serum_cholestoral       0    0.00    0 0.00     0     0 integer    152
## 6     fasting_blood_sugar     258   85.15    0 0.00     0     0  factor      2
## 7         resting_electro     151   49.83    0 0.00     0     0  factor      3
## 8          max_heart_rate       0    0.00    0 0.00     0     0 integer     91
## 9             exer_angina     204   67.33    0 0.00     0     0 integer      2
## 10                oldpeak      99   32.67    0 0.00     0     0 numeric     40
## 11                  slope       0    0.00    0 0.00     0     0 integer      3
## 12      num_vessels_flour     176   58.09    4 1.32     0     0 integer      4
## 13                   thal       0    0.00    2 0.66     0     0  factor      3
## 14 heart_disease_severity     164   54.13    0 0.00     0     0 integer      5
## 15           exter_angina     204   67.33    0 0.00     0     0  factor      2
## 16      has_heart_disease       0    0.00    0 0.00     0     0  factor      2</code></pre>
<pre><code>##                  variable    type unique q_na
## 1                  gender  factor      2    0
## 2              chest_pain  factor      4    0
## 3     fasting_blood_sugar  factor      2    0
## 4         resting_electro  factor      3    0
## 5                    thal  factor      3    2
## 6            exter_angina  factor      2    0
## 7       has_heart_disease  factor      2    0
## 8                     age integer     41    0
## 9  resting_blood_pressure integer     50    0
## 10      serum_cholestoral integer    152    0
## 11         max_heart_rate integer     91    0
## 12            exer_angina integer      2    0
## 13                  slope integer      3    0
## 14      num_vessels_flour integer      4    4
## 15 heart_disease_severity integer      5    0
## 16                oldpeak numeric     40    0</code></pre>
<p>팩터(factor), 정수(integer), 수치형(numeric) 변수들이 섞여 있습니다! 변환은 두 단계로 이루어집니다. 첫째, 각 세그먼트가 시작되는 절단값 또는 임계값을 가져옵니다. 둘째, 해당 임계값을 사용하여 변수를 범주형으로 변환합니다.</p>
<p>다음 예제에서는 <code>max_heart_rate</code>와 <code>oldpeak</code> 두 변수를 이산화할 것입니다. 또한 결측값에 대해 함수가 어떻게 작동하는지 테스트하기 위해 <code>oldpeak</code>에 몇 가지 <code>NA</code> 값을 도입하겠습니다.</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb114-1"><a href="data_preparation.html#cb114-1" tabindex="-1"></a><span class="co"># creating a copy to keep original data clean</span></span>
<span id="cb114-2"><a href="data_preparation.html#cb114-2" tabindex="-1"></a>heart_disease_2<span class="ot">=</span>heart_disease</span>
<span id="cb114-3"><a href="data_preparation.html#cb114-3" tabindex="-1"></a></span>
<span id="cb114-4"><a href="data_preparation.html#cb114-4" tabindex="-1"></a><span class="co"># Introducing some missing values in the first 30 rows of the oldpeak variable</span></span>
<span id="cb114-5"><a href="data_preparation.html#cb114-5" tabindex="-1"></a>heart_disease_2<span class="sc">$</span>oldpeak[<span class="dv">1</span><span class="sc">:</span><span class="dv">30</span>]<span class="ot">=</span><span class="cn">NA</span></span></code></pre></div>
<p>1단계) 각 입력 변수에 대해 구간 임계값 가져오기:</p>
<p><code>discretize_get_bins</code>는 <code>discretize_df</code> 함수에서 사용될 데이터 프레임을 반환하며, 이 함수는 최종 처리된 데이터 프레임을 반환합니다.</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb115-1"><a href="data_preparation.html#cb115-1" tabindex="-1"></a>d_bins<span class="ot">=</span><span class="fu">discretize_get_bins</span>(<span class="at">data=</span>heart_disease_2, <span class="at">input=</span><span class="fu">c</span>(<span class="st">&quot;max_heart_rate&quot;</span>, <span class="st">&quot;oldpeak&quot;</span>), <span class="at">n_bins=</span><span class="dv">5</span>)</span></code></pre></div>
<pre><code>## Variables processed: max_heart_rate, oldpeak</code></pre>
<div class="sourceCode" id="cb117"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb117-1"><a href="data_preparation.html#cb117-1" tabindex="-1"></a><span class="co"># `d_bins` 객체 확인:</span></span>
<span id="cb117-2"><a href="data_preparation.html#cb117-2" tabindex="-1"></a>d_bins</span></code></pre></div>
<pre><code>##         variable                cuts
## 1 max_heart_rate 131|147|160|171|Inf
## 2        oldpeak   0.1|0.3|1.1|2|Inf</code></pre>
<p>매개변수:</p>
<ul>
<li><code>data</code>: 처리할 변수가 포함된 데이터 프레임.</li>
<li><code>input</code>: 변수 이름을 포함하는 문자열 벡터.</li>
<li><code>n_bins</code>: 이산화된 데이터에서 가질 구간/세그먼트의 수.</li>
</ul>
<p>각 변수에 대한 각 임계값 지점(또는 상한 경계)을 확인할 수 있습니다.</p>
<p><strong>참고</strong>: 버전 1.6.6에서 1.6.7로의 변경 사항:</p>
<ul>
<li><code>discretize_get_bins</code>는 해당 값이 항상 최소값으로 간주되었기 때문에 <code>-Inf</code> 임계값을 생성하지 않습니다.</li>
<li>단일 값 카테고리는 이제 범위로 표시됩니다. 예를 들어 <code>"5"</code>였던 것은 이제 <code>"[5, 6)"</code>으로 표시됩니다.</li>
<li>버킷 포맷이 변경되었을 수 있으므로, 이 함수를 운영 환경에서 사용 중이었다면 새로운 값을 확인해야 합니다.</li>
</ul>
<p>다음 단계로 넘어갈 시간입니다!</p>
<p>2단계) 각 변수에 임계값 적용하기:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb119-1"><a href="data_preparation.html#cb119-1" tabindex="-1"></a><span class="co"># 이제 동일한 데이터 프레임이나 새로운 데이터 프레임(예: 시간이 지남에 따라 데이터가 변하는 </span></span>
<span id="cb119-2"><a href="data_preparation.html#cb119-2" tabindex="-1"></a><span class="co"># 예측 모델)에 적용할 수 있습니다.</span></span>
<span id="cb119-3"><a href="data_preparation.html#cb119-3" tabindex="-1"></a>heart_disease_discretized <span class="ot">=</span> </span>
<span id="cb119-4"><a href="data_preparation.html#cb119-4" tabindex="-1"></a>  <span class="fu">discretize_df</span>(<span class="at">data=</span>heart_disease_2, </span>
<span id="cb119-5"><a href="data_preparation.html#cb119-5" tabindex="-1"></a>                <span class="at">data_bins=</span>d_bins, </span>
<span id="cb119-6"><a href="data_preparation.html#cb119-6" tabindex="-1"></a>                <span class="at">stringsAsFactors=</span>T)</span></code></pre></div>
<pre><code>## Warning: `funs()` was deprecated in dplyr 0.8.0.
## ℹ Please use a list of either functions or lambdas:
## 
## # Simple named list: list(mean = mean, median = median)
## 
## # Auto named with `tibble::lst()`: tibble::lst(mean, median)
## 
## # Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))
## ℹ The deprecated feature was likely used in the funModeling package.
##   Please report the issue at &lt;https://github.com/pablo14/funModeling/issues&gt;.
## This warning is displayed once per session.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.</code></pre>
<pre><code>## Variables processed: max_heart_rate, oldpeak</code></pre>
<p>매개변수:</p>
<ul>
<li><code>data</code>: 이산화할 수치형 변수가 포함된 데이터 프레임.</li>
<li><code>data_bins</code>: <code>discretize_get_bins</code>가 반환한 데이터 프레임. 사용자가 직접 변경하는 경우, 예제에 표시된 대로 각 상한 경계는 파이프 문자(<code>|</code>)로 구분되어야 합니다.</li>
<li><code>stringsAsFactors</code>: 기본값은 <code>TRUE</code>이며, 최종 변수는 팩터(문자열 대신)가 되어 시각화할 때 유용합니다.</li>
</ul>
<div id="최종-결과-및-플롯" class="section level4 hasAnchor" number="2.1.8.1">
<h4><span class="header-section-number">2.1.8.1</span> 최종 결과 및 플롯<a href="data_preparation.html#최종-결과-및-플롯" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>변환 전후:</p>
<pre><code>##   max_heart_rate_before max_heart_rate_after oldpeak_before oldpeak_after
## 1                   171          [ 171, Inf]             NA           NA.
## 2                   114          [-Inf, 131)             NA           NA.
## 3                   151          [ 147, 160)            1.8   [ 1.1, 2.0)
## 4                   160          [ 160, 171)            1.4   [ 1.1, 2.0)
## 5                   158          [ 147, 160)            0.0   [-Inf, 0.1)
## 6                   161          [ 160, 171)            0.5   [ 0.3, 1.1)</code></pre>
<p>최종 분포:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb123-1"><a href="data_preparation.html#cb123-1" tabindex="-1"></a><span class="fu">freq</span>(heart_disease_discretized <span class="sc">%&gt;%</span> </span>
<span id="cb123-2"><a href="data_preparation.html#cb123-2" tabindex="-1"></a>           <span class="fu">select</span>(max_heart_rate,oldpeak),</span>
<span id="cb123-3"><a href="data_preparation.html#cb123-3" tabindex="-1"></a>     <span class="at">plot =</span> F)</span></code></pre></div>
<pre><code>##   max_heart_rate frequency percentage cumulative_perc
## 1    [-Inf, 131)        63      20.79           20.79
## 2    [ 147, 160)        62      20.46           41.25
## 3    [ 160, 171)        62      20.46           61.71
## 4    [ 131, 147)        59      19.47           81.18
## 5    [ 171, Inf]        57      18.81          100.00
## 
##       oldpeak frequency percentage cumulative_perc
## 1 [-Inf, 0.1)        97      32.01           32.01
## 2 [ 0.3, 1.1)        54      17.82           49.83
## 3 [ 1.1, 2.0)        54      17.82           67.65
## 4 [ 2.0, Inf]        50      16.50           84.15
## 5         NA.        30       9.90           94.05
## 6 [ 0.1, 0.3)        18       5.94          100.00</code></pre>
<pre><code>## [1] &quot;Variables processed: max_heart_rate, oldpeak&quot;</code></pre>
<div class="sourceCode" id="cb126"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb126-1"><a href="data_preparation.html#cb126-1" tabindex="-1"></a>p5<span class="ot">=</span><span class="fu">ggplot</span>(heart_disease_discretized, </span>
<span id="cb126-2"><a href="data_preparation.html#cb126-2" tabindex="-1"></a>          <span class="fu">aes</span>(max_heart_rate)) <span class="sc">+</span> </span>
<span id="cb126-3"><a href="data_preparation.html#cb126-3" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">fill=</span><span class="st">&quot;#0072B2&quot;</span>) <span class="sc">+</span> </span>
<span id="cb126-4"><a href="data_preparation.html#cb126-4" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span> </span>
<span id="cb126-5"><a href="data_preparation.html#cb126-5" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">axis.text.x =</span> </span>
<span id="cb126-6"><a href="data_preparation.html#cb126-6" tabindex="-1"></a>          <span class="fu">element_text</span>(<span class="at">angle =</span> <span class="dv">45</span>, <span class="at">vjust =</span> <span class="dv">1</span>, <span class="at">hjust=</span><span class="dv">1</span>)</span>
<span id="cb126-7"><a href="data_preparation.html#cb126-7" tabindex="-1"></a>        )</span>
<span id="cb126-8"><a href="data_preparation.html#cb126-8" tabindex="-1"></a></span>
<span id="cb126-9"><a href="data_preparation.html#cb126-9" tabindex="-1"></a>p6<span class="ot">=</span><span class="fu">ggplot</span>(heart_disease_discretized, </span>
<span id="cb126-10"><a href="data_preparation.html#cb126-10" tabindex="-1"></a>          <span class="fu">aes</span>(oldpeak)) <span class="sc">+</span> </span>
<span id="cb126-11"><a href="data_preparation.html#cb126-11" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">fill=</span><span class="st">&quot;#CC79A7&quot;</span>) <span class="sc">+</span></span>
<span id="cb126-12"><a href="data_preparation.html#cb126-12" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span> </span>
<span id="cb126-13"><a href="data_preparation.html#cb126-13" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">axis.text.x =</span> </span>
<span id="cb126-14"><a href="data_preparation.html#cb126-14" tabindex="-1"></a>          <span class="fu">element_text</span>(<span class="at">angle =</span> <span class="dv">45</span>, <span class="at">vjust =</span> <span class="dv">1</span>, <span class="at">hjust=</span><span class="dv">1</span>)</span>
<span id="cb126-15"><a href="data_preparation.html#cb126-15" tabindex="-1"></a>        )</span>
<span id="cb126-16"><a href="data_preparation.html#cb126-16" tabindex="-1"></a></span>
<span id="cb126-17"><a href="data_preparation.html#cb126-17" tabindex="-1"></a>gridExtra<span class="sc">::</span><span class="fu">grid.arrange</span>(p5, p6, <span class="at">ncol=</span><span class="dv">2</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:binning-variable"></span>
<img src="02_data_preparation_files/figure-html/binning-variable-1.png" alt="자동 이산화 결과" width="672"  />
<p class="caption">
Figure 2.7: 자동 이산화 결과
</p>
</div>
<p><strong>동일 빈도</strong>를 계산할 때 <code>oldpeak</code> 변수에서 볼 수 있듯이 버킷당 동일한 수의 사례를 얻는 것이 항상 가능한 것은 아닙니다.</p>
</div>
<div id="na-처리" class="section level4 hasAnchor" number="2.1.8.2">
<h4><span class="header-section-number">2.1.8.2</span> NA 처리<a href="data_preparation.html#na-처리" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><code>NA</code> 값과 관련하여, 새로운 <code>oldpeak</code> 변수에는 6개의 카테고리가 있습니다. 즉, <code>n_bins=5</code>에서 정의된 5개 카테고리와 <code>NA.</code> 값입니다. 끝에 있는 점은 결측값의 존재를 나타냅니다.</p>
</div>
<div id="추가-정보" class="section level4 hasAnchor" number="2.1.8.3">
<h4><span class="header-section-number">2.1.8.3</span> 추가 정보<a href="data_preparation.html#추가-정보" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li><code>discretize_df</code>는 결측값을 <code>NA.</code> 문자열로 변환하지 않고는 절대 <code>NA</code>를 반환하지 않습니다.</li>
<li><code>n_bins</code>는 모든 변수에 대한 구간 수를 설정합니다.</li>
<li><code>input</code>이 누락된 경우, 고유 값의 수가 구간 수(<code>n_bins</code>)보다 큰 모든 수치형/정수형 변수에 대해 실행됩니다.</li>
<li><code>input</code>에 정의된 변수만 처리되며 나머지 변수는 <strong>전혀 수정되지 않습니다</strong>.</li>
<li><code>discretize_get_bins</code>는 단지 데이터 프레임을 반환하므로 텍스트 파일이나 R 세션에서 필요에 따라 직접 수정할 수 있습니다.</li>
</ul>
</div>
<div id="새로운-데이터에서의-이산화" class="section level4 hasAnchor" number="2.1.8.4">
<h4><span class="header-section-number">2.1.8.4</span> 새로운 데이터에서의 이산화<a href="data_preparation.html#새로운-데이터에서의-이산화" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>우리 데이터에서 <code>max_heart_rate</code>의 최소값은 71입니다. 데이터 준비 과정은 새로운 데이터에 대해 견고해야 합니다. 예를 들어 <code>max_heart_rate</code>가 68인 새로운 환자가 들어오면, 현재 프로세스는 이 환자를 가장 낮은 카테고리에 할당할 것입니다.</p>
<p>다른 패키지의 다른 함수에서는 범위를 벗어났기 때문에 <code>NA</code>를 반환할 수도 있습니다.</p>
<p>앞서 언급했듯이 시간이 지남에 따라 새로운 데이터가 들어오면 새로운 최소값이나 최대값이 나타날 가능성이 큽니다. 이는 프로세스를 방해할 수 있습니다. 이를 해결하기 위해 <code>discretize_df</code>는 항상 <code>-Inf</code>/<code>Inf</code>를 최소값/최대값으로 가집니다. 따라서 최소값보다 낮거나 최대값보다 높은 새로운 값은 각각 가장 낮거나 높은 세그먼트에 추가됩니다.</p>
<p><code>discretize_get_bins</code>가 반환한 데이터 프레임은 새로운 데이터에 적용하기 위해 저장되어야 합니다. 만약 이산화 과정이 새로운 데이터와 함께 실행될 의도가 없다면, 두 개의 함수를 가질 이유가 없으며 하나면 충분할 것입니다. 또한 <code>discretize_get_bins</code>의 결과를 저장할 필요도 없을 것입니다.</p>
<p>이러한 2단계 접근 방식을 통해 두 가지 경우를 모두 처리할 수 있습니다.</p>
</div>
<div id="단계-이산화에-대한-결론" class="section level4 hasAnchor" number="2.1.8.5">
<h4><span class="header-section-number">2.1.8.5</span> 2단계 이산화에 대한 결론<a href="data_preparation.html#단계-이산화에-대한-결론" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><code>discretize_get_bins</code> + <code>discretize_df</code>의 사용은 바로 사용할 준비가 된 깨끗한 데이터 프레임을 통해 빠른 데이터 준비를 제공합니다. 각 세그먼트가 어디서 시작하고 끝나는지 명확하게 보여주며, 통계 보고서를 작성할 때 필수적입니다.</p>
<p>새로운 데이터에서 새로운 최소값/최대값을 대할 때 <em>실패하지 않기로</em> 결정한 것은 <strong>단순한 결정</strong>일 뿐입니다. 어떤 문맥에서는 실패하는 것이 바람직한 행동일 수도 있습니다.</p>
<p><strong>인간의 개입</strong>: 데이터 프레임을 이산화하는 가장 쉬운 방법은 예제에서 본 것처럼 모든 변수에 동일한 수의 구간을 적용하는 것이지만, 튜닝이 필요한 경우에는 일부 변수에 <strong>다른 수의 구간</strong>이 필요할 수 있습니다. 예를 들어, 분산이 적은 변수는 적은 수의 구간으로도 잘 작동할 수 있습니다.</p>
<p>세그먼트 수의 일반적인 값은 3, 5, 10 또는 20(그 이상은 아님)이 될 수 있습니다. 이 결정은 데이터 과학자의 몫입니다.</p>
</div>
<div id="보너스-트랙-트레이드오프의-예술" class="section level4 hasAnchor" number="2.1.8.6">
<h4><span class="header-section-number">2.1.8.6</span> 보너스 트랙: 트레이드오프의 예술 ⚖️<a href="data_preparation.html#보너스-트랙-트레이드오프의-예술" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li>많은 수의 구간 =&gt; 더 많은 노이즈 포착.</li>
<li>적은 수의 구간 =&gt; 과도한 단순화, 변동성 감소.</li>
</ul>
<p>이 용어들이 머신러닝의 다른 용어들과 비슷하게 들리나요?</p>
<p>정답은: <strong>네!</strong> 입니다. 단 한 가지 예만 들자면, 예측 모델에서 변수를 추가하거나 제거하는 사이의 트레이드오프와 같습니다.</p>
<ul>
<li>더 많은 변수: 과적합(overfitting) 경고 (너무 상세한 예측 모델).</li>
<li>더 적은 변수: 과소적합(underfitting) 위험 (일반적인 패턴을 포착하기에 정보 부족).</li>
</ul>
<p><em>수천 년 동안 동양 철학이 지적해 왔듯이, 하나의 가치와 그 반대 사이에서 올바른 균형을 찾는 것은 하나의 예술입니다.</em></p>
</div>
</div>
<div id="최종-생각-1" class="section level3 hasAnchor" number="2.1.9">
<h3><span class="header-section-number">2.1.9</span> 최종 생각<a href="data_preparation.html#최종-생각-1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>보았듯이, 이산화나 데이터 준비에 있어 <strong>공짜 점심은 없습니다</strong>. _자동화된 시스템이나 지능형 시스템_이 인간의 개입이나 분석 없이 이러한 모든 상황을 어떻게 처리할 것이라 생각하나요?</p>
<p>물론 일부 작업은 자동화된 프로세스에 위임할 수 있지만, 처리할 올바른 입력 데이터를 제공하는 <strong>데이터 준비 단계에서 인간은 필수적</strong>입니다.</p>
<p>가장 많이 사용되는 두 가지 데이터 유형인 범주형 또는 수치형으로 변수를 할당하는 것은 데이터의 성격과 선택된 알고리즘(일부는 한 가지 데이터 유형만 지원)에 따라 달라집니다.</p>
<p>이 변환은 분석에 <strong>약간의 편향을 도입</strong>합니다. 결측값을 다룰 때도 비슷한 사례가 있습니다: <a href="data_preparation.html#missing_data">결측 데이터의 처리 및 대치</a>.</p>
<p>범주형 변수로 작업할 때, 타겟 변수에 따라 카테고리를 재배치하여 <strong>관계를 더 잘 드러내도록</strong> 분포를 변경할 수 있습니다. 비선형 변수 관계를 선형 관계로 변환하는 것이죠.</p>
</div>
<div id="보너스-트랙" class="section level3 hasAnchor" number="2.1.10">
<h3><span class="header-section-number">2.1.10</span> 보너스 트랙 💥<a href="data_preparation.html#보너스-트랙" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>이산화 변수 섹션으로 돌아가서 지금까지 살펴본 모든 변환을 플롯해 보겠습니다.</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb127-1"><a href="data_preparation.html#cb127-1" tabindex="-1"></a><span class="fu">grid.arrange</span>(p2, p3, p4, <span class="at">ncol =</span> <span class="dv">3</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:discretization-methods"></span>
<img src="02_data_preparation_files/figure-html/discretization-methods-1.png" alt="동일한 데이터, 다른 시각화" width="864"  />
<p class="caption">
Figure 2.8: 동일한 데이터, 다른 시각화
</p>
</div>
<p>입력 데이터는 항상 동일합니다. 하지만 이러한 모든 방법은 <strong>동일한 것에 대해 다른 관점을 보여줍니다</strong>.</p>
<p><strong>예측 모델링</strong>을 위한 <strong>동일 빈도</strong> 사용과 같이 특정 상황에 더 적합한 관점들이 있습니다.</p>
<p>이 사례는 하나의 변수만 고려하고 있지만, 여러 변수를 동시에 가진 경우, 즉 <code>N-차원</code> 공간에서도 논리는 동일합니다.</p>
<p>예측 모델을 구축할 때, 사람들이 어떤 대상에 대해 의견을 내는 것과 같이 동일한 점의 무리를 다른 방식으로 설명합니다.</p>
<p><img src="introduction/spacer_bar.png" /><!-- --></p>
</div>
</div>
<div id="high_cardinality_descriptive_stats" class="section level2 hasAnchor" number="2.2">
<h2><span class="header-section-number">2.2</span> 기술 통계에서의 고카디널리티 변수<a href="data_preparation.html#high_cardinality_descriptive_stats" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="무엇에-대한-내용인가요-1" class="section level3 hasAnchor" number="2.2.1">
<h3><span class="header-section-number">2.2.1</span> 무엇에 대한 내용인가요?<a href="data_preparation.html#무엇에-대한-내용인가요-1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><strong>고카디널리티(high cardinality)</strong> 변수는 가질 수 있는 값이 <em>매우 많은</em> 변수를 말합니다. 예를 들어 국가(country)가 있습니다.</p>
<p>이 장에서는 파레토 법칙(Pareto rule)에 기반한 카디널리티 감소를 다루며, 대부분의 값이 어디에 집중되어 있는지와 변수 분포를 빠르게 보여주는 <code>freq</code> 함수를 사용합니다.</p>
</div>
<div id="기술-통계에서의-고카디널리티" class="section level3 hasAnchor" number="2.2.2">
<h3><span class="header-section-number">2.2.2</span> 기술 통계에서의 고카디널리티<a href="data_preparation.html#기술-통계에서의-고카디널리티" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>다음 예제는 <code>person</code>, <code>country</code>, <code>has_flu</code>라는 3개의 열을 가진 910개 사례의 설문조사를 포함하고 있습니다. <code>has_flu</code>는 지난 달에 해당 질병을 앓았는지 여부를 나타냅니다.</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb128-1"><a href="data_preparation.html#cb128-1" tabindex="-1"></a><span class="fu">library</span>(funModeling) </span></code></pre></div>
<p><code>data_country</code> 데이터는 <code>funModeling</code> 패키지(버전 1.6 이상)에 포함되어 있습니다.</p>
<p><code>data_country</code>의 빠른 프로파일링 (처음 10행)</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb129-1"><a href="data_preparation.html#cb129-1" tabindex="-1"></a><span class="co"># 처음 10행 출력</span></span>
<span id="cb129-2"><a href="data_preparation.html#cb129-2" tabindex="-1"></a><span class="fu">head</span>(data_country, <span class="dv">10</span>)</span></code></pre></div>
<pre><code>##     person     country has_flu
## 478    478      France      no
## 990    990      Brazil      no
## 606    606      France      no
## 575    575 Philippines      no
## 806    806      France      no
## 232    232      France      no
## 422    422      Poland      no
## 347    347     Romania      no
## 858    858     Finland      no
## 704    704      France      no</code></pre>
<div class="sourceCode" id="cb131"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb131-1"><a href="data_preparation.html#cb131-1" tabindex="-1"></a><span class="co"># 데이터 탐색, 처음 10행만 표시</span></span>
<span id="cb131-2"><a href="data_preparation.html#cb131-2" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">freq</span>(data_country, <span class="st">&quot;country&quot;</span>), <span class="dv">10</span>)</span></code></pre></div>
<pre><code>## Warning: The `&lt;scale&gt;` argument of `guides()` cannot be `FALSE`. Use &quot;none&quot; instead as
## of ggplot2 3.3.4.
## ℹ The deprecated feature was likely used in the funModeling package.
##   Please report the issue at &lt;https://github.com/pablo14/funModeling/issues&gt;.
## This warning is displayed once per session.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.</code></pre>
<div class="figure"><span style="display:block;" id="fig:data-preparation-nominal-variable"></span>
<img src="02_data_preparation_files/figure-html/data-preparation-nominal-variable-1.png" alt="국가 빈도 분석" width="1500"  />
<p class="caption">
Figure 2.9: 국가 빈도 분석
</p>
</div>
<pre><code>##           country frequency percentage cumulative_perc
## 1          France       288      31.65           31.65
## 2          Turkey        67       7.36           39.01
## 3           China        65       7.14           46.15
## 4         Uruguay        63       6.92           53.07
## 5  United Kingdom        45       4.95           58.02
## 6       Australia        41       4.51           62.53
## 7         Germany        30       3.30           65.83
## 8          Canada        19       2.09           67.92
## 9     Netherlands        19       2.09           70.01
## 10          Japan        18       1.98           71.99</code></pre>
<div class="sourceCode" id="cb134"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb134-1"><a href="data_preparation.html#cb134-1" tabindex="-1"></a><span class="co"># 데이터 탐색</span></span>
<span id="cb134-2"><a href="data_preparation.html#cb134-2" tabindex="-1"></a><span class="fu">freq</span>(data_country, <span class="st">&quot;has_flu&quot;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:data-preparation-nominal-variable-2"></span>
<img src="02_data_preparation_files/figure-html/data-preparation-nominal-variable-2-1.png" alt="독감 발생 여부 빈도 분석" width="480"  />
<p class="caption">
Figure 2.10: 독감 발생 여부 빈도 분석
</p>
</div>
<pre><code>##   has_flu frequency percentage cumulative_perc
## 1      no       827      90.88           90.88
## 2     yes        83       9.12          100.00</code></pre>
<p>마지막 테이블은 <code>has_flu="yes"</code>인 행이 83개뿐임을 보여주며, 이는 전체 인원의 약 9%를 차지합니다.</p>
<p>하지만 이들 중 다수는 데이터에서 거의 비중을 차지하지 않습니다. 이것이 <em>롱 테일(long tail)</em> 현상이며, 카디널리티를 줄이는 한 가지 방법은 데이터 공유의 높은 비율(예: 70, 80 또는 90%)을 차지하는 카테고리들만 유지하는 파레토 법칙을 적용하는 것입니다.</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb136-1"><a href="data_preparation.html#cb136-1" tabindex="-1"></a><span class="co"># &#39;funModeling&#39; 패키지의 &#39;freq&#39; 함수는 절단 지점을 설정하는 데 도움이 되는 누적 백분율(cumulative_percentage)을 가져옵니다. </span></span>
<span id="cb136-2"><a href="data_preparation.html#cb136-2" tabindex="-1"></a>country_freq <span class="ot">=</span> <span class="fu">freq</span>(data_country, <span class="st">&#39;country&#39;</span>, <span class="at">plot =</span> F)</span>
<span id="cb136-3"><a href="data_preparation.html#cb136-3" tabindex="-1"></a></span>
<span id="cb136-4"><a href="data_preparation.html#cb136-4" tabindex="-1"></a><span class="co"># &#39;country_freq&#39;는 빈도에 따라 정렬된 테이블이므로, 가장 높은 비중을 차지하는 처음 10개 행을 살펴봅시다.</span></span>
<span id="cb136-5"><a href="data_preparation.html#cb136-5" tabindex="-1"></a>country_freq <span class="sc">%&gt;%</span> <span class="fu">slice_head</span>(<span class="at">n =</span> <span class="dv">10</span>)</span></code></pre></div>
<pre><code>##           country frequency percentage cumulative_perc
## 1          France       288      31.65           31.65
## 2          Turkey        67       7.36           39.01
## 3           China        65       7.14           46.15
## 4         Uruguay        63       6.92           53.07
## 5  United Kingdom        45       4.95           58.02
## 6       Australia        41       4.51           62.53
## 7         Germany        30       3.30           65.83
## 8          Canada        19       2.09           67.92
## 9     Netherlands        19       2.09           70.01
## 10          Japan        18       1.98           71.99</code></pre>
<p>따라서 10개 국가가 사례의 70% 이상을 대표합니다. 나머지 사례들에 <code>other</code> 카테고리를 할당하고 플롯을 그릴 수 있습니다.</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb138-1"><a href="data_preparation.html#cb138-1" tabindex="-1"></a>data_country<span class="sc">$</span>country_2 <span class="ot">=</span> <span class="fu">ifelse</span>(data_country<span class="sc">$</span>country <span class="sc">%in%</span> <span class="fu">pull</span>(country_freq[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, ], country), data_country<span class="sc">$</span>country, <span class="st">&#39;other&#39;</span>)</span>
<span id="cb138-2"><a href="data_preparation.html#cb138-2" tabindex="-1"></a><span class="fu">freq</span>(data_country, <span class="st">&#39;country_2&#39;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:data-preparation-profiling-nominal-variable-2"></span>
<img src="02_data_preparation_files/figure-html/data-preparation-profiling-nominal-variable-2-1.png" alt="수정된 국가 변수 - 빈도 분석" width="403.2"  />
<p class="caption">
Figure 2.11: 수정된 국가 변수 - 빈도 분석
</p>
</div>
<pre><code>##         country_2 frequency percentage cumulative_perc
## 1          France       288      31.65           31.65
## 2           other       255      28.02           59.67
## 3          Turkey        67       7.36           67.03
## 4           China        65       7.14           74.17
## 5         Uruguay        63       6.92           81.09
## 6  United Kingdom        45       4.95           86.04
## 7       Australia        41       4.51           90.55
## 8         Germany        30       3.30           93.85
## 9          Canada        19       2.09           95.94
## 10    Netherlands        19       2.09           98.03
## 11          Japan        18       1.98          100.00</code></pre>
</div>
<div id="최종-코멘트" class="section level3 hasAnchor" number="2.2.3">
<h3><span class="header-section-number">2.2.3</span> 최종 코멘트<a href="data_preparation.html#최종-코멘트" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>대표성이 낮은 카테고리는 가끔 <code>Egypt</code>, <code>Eggypt.</code>와 같이 데이터 오류인 경우가 있으며, 이는 데이터를 수집하는 나쁜 습관이나 소스에서 수집할 때 발생할 수 있는 오류의 증거가 될 수 있습니다.</p>
<p>데이터를 축소하는 일반적인 규칙은 없으며, 각 사례에 따라 다릅니다.</p>
<p><strong>다음 권장 장:</strong> <a href="data_preparation.html#high_cardinality_predictive_modeling">예측 모델링에서의 고카디널리티 변수</a>.</p>
<p><img src="introduction/spacer_bar.png" /><!-- --></p>
</div>
</div>
<div id="high_cardinality_predictive_modeling" class="section level2 hasAnchor" number="2.3">
<h2><span class="header-section-number">2.3</span> High Cardinality Variable in Predictive Modeling<a href="data_preparation.html#high_cardinality_predictive_modeling" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="무엇에-대한-내용인가요-2" class="section level3 hasAnchor" number="2.3.1">
<h3><span class="header-section-number">2.3.1</span> 무엇에 대한 내용인가요?<a href="data_preparation.html#무엇에-대한-내용인가요-2" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>지난 장인 <a href="data_preparation.html#high_cardinality_descriptive_stats">기술 통계에서의 고카디널리티</a>에서 보았듯이, 우리는 주요 대표성을 가진 카테고리들만 유지하지만, 이를 기반으로 예측할 다른 변수가 있다면 어떨까요? 즉, <code>country</code>를 기반으로 <code>has_flu</code>를 예측하는 것입니다.</p>
<p>이전 방법을 사용하면 변수의 정보가 파괴되어 <strong>예측력을 잃게 될 수 있습니다</strong>. 이 장에서는 위에서 설명한 방법을 더 발전시켜, 자동 그룹화 함수인 <code>auto_grouping</code>을 사용하여 변수의 구조를 탐색하고 범주형 변수를 최적화하는 방법에 대한 아이디어를 제공할 것입니다. 하지만 더 중요한 것은 독자가 자신만의 최적화를 수행하도록 장려하는 것입니다.</p>
<p>다른 문헌에서는 이러한 재그룹화를 카디널리티 감소 또는 <strong>인코딩(encoding)</strong>이라고 부릅니다.</p>
<p><strong>이 장에서 무엇을 검토할까요?</strong></p>
<ul>
<li>데이터 대표성의 개념 (샘플 크기).</li>
<li>타겟 또는 결과 변수가 있는 샘플 크기.</li>
<li>R에서: 카디널리티를 줄이고 범주형 변수를 프로파일링하는 데 도움이 되는 방법 제시.</li>
<li>카디널리티를 줄인 전후의 실용적인 사례와 인사이트 추출.</li>
<li>랜덤 포레스트나 그레디언트 부스팅 머신과 같은 다양한 모델이 범주형 변수를 처리하는 방법.</li>
</ul>
</div>
<div id="하지만-변수를-재그룹화하는-것이-필요할까요" class="section level3 hasAnchor" number="2.3.2">
<h3><span class="header-section-number">2.3.2</span> 하지만 변수를 재그룹화하는 것이 필요할까요?<a href="data_preparation.html#하지만-변수를-재그룹화하는-것이-필요할까요" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>사례에 따라 다르지만 가장 빠른 대답은 “예”입니다. 이 장에서 우리는 이러한 데이터 준비가 전체 정확도(ROC 곡선 아래 면적으로 측정)를 높이는 한 사례를 보게 될 것입니다.</p>
<p><strong>데이터의 표현력</strong>(각 카테고리가 가진 행의 수)과 각 카테고리가 결과 변수와 얼마나 관련이 있는지 사이에는 트레이드오프가 존재합니다. 예: 일부 국가는 다른 국가보다 독감 사례에 더 취약할 수 있습니다.</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb140-1"><a href="data_preparation.html#cb140-1" tabindex="-1"></a><span class="co"># 이를 처리하는 함수를 포함하고 있는 funModeling &gt;=1.6을 로드합니다. </span></span>
<span id="cb140-2"><a href="data_preparation.html#cb140-2" tabindex="-1"></a><span class="fu">library</span>(funModeling)</span>
<span id="cb140-3"><a href="data_preparation.html#cb140-3" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span></code></pre></div>
<p><code>funModeling</code> 패키지에 포함된 <code>data_country</code>를 프로파일링합니다 (버전 1.6.5 이상으로 업데이트하세요).</p>
<p><code>data_country</code>의 빠른 프로파일링 (처음 10행)</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb141-1"><a href="data_preparation.html#cb141-1" tabindex="-1"></a><span class="co"># 처음 10행 출력</span></span>
<span id="cb141-2"><a href="data_preparation.html#cb141-2" tabindex="-1"></a><span class="fu">head</span>(data_country, <span class="dv">10</span>)</span></code></pre></div>
<pre><code>##     person     country has_flu country_2
## 478    478      France      no    France
## 990    990      Brazil      no     other
## 606    606      France      no    France
## 575    575 Philippines      no     other
## 806    806      France      no    France
## 232    232      France      no    France
## 422    422      Poland      no     other
## 347    347     Romania      no     other
## 858    858     Finland      no     other
## 704    704      France      no    France</code></pre>
<div class="sourceCode" id="cb143"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb143-1"><a href="data_preparation.html#cb143-1" tabindex="-1"></a><span class="co"># 데이터 탐색, 처음 10행만 표시</span></span>
<span id="cb143-2"><a href="data_preparation.html#cb143-2" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">freq</span>(data_country, <span class="st">&quot;country&quot;</span>), <span class="dv">10</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:high-cardinality-variable"></span>
<img src="02_data_preparation_files/figure-html/high-cardinality-variable-1.png" alt="처음 10개 국가" width="1200"  />
<p class="caption">
Figure 2.12: 처음 10개 국가
</p>
</div>
<pre><code>##           country frequency percentage cumulative_perc
## 1          France       288      31.65           31.65
## 2          Turkey        67       7.36           39.01
## 3           China        65       7.14           46.15
## 4         Uruguay        63       6.92           53.07
## 5  United Kingdom        45       4.95           58.02
## 6       Australia        41       4.51           62.53
## 7         Germany        30       3.30           65.83
## 8          Canada        19       2.09           67.92
## 9     Netherlands        19       2.09           70.01
## 10          Japan        18       1.98           71.99</code></pre>
<div class="sourceCode" id="cb145"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb145-1"><a href="data_preparation.html#cb145-1" tabindex="-1"></a><span class="co"># 데이터 탐색</span></span>
<span id="cb145-2"><a href="data_preparation.html#cb145-2" tabindex="-1"></a><span class="fu">freq</span>(data_country, <span class="st">&quot;has_flu&quot;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:data-preparation-high-cardinality-variable"></span>
<img src="02_data_preparation_files/figure-html/data-preparation-high-cardinality-variable-1.png" alt="독감 분포" width="508.8"  />
<p class="caption">
Figure 2.13: 독감 분포
</p>
</div>
<pre><code>##   has_flu frequency percentage cumulative_perc
## 1      no       827      90.88           90.88
## 2     yes        83       9.12          100.00</code></pre>
</div>
<div id="analyze-binary-outcome-vs-categorical-variable" class="section level3 hasAnchor" number="2.3.3">
<h3><span class="header-section-number">2.3.3</span> 사례 🔍<a href="data_preparation.html#analyze-binary-outcome-vs-categorical-variable" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>예측 모델은 특정 값을 특정 결과와 매핑하려고 시도할 것이며, 우리의 경우 타겟 변수는 이진형입니다.</p>
<p>우리는 <code>categ_analysis</code>를 기반으로 타겟 변수 <code>has_flu</code>에 대한 <code>country</code>의 완전한 프로파일링을 계산할 것입니다.</p>
<p>각 행은 <code>input</code> 변수의 고유한 카테고리를 나타냅니다. 각 행 내에서 대표성과 가능성 측면에서 각 카테고리를 정의하는 속성을 찾을 수 있습니다.</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb147-1"><a href="data_preparation.html#cb147-1" tabindex="-1"></a><span class="co"># `categ_analysis`는 &quot;funModeling&quot; &gt;= v1.6에서 사용할 수 있습니다. 사용 전 설치해 주세요.</span></span>
<span id="cb147-2"><a href="data_preparation.html#cb147-2" tabindex="-1"></a>country_profiling<span class="ot">=</span><span class="fu">categ_analysis</span>(<span class="at">data=</span>data_country, <span class="at">input=</span><span class="st">&quot;country&quot;</span>, <span class="at">target =</span> <span class="st">&quot;has_flu&quot;</span>)</span></code></pre></div>
<pre><code>## Warning: `summarise_()` was deprecated in dplyr 0.7.0.
## ℹ Please use `summarise()` instead.
## ℹ The deprecated feature was likely used in the funModeling package.
##   Please report the issue at &lt;https://github.com/pablo14/funModeling/issues&gt;.
## This warning is displayed once per session.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.</code></pre>
<pre><code>## Warning: `group_by_()` was deprecated in dplyr 0.7.0.
## ℹ Please use `group_by()` instead.
## ℹ See vignette(&#39;programming&#39;) for more help
## ℹ The deprecated feature was likely used in the funModeling package.
##   Please report the issue at &lt;https://github.com/pablo14/funModeling/issues&gt;.
## This warning is displayed once per session.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.</code></pre>
<div class="sourceCode" id="cb150"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb150-1"><a href="data_preparation.html#cb150-1" tabindex="-1"></a><span class="co"># 70개 국가 중 처음 15개 행(국가) 출력.</span></span>
<span id="cb150-2"><a href="data_preparation.html#cb150-2" tabindex="-1"></a><span class="fu">head</span>(country_profiling, <span class="dv">15</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:data-preparation-in-predictivemodeling"></span>
<img src="data_preparation/country_profiling.png" alt="타겟 vs. 입력 분석" width="75%"  />
<p class="caption">
Figure 2.14: 타겟 vs. 입력 분석
</p>
</div>
<ul>
<li>참고 1: <em>첫 번째 열의 이름은 <code>input</code> 변수에 따라 자동으로 조정됩니다.</em></li>
<li>참고 2: <em><code>has_flu</code> 변수는 <code>yes</code>와 <code>no</code> 값을 가집니다. <code>categ_analysis</code>는 평균, 합계 및 백분율을 계산하기 위해 대표성이 낮은 클래스(이 경우 <code>yes</code>)에 내부적으로 숫자 <strong>1</strong>을 할당합니다.</em></li>
</ul>
<p>이들은 <code>categ_analysis</code>가 반환하는 지표들입니다:</p>
<ul>
<li><code>country</code>: <code>input</code> 변수의 각 카테고리 이름.</li>
<li><code>mean_target</code>: <code>sum_target / q_rows</code>, 해당 카테고리에 대한 <code>has_flu="yes"</code>의 평균 수. 이것이 가능성(likelihood)입니다.</li>
<li><code>sum_target</code>: 각 카테고리에 있는 <code>has_flu="yes"</code> 값의 수량.</li>
<li><code>perc_target</code>: <code>sum_target</code>과 동일하지만 백분율로 표시됩니다. <code>각 카테고리의 sum_target / 전체 sum_target</code>. 이 열의 합은 <code>1.00</code>입니다.</li>
<li><code>q_rows</code>: <code>has_flu</code> 변수와 관계없이 해당 카테고리에 속한 행의 수량. <code>input</code>의 분포입니다. 이 열의 합은 분석된 전체 행 수입니다.</li>
<li><code>perc_rows</code>: <code>q_rows</code>와 관련되어 각 카테고리의 점유율 또는 백분율을 나타냅니다. 이 열의 합은 <code>1.00</code>입니다.</li>
</ul>
<div id="여기서-어떤-결론을-내릴-수-있을까요" class="section level4 hasAnchor" number="2.3.3.1">
<h4><span class="header-section-number">2.3.3.1</span> 여기서 어떤 결론을 내릴 수 있을까요?<a href="data_preparation.html#여기서-어떤-결론을-내릴-수-있을까요" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>첫 번째 <code>France</code> 행을 기반으로 예제를 읽어봅시다:</p>
<ul>
<li>41명이 독감에 걸렸습니다 (<code>sum_target=41</code>). 이 41명은 독감에 걸린 전체 인원의 거의 50%를 나타냅니다 (<code>perc_target=0.494</code>).</li>
<li>프랑스에서 독감에 걸릴 확률은 14.2%입니다 (<code>mean_target=0.142</code>).</li>
<li>프랑스의 전체 행 = 288개 (910개 중). 이것이 <code>q_rows</code> 변수이며, <code>perc_rows</code>는 동일한 수치를 백분율로 나타낸 것입니다.</li>
</ul>
<p>국가별 필터를 고려하지 않으면 다음을 얻습니다:</p>
<ul>
<li><code>sum_target</code> 열의 합은 데이터에 있는 독감 환자의 총합입니다.</li>
<li><code>perc_target</code> 열의 합은 <code>1.00</code> 또는 100%입니다.</li>
<li><code>q_rows</code> 열의 합은 <code>data_country</code> 데이터 프레임에 있는 총 행 수입니다.</li>
<li><code>perc_rows</code> 열의 합은 <code>1.00</code> 또는 100%입니다.</li>
</ul>
</div>
</div>
<div id="예측-모델링을-위한-분석" class="section level3 hasAnchor" number="2.3.4">
<h3><span class="header-section-number">2.3.4</span> 예측 모델링을 위한 분석 🔮<a href="data_preparation.html#예측-모델링을-위한-분석" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>예측 모델을 개발할 때, 우리는 특정 이벤트의 가능성을 높이는 값들에 관심을 가질 수 있습니다. 우리의 경우:</p>
<p><strong>독감 환자를 찾을 가능성을 최대화하는 국가는 어디인가요?</strong></p>
<p>쉽습니다. <code>country_profiling</code>을 <code>mean_target</code> 기준 내림차순으로 정렬하면 됩니다:</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb151-1"><a href="data_preparation.html#cb151-1" tabindex="-1"></a><span class="co"># country_profiling을 mean_target으로 정렬한 다음 처음 6개 국가 가져오기</span></span>
<span id="cb151-2"><a href="data_preparation.html#cb151-2" tabindex="-1"></a>country_profiling <span class="sc">%&gt;%</span> <span class="fu">arrange</span>(<span class="fu">desc</span>(mean_target)) <span class="sc">%&gt;%</span> <span class="fu">head</span>()</span></code></pre></div>
<pre><code>##          country mean_target sum_target perc_target q_rows perc_rows
## 1       Malaysia       1.000          1       0.012      1     0.001
## 2         Mexico       0.667          2       0.024      3     0.003
## 3       Portugal       0.200          1       0.012      5     0.005
## 4 United Kingdom       0.178          8       0.096     45     0.049
## 5        Uruguay       0.175         11       0.133     63     0.069
## 6         Israel       0.167          1       0.012      6     0.007</code></pre>
<p>좋습니다! 독감에 걸릴 확률이 가장 높은 국가로 <code>Malasyia</code>가 나왔습니다! 그곳 사람들의 100%가 독감에 걸렸습니다 (<code>mean_has_flu=1.000</code>).</p>
<p>하지만 우리의 상식은 <em>아마도</em> 무언가 잘못되었다고 조언합니다…</p>
<p>말레이시아의 행 수는 몇 개인가요? 정답: 1. -열: <code>q_rows=1</code>
말레이시아의 양성 사례는 몇 개인가요? 정답: 1. -열: <code>sum_target=1</code></p>
<p>샘플을 늘려 이 비율이 높게 유지되는지 확인할 수 없으므로, 이는 예측 모델에서 <strong>과적합(overfit)</strong>을 유발하고 편향을 만들게 될 것입니다.</p>
<p><code>Mexico</code>는 어떨까요? 3명 중 2명이 독감… 여전히 낮아 보입니다. 하지만 <code>Uruguay</code>는 17.3%의 확률(63건 중 11건)을 보이며, 이 63건은 전체 인구의 거의 7%를 차지합니다 (<code>perc_row=0.069</code>). 이 비율은 좀 더 신뢰할 수 있어 보입니다.</p>
<p>다음은 이를 처리하기 위한 몇 가지 아이디어입니다:</p>
<div id="reduce_cardinality_by_re_categorizing_less_representative_values" class="section level4 hasAnchor" number="2.3.4.1">
<h4><span class="header-section-number">2.3.4.1</span> 사례 1: 대표성이 낮은 값을 재범주화하여 줄이기<a href="data_preparation.html#reduce_cardinality_by_re_categorizing_less_representative_values" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>데이터에서 일정 비율 이상의 점유율을 가진 사례만 남깁니다. 예를 들어, 데이터에서 점유율이 1% 미만인 국가들의 이름을 <code>other</code>로 바꿉니다.</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb153-1"><a href="data_preparation.html#cb153-1" tabindex="-1"></a>country_profiling<span class="ot">=</span><span class="fu">categ_analysis</span>(<span class="at">data=</span>data_country, <span class="at">input=</span><span class="st">&quot;country&quot;</span>, <span class="at">target =</span> <span class="st">&quot;has_flu&quot;</span>)</span>
<span id="cb153-2"><a href="data_preparation.html#cb153-2" tabindex="-1"></a></span>
<span id="cb153-3"><a href="data_preparation.html#cb153-3" tabindex="-1"></a>countries_high_rep<span class="ot">=</span><span class="fu">filter</span>(country_profiling, perc_rows<span class="sc">&gt;</span><span class="fl">0.01</span>) <span class="sc">%&gt;%</span> <span class="fu">pull</span>(country)</span>
<span id="cb153-4"><a href="data_preparation.html#cb153-4" tabindex="-1"></a></span>
<span id="cb153-5"><a href="data_preparation.html#cb153-5" tabindex="-1"></a><span class="co"># 만약 countries_high_rep에 포함되지 않으면 `other` 카테고리 할당</span></span>
<span id="cb153-6"><a href="data_preparation.html#cb153-6" tabindex="-1"></a>data_country<span class="sc">$</span>country_new<span class="ot">=</span><span class="fu">ifelse</span>(data_country<span class="sc">$</span>country <span class="sc">%in%</span> countries_high_rep, data_country<span class="sc">$</span>country, <span class="st">&quot;other&quot;</span>)</span></code></pre></div>
<p>독감 확률을 다시 확인해 봅시다.</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb154-1"><a href="data_preparation.html#cb154-1" tabindex="-1"></a>country_profiling_new<span class="ot">=</span><span class="fu">categ_analysis</span>(<span class="at">data=</span>data_country, <span class="at">input=</span><span class="st">&quot;country_new&quot;</span>, <span class="at">target =</span> <span class="st">&quot;has_flu&quot;</span>)</span>
<span id="cb154-2"><a href="data_preparation.html#cb154-2" tabindex="-1"></a>country_profiling_new</span></code></pre></div>
<pre><code>##       country_new mean_target sum_target perc_target q_rows perc_rows
## 1  United Kingdom       0.178          8       0.096     45     0.049
## 2         Uruguay       0.175         11       0.133     63     0.069
## 3          Canada       0.158          3       0.036     19     0.021
## 4          France       0.142         41       0.494    288     0.316
## 5         Germany       0.100          3       0.036     30     0.033
## 6       Australia       0.098          4       0.048     41     0.045
## 7         Romania       0.091          1       0.012     11     0.012
## 8           Spain       0.091          1       0.012     11     0.012
## 9          Sweden       0.083          1       0.012     12     0.013
## 10    Netherlands       0.053          1       0.012     19     0.021
## 11          other       0.041          7       0.084    170     0.187
## 12         Turkey       0.030          2       0.024     67     0.074
## 13        Belgium       0.000          0       0.000     15     0.016
## 14         Brazil       0.000          0       0.000     13     0.014
## 15          China       0.000          0       0.000     65     0.071
## 16          Italy       0.000          0       0.000     10     0.011
## 17          Japan       0.000          0       0.000     18     0.020
## 18         Poland       0.000          0       0.000     13     0.014</code></pre>
<p>국가의 수가 급격히 줄어들었습니다 -<strong>74% 감소</strong>- 단지 1% 미만의 낮은 대표성 국가들을 줄임으로써 70개 국가 중 18개만 남았습니다.</p>
<p><code>other</code> 카테고리에서 타겟 변수의 확률이 좀 더 안정화되었습니다. 이제 예측 모델이 <code>Malaysia</code>를 보게 되면 <strong>100%의 확률을 부여하는 대신 4.1%</strong> (<code>mean_has_flu=0.041</code>)를 부여하게 됩니다.</p>
<p><strong>이 마지막 방법에 대한 조언:</strong></p>
<p>이 기술을 맹목적으로 적용하지 않도록 주의하세요. 때때로 <strong>매우 불균형한(highly unbalanced)</strong> 타겟 예측(예: <strong>이상 탐지, anomaly detection</strong>)에서는 이상 징후가 데이터의 1% 미만에서 나타나는 경우가 있습니다.</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb156-1"><a href="data_preparation.html#cb156-1" tabindex="-1"></a><span class="co"># 데이터 복제</span></span>
<span id="cb156-2"><a href="data_preparation.html#cb156-2" tabindex="-1"></a>d_abnormal<span class="ot">=</span>data_country</span>
<span id="cb156-3"><a href="data_preparation.html#cb156-3" tabindex="-1"></a></span>
<span id="cb156-4"><a href="data_preparation.html#cb156-4" tabindex="-1"></a><span class="co"># 일부 국가에서 비정상적인 동작 시뮬레이션</span></span>
<span id="cb156-5"><a href="data_preparation.html#cb156-5" tabindex="-1"></a>d_abnormal<span class="sc">$</span>abnormal<span class="ot">=</span><span class="fu">ifelse</span>(d_abnormal<span class="sc">$</span>country <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;Brazil&quot;</span>, <span class="st">&quot;Chile&quot;</span>), <span class="st">&#39;yes&#39;</span>, <span class="st">&#39;no&#39;</span>)</span>
<span id="cb156-6"><a href="data_preparation.html#cb156-6" tabindex="-1"></a></span>
<span id="cb156-7"><a href="data_preparation.html#cb156-7" tabindex="-1"></a><span class="co"># 범주형 분석</span></span>
<span id="cb156-8"><a href="data_preparation.html#cb156-8" tabindex="-1"></a>ab_analysis<span class="ot">=</span><span class="fu">categ_analysis</span>(d_abnormal, <span class="at">input =</span> <span class="st">&quot;country&quot;</span>, <span class="at">target =</span> <span class="st">&quot;abnormal&quot;</span>)</span>
<span id="cb156-9"><a href="data_preparation.html#cb156-9" tabindex="-1"></a></span>
<span id="cb156-10"><a href="data_preparation.html#cb156-10" tabindex="-1"></a><span class="co"># 처음 6개 요소만 표시</span></span>
<span id="cb156-11"><a href="data_preparation.html#cb156-11" tabindex="-1"></a><span class="fu">head</span>(ab_analysis)</span></code></pre></div>
<pre><code>##               country mean_target sum_target perc_target q_rows perc_rows
## 1              Brazil           1         13       0.867     13     0.014
## 2               Chile           1          2       0.133      2     0.002
## 3           Argentina           0          0       0.000      9     0.010
## 4 Asia/Pacific Region           0          0       0.000      1     0.001
## 5           Australia           0          0       0.000     41     0.045
## 6             Austria           0          0       0.000      1     0.001</code></pre>
<div class="sourceCode" id="cb158"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb158-1"><a href="data_preparation.html#cb158-1" tabindex="-1"></a><span class="co"># 분포 검사, &#39;no&#39; 카테고리에 속하는 비중이 매우 낮음</span></span>
<span id="cb158-2"><a href="data_preparation.html#cb158-2" tabindex="-1"></a><span class="fu">freq</span>(d_abnormal, <span class="st">&quot;abnormal&quot;</span>, <span class="at">plot =</span> F)</span></code></pre></div>
<pre><code>##   abnormal frequency percentage cumulative_perc
## 1       no       895      98.35           98.35
## 2      yes        15       1.65          100.00</code></pre>
<p><em>이상 수치가 얼마나 있나요?</em></p>
<p>단 15개뿐이며, 전체 데이터의 1.65%를 차지합니다.</p>
<p><code>categ_analysis</code>가 반환한 테이블을 보면, 이 _이상 징후_는 참여도가 매우 낮은 카테고리에서<strong>만</strong> 발생함을 알 수 있습니다. <code>Brazil</code>은 1.4%, <code>Chile</code>은 0.2%에 불과합니다.</p>
<p>여기서 데이터 분포를 기반으로 <code>other</code> 카데고리를 만드는 것은 좋은 생각이 아닙니다.</p>
<p><strong>결론:</strong></p>
<p>비록 이것은 준비된 예제이지만, 정확도 측면에서 정말 유용할 수 있는 몇 가지 데이터 준비 기술이 있습니다. 하지만 이들은 전문가의 감독이 필요하며, 알고리즘이 이러한 감독을 도울 수 있습니다.</p>
</div>
<div id="사례-2-자동-그룹화를-통한-줄이기" class="section level4 hasAnchor" number="2.3.4.2">
<h4><span class="header-section-number">2.3.4.2</span> 사례 2: 자동 그룹화를 통한 줄이기<a href="data_preparation.html#사례-2-자동-그룹화를-통한-줄이기" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>이 절차는 <code>kmeans</code> 클러스터링 기술과 <code>categ_analysis</code>가 반환한 테이블을 사용하여 다음과 같은 측면에서 유사한 행동을 보이는 카테고리들을 그룹(클러스터)으로 묶습니다.</p>
<ul>
<li><code>perc_rows</code></li>
<li><code>perc_target</code></li>
</ul>
<p>두 가지를 결합하면 가능성과 대표성을 모두 고려한 그룹을 찾을 수 있습니다.</p>
<p><strong>R 실습:</strong></p>
<p>우리는 원하는 그룹의 수인 <code>n_groups</code> 매개변수를 정의합니다. 이 숫자는 데이터와 전체 카테고리 수에 따라 상대적이지만, 일반적으로 3에서 10 사이의 숫자가 적당합니다.</p>
<p><code>auto_grouping</code> 함수는 <code>funModeling</code> 버전 1.6 이상에서 제공됩니다. <code>target</code> 매개변수는 비이진(non binary) 변수만 지원한다는 점에 유의하세요.</p>
<p><em>참고: <code>seed</code> 매개변수는 선택 사항이지만, 숫자를 지정하면 항상 동일한 결과를 얻을 수 있습니다.</em></p>
<div class="sourceCode" id="cb160"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb160-1"><a href="data_preparation.html#cb160-1" tabindex="-1"></a><span class="co"># 카디널리티 줄이기</span></span>
<span id="cb160-2"><a href="data_preparation.html#cb160-2" tabindex="-1"></a>country_groups<span class="ot">=</span><span class="fu">auto_grouping</span>(<span class="at">data =</span> data_country, <span class="at">input =</span> <span class="st">&quot;country&quot;</span>, <span class="at">target=</span><span class="st">&quot;has_flu&quot;</span>, <span class="at">n_groups=</span><span class="dv">9</span>, <span class="at">seed =</span> <span class="dv">999</span>)</span></code></pre></div>
<pre><code>## Warning: `select_()` was deprecated in dplyr 0.7.0.
## ℹ Please use `select()` instead.
## ℹ The deprecated feature was likely used in the funModeling package.
##   Please report the issue at &lt;https://github.com/pablo14/funModeling/issues&gt;.
## This warning is displayed once per session.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.</code></pre>
<pre><code>## Warning: `arrange_()` was deprecated in dplyr 0.7.0.
## ℹ Please use `arrange()` instead.
## ℹ See vignette(&#39;programming&#39;) for more help
## ℹ The deprecated feature was likely used in the funModeling package.
##   Please report the issue at &lt;https://github.com/pablo14/funModeling/issues&gt;.
## This warning is displayed once per session.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.</code></pre>
<div class="sourceCode" id="cb163"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb163-1"><a href="data_preparation.html#cb163-1" tabindex="-1"></a>country_groups<span class="sc">$</span>df_equivalence</span></code></pre></div>
<pre><code>##                      country country_rec
## 1                   Bulgaria     group_1
## 2                    Denmark     group_1
## 3                  Hong Kong     group_1
## 4                  Indonesia     group_1
## 5                      Italy     group_1
## 6                     Norway     group_1
## 7                Philippines     group_1
## 8                  Singapore     group_1
## 9               South Africa     group_1
## 10                   Ukraine     group_1
## 11       Asia/Pacific Region     group_2
## 12                   Austria     group_2
## 13                Bangladesh     group_2
## 14    Bosnia and Herzegovina     group_2
## 15                  Cambodia     group_2
## 16                     Chile     group_2
## 17                Costa Rica     group_2
## 18                   Croatia     group_2
## 19                    Cyprus     group_2
## 20            Czech Republic     group_2
## 21        Dominican Republic     group_2
## 22                     Egypt     group_2
## 23                   Finland     group_2
## 24                     Ghana     group_2
## 25                    Greece     group_2
## 26                  Honduras     group_2
## 27 Iran, Islamic Republic of     group_2
## 28                   Ireland     group_2
## 29               Isle of Man     group_2
## 30        Korea, Republic of     group_2
## 31                    Latvia     group_2
## 32                 Lithuania     group_2
## 33                Luxembourg     group_2
## 34                     Malta     group_2
## 35      Moldova, Republic of     group_2
## 36                Montenegro     group_2
## 37                   Morocco     group_2
## 38               New Zealand     group_2
## 39                  Pakistan     group_2
## 40     Palestinian Territory     group_2
## 41                      Peru     group_2
## 42        Russian Federation     group_2
## 43              Saudi Arabia     group_2
## 44                   Senegal     group_2
## 45                  Slovenia     group_2
## 46                    Taiwan     group_2
## 47                  Thailand     group_2
## 48                   Vietnam     group_2
## 49                     China     group_3
## 50                    Turkey     group_3
## 51                    France     group_4
## 52                 Australia     group_5
## 53                 Argentina     group_6
## 54                    Israel     group_6
## 55                  Malaysia     group_6
## 56                    Mexico     group_6
## 57                  Portugal     group_6
## 58                   Romania     group_6
## 59                     Spain     group_6
## 60                    Sweden     group_6
## 61               Switzerland     group_6
## 62                   Belgium     group_7
## 63                    Brazil     group_7
## 64                     Japan     group_7
## 65               Netherlands     group_7
## 66                    Poland     group_7
## 67            United Kingdom     group_8
## 68                   Uruguay     group_8
## 69                    Canada     group_9
## 70                   Germany     group_9</code></pre>
<p><code>auto_grouping</code>은 3개의 객체를 포함하는 리스트를 반환합니다.</p>
<ul>
<li><code>df_equivalence</code>: 기존 값과 새로운 값을 매핑하는 테이블이 포함된 데이터 프레임.</li>
<li><code>fit_cluster</code>: 카디널리티를 줄이기 위해 사용된 k-means 모델 (값은 스케일링됨).</li>
<li><code>recateg_results</code>: 타겟 변수에 대한 각 그룹의 프로파일링을 포함하는 데이터 프레임으로, 첫 번째 열은 입력 변수의 이름을 따릅니다 (이 경우 <code>country_rec</code>). 각 그룹은 입력 변수의 하나 또는 여러 카테고리에 대응합니다 (<code>df_equivalence</code>에서 확인 가능).</li>
</ul>
<p>새로운 그룹들이 어떻게 행동하는지 살펴봅시다. 예측 모델이 보게 될 정보입니다.</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb165-1"><a href="data_preparation.html#cb165-1" tabindex="-1"></a>country_groups<span class="sc">$</span>recateg_results</span></code></pre></div>
<pre><code>##   country_rec mean_target sum_target perc_target q_rows perc_rows
## 1     group_8       0.176         19       0.229    108     0.119
## 2     group_6       0.156         10       0.120     64     0.070
## 3     group_4       0.142         41       0.494    288     0.316
## 4     group_9       0.122          6       0.072     49     0.054
## 5     group_5       0.098          4       0.048     41     0.045
## 6     group_3       0.015          2       0.024    132     0.145
## 7     group_7       0.013          1       0.012     78     0.086
## 8     group_1       0.000          0       0.000     75     0.082
## 9     group_2       0.000          0       0.000     75     0.082</code></pre>
<p>위 테이블은 <code>mean_target</code>을 기준으로 정렬되어 있어, 확률을 최대화하거나 최소화하는 그룹을 빠르게 확인할 수 있습니다.</p>
<ul>
<li><code>group_2</code>가 가장 흔하며, 31.6%의 비중을 차지하고 <code>mean_target</code>(확률)은 14.2%입니다.</li>
<li><code>group_8</code>이 가장 높은 확률(17.6%)을 보입니다. 그 뒤를 이어 <code>group_6</code>가 15.6%의 양성(<code>has_flu="yes"</code>) 확률을 가집니다.</li>
<li><code>group_4</code>, <code>group_5</code>, <code>group_9</code>은 비슷해 보입니다. 모든 사례에서 확률이 0이므로 하나의 그룹으로 묶을 수 있습니다.</li>
<li><code>group_7</code>과 <code>group_3</code>은 양성 사례가 있는 국가가 1~2개뿐입니다. 이 수치들을 동일한 것으로 간주하여 하나의 그룹으로 묶을 수 있으며, 결국 가장 낮은 확률을 가진 국가들을 나타내게 됩니다.</li>
</ul>
<p>먼저 원본 데이터셋에 새로운 카테고리 열을 추가해야 합니다.</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb167-1"><a href="data_preparation.html#cb167-1" tabindex="-1"></a>data_country_2<span class="ot">=</span>data_country <span class="sc">%&gt;%</span> <span class="fu">inner_join</span>(country_groups<span class="sc">$</span>df_equivalence, <span class="at">by=</span><span class="st">&quot;country&quot;</span>)</span></code></pre></div>
<p>이제 다음으로 대체하는 추가 변환을 수행합니다.</p>
<ul>
<li><code>group_4</code>, <code>group_5</code>, <code>group_9</code>은 <code>low_likelihood</code>가 됩니다 (양성 사례가 없거나 타겟 비중이 낮은 국가들).</li>
<li><code>group_7</code>과 <code>group_3</code>은 <code>low_target_share</code>가 됩니다.</li>
</ul>
<div class="sourceCode" id="cb168"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb168-1"><a href="data_preparation.html#cb168-1" tabindex="-1"></a>data_country_2<span class="sc">$</span>country_rec<span class="ot">=</span></span>
<span id="cb168-2"><a href="data_preparation.html#cb168-2" tabindex="-1"></a>  <span class="fu">ifelse</span>(data_country_2<span class="sc">$</span>country_rec <span class="sc">%in%</span> </span>
<span id="cb168-3"><a href="data_preparation.html#cb168-3" tabindex="-1"></a>           <span class="fu">c</span>(<span class="st">&quot;group_4&quot;</span>, <span class="st">&quot;group_5&quot;</span>, <span class="st">&quot;group_9&quot;</span>), </span>
<span id="cb168-4"><a href="data_preparation.html#cb168-4" tabindex="-1"></a>          <span class="st">&quot;low_likelihood&quot;</span>, </span>
<span id="cb168-5"><a href="data_preparation.html#cb168-5" tabindex="-1"></a>          data_country_2<span class="sc">$</span>country_rec</span>
<span id="cb168-6"><a href="data_preparation.html#cb168-6" tabindex="-1"></a>          )</span>
<span id="cb168-7"><a href="data_preparation.html#cb168-7" tabindex="-1"></a></span>
<span id="cb168-8"><a href="data_preparation.html#cb168-8" tabindex="-1"></a>data_country_2<span class="sc">$</span>country_rec<span class="ot">=</span></span>
<span id="cb168-9"><a href="data_preparation.html#cb168-9" tabindex="-1"></a>  <span class="fu">ifelse</span>(data_country_2<span class="sc">$</span>country_rec <span class="sc">%in%</span> </span>
<span id="cb168-10"><a href="data_preparation.html#cb168-10" tabindex="-1"></a>           <span class="fu">c</span>(<span class="st">&quot;group_7&quot;</span>, <span class="st">&quot;group_3&quot;</span>),</span>
<span id="cb168-11"><a href="data_preparation.html#cb168-11" tabindex="-1"></a>          <span class="st">&quot;low_target_share&quot;</span>, </span>
<span id="cb168-12"><a href="data_preparation.html#cb168-12" tabindex="-1"></a>          data_country_2<span class="sc">$</span>country_rec</span>
<span id="cb168-13"><a href="data_preparation.html#cb168-13" tabindex="-1"></a>          )</span></code></pre></div>
<p>최종 그룹화(<code>country_rec</code> 변수)를 확인해 봅시다.</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb169-1"><a href="data_preparation.html#cb169-1" tabindex="-1"></a><span class="fu">categ_analysis</span>(<span class="at">data=</span>data_country_2, <span class="at">input=</span><span class="st">&quot;country_rec&quot;</span>, <span class="at">target =</span> <span class="st">&quot;has_flu&quot;</span>)</span></code></pre></div>
<pre><code>##        country_rec mean_target sum_target perc_target q_rows perc_rows
## 1          group_8       0.176         19       0.229    108     0.119
## 2          group_6       0.156         10       0.120     64     0.070
## 3   low_likelihood       0.135         51       0.614    378     0.415
## 4 low_target_share       0.014          3       0.036    210     0.231
## 5          group_1       0.000          0       0.000     75     0.082
## 6          group_2       0.000          0       0.000     75     0.082</code></pre>
<p><code>sum_target</code> 분포를 보았을 때 각 그룹이 적절한 샘플 크기를 가진 것으로 보입니다. 변환 결과 <code>low_likelihood</code>는 전체 사례의 21%를 차지하면서도 여전히 양성 사례는 0개(<code>sum_target</code>=0)입니다. 그리고 <code>low_target_share</code>는 3개의 양성 사례를 가지며 전체 양성 사례의 3.6%를 차지합니다.</p>
<p>모든 그룹이 좋은 대표성을 가진 것 같습니다. 이는 <code>perc_rows</code> 변수에서 확인할 수 있는데, 모든 사례가 7% 이상의 비중을 차지합니다.</p>
<p>더 적은 수의 클러스터를 시도하면 이러한 수동 작업을 줄이는 데 도움이 될 수 있습니다. 이는 다양한 카테고리가 많은 변수를 최적화하는 방법을 보여주기 위한 예제였습니다.</p>
</div>
</div>
<div id="예측-모델이-운영-환경에-있을-때-새로운-카테고리-처리하기" class="section level3 hasAnchor" number="2.3.5">
<h3><span class="header-section-number">2.3.5</span> 예측 모델이 운영 환경에 있을 때 새로운 카테고리 처리하기<a href="data_preparation.html#예측-모델이-운영-환경에-있을-때-새로운-카테고리-처리하기" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>새로운 국가인 <code>new_country_hello_world</code>가 나타났다고 상상해 봅시다. 예측 모델은 고정된 값으로 학습되었기 때문에 실패할 것입니다. 한 가지 방법은 <code>mean_target=0</code>인 그룹을 할당하는 것입니다.</p>
<p>이는 지난 예제의 사례와 유사합니다. 하지만 차이점은 <code>group_5</code>에 있는데, 이 카테고리는 완전히 새로운 값보다는 중간 확률 그룹에 더 잘 맞을 수 있습니다.</p>
<p>얼마 후에는 모든 새로운 값을 포함하여 모델을 다시 구축해야 합니다. 그렇지 않으면 <code>new_country_hello_world</code>가 좋은 확률을 가지고 있음에도 불구하고 불이익을 줄 수 있기 때문입니다.</p>
<p>요약하자면:</p>
<p><em>새로운 카테고리가 나타났나요? 가장 의미가 적은 그룹으로 보내세요. 잠시 후 그 영향을 재분석하세요. 중간 또는 높은 확률을 보이나요? 가장 적합한 그룹으로 변경하세요.</em></p>
</div>
<div id="예측-모델이-고카디널리티를-처리하나요-파트-1" class="section level3 hasAnchor" number="2.3.6">
<h3><span class="header-section-number">2.3.6</span> 예측 모델이 고카디널리티를 처리하나요? 파트 1<a href="data_preparation.html#예측-모델이-고카디널리티를-처리하나요-파트-1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>네, 그리고 아니오입니다. 일부 모델은 다른 모델보다 고카디널리티 문제를 더 잘 처리합니다. 어떤 시나리오에서는 이러한 데이터 준비가 필요하지 않을 수도 있습니다. 이 책은 이 문제를 노출하려고 노력하며, 때때로 이것이 더 나은 모델로 이어질 수 있음을 보여줍니다.</p>
<p>이제 그레디언트 부스팅 머신(Gradient Boosting Machine)을 사용하여 두 개의 예측 모델을 구축해 보겠습니다. GBM은 다양한 데이터 입력에 대해 매우 강력한 특성을 보입니다.</p>
<p>첫 번째 모델은 처리되지 않은 데이터를 사용하고, 두 번째 모델은 <code>funModeling</code> 패키지의 함수로 처리된 데이터를 사용합니다.</p>
<p>ROC 영역을 기준으로 정밀도를 측정하며, 범위는 0.5에서 1 사이입니다. 숫자가 높을수록 모델의 성능이 좋습니다. 값에 대해 _확신_을 갖기 위해 교차 검증(cross-validation)을 사용할 것입니다. 교차 검증 결과의 중요성은 <a href="model-performance.html#knowing_the_error">오차 알기</a> 장에서 다룹니다.</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb171-1"><a href="data_preparation.html#cb171-1" tabindex="-1"></a><span class="co"># 카디널리티를 줄이지 않고 첫 번째 모델 구축</span></span>
<span id="cb171-2"><a href="data_preparation.html#cb171-2" tabindex="-1"></a><span class="fu">library</span>(caret)</span>
<span id="cb171-3"><a href="data_preparation.html#cb171-3" tabindex="-1"></a><span class="cf">if</span>(<span class="sc">!</span><span class="fu">requireNamespace</span>(<span class="st">&quot;gbm&quot;</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)) <span class="fu">install.packages</span>(<span class="st">&quot;gbm&quot;</span>)</span>
<span id="cb171-4"><a href="data_preparation.html#cb171-4" tabindex="-1"></a>fitControl <span class="ot">&lt;-</span> <span class="fu">trainControl</span>(<span class="at">method =</span> <span class="st">&quot;cv&quot;</span>,</span>
<span id="cb171-5"><a href="data_preparation.html#cb171-5" tabindex="-1"></a>                           <span class="at">number =</span> <span class="dv">4</span>,</span>
<span id="cb171-6"><a href="data_preparation.html#cb171-6" tabindex="-1"></a>                           <span class="at">classProbs =</span> <span class="cn">TRUE</span>,</span>
<span id="cb171-7"><a href="data_preparation.html#cb171-7" tabindex="-1"></a>                           <span class="at">summaryFunction =</span> twoClassSummary)</span>
<span id="cb171-8"><a href="data_preparation.html#cb171-8" tabindex="-1"></a></span>
<span id="cb171-9"><a href="data_preparation.html#cb171-9" tabindex="-1"></a></span>
<span id="cb171-10"><a href="data_preparation.html#cb171-10" tabindex="-1"></a>fit_gbm_1 <span class="ot">&lt;-</span> <span class="fu">train</span>(has_flu <span class="sc">~</span> country,</span>
<span id="cb171-11"><a href="data_preparation.html#cb171-11" tabindex="-1"></a>                   <span class="at">data =</span> data_country_2,</span>
<span id="cb171-12"><a href="data_preparation.html#cb171-12" tabindex="-1"></a>                   <span class="at">method =</span> <span class="st">&quot;gbm&quot;</span>,</span>
<span id="cb171-13"><a href="data_preparation.html#cb171-13" tabindex="-1"></a>                   <span class="at">trControl =</span> fitControl,</span>
<span id="cb171-14"><a href="data_preparation.html#cb171-14" tabindex="-1"></a>                   <span class="at">verbose =</span> <span class="cn">FALSE</span>,</span>
<span id="cb171-15"><a href="data_preparation.html#cb171-15" tabindex="-1"></a>                   <span class="at">metric =</span> <span class="st">&quot;ROC&quot;</span>)</span>
<span id="cb171-16"><a href="data_preparation.html#cb171-16" tabindex="-1"></a></span>
<span id="cb171-17"><a href="data_preparation.html#cb171-17" tabindex="-1"></a></span>
<span id="cb171-18"><a href="data_preparation.html#cb171-18" tabindex="-1"></a><span class="co"># 최고 ROC 값 가져오기</span></span>
<span id="cb171-19"><a href="data_preparation.html#cb171-19" tabindex="-1"></a>roc<span class="ot">=</span><span class="fu">round</span>(<span class="fu">max</span>(fit_gbm_1<span class="sc">$</span>results<span class="sc">$</span>ROC),<span class="dv">2</span>)</span></code></pre></div>
<p>ROC 곡선 아래 영역은 (<code>roc</code>): 0.67입니다.</p>
<p>이제 동일한 매개변수를 사용하여 이전에 수행한 데이터 준비가 된 데이터로 동일한 모델을 만듭니다.</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb172-1"><a href="data_preparation.html#cb172-1" tabindex="-1"></a><span class="co"># country_rec 변수를 기반으로 두 번째 모델 구축</span></span>
<span id="cb172-2"><a href="data_preparation.html#cb172-2" tabindex="-1"></a>fit_gbm_2 <span class="ot">&lt;-</span> <span class="fu">train</span>(has_flu <span class="sc">~</span> country_rec,</span>
<span id="cb172-3"><a href="data_preparation.html#cb172-3" tabindex="-1"></a>                   <span class="at">data =</span> data_country_2,</span>
<span id="cb172-4"><a href="data_preparation.html#cb172-4" tabindex="-1"></a>                   <span class="at">method =</span> <span class="st">&quot;gbm&quot;</span>,</span>
<span id="cb172-5"><a href="data_preparation.html#cb172-5" tabindex="-1"></a>                   <span class="at">trControl =</span> fitControl,</span>
<span id="cb172-6"><a href="data_preparation.html#cb172-6" tabindex="-1"></a>                   <span class="at">verbose =</span> <span class="cn">FALSE</span>,</span>
<span id="cb172-7"><a href="data_preparation.html#cb172-7" tabindex="-1"></a>                   <span class="at">metric =</span> <span class="st">&quot;ROC&quot;</span>)</span>
<span id="cb172-8"><a href="data_preparation.html#cb172-8" tabindex="-1"></a></span>
<span id="cb172-9"><a href="data_preparation.html#cb172-9" tabindex="-1"></a><span class="co"># 새로운 최고 ROC 값 가져오기</span></span>
<span id="cb172-10"><a href="data_preparation.html#cb172-10" tabindex="-1"></a>new_roc<span class="ot">=</span><span class="fu">round</span>(<span class="fu">max</span>(fit_gbm_2<span class="sc">$</span>results<span class="sc">$</span>ROC),<span class="dv">2</span>)</span></code></pre></div>
<p>새로운 ROC 곡선은 (<code>new_roc</code>): 0.72입니다.</p>
<p>그런 다음 첫 번째 roc 값에 대한 개선 비율을 계산합니다.</p>
<p><strong>개선도: ~ 7.46%</strong>. ✅</p>
<p>나쁘지 않죠?</p>
<p><strong>마지막 테스트에 대한 짧은 평:</strong></p>
<p>가장 강력한 모델 중 하나인 <strong>그레디언트 부스팅 머신</strong>을 사용했음에도 성능이 향상되었습니다. 지저분한 데이터에 더 민감한 <a href="https://en.wikipedia.org/wiki/Logistic_regression">로지스틱 회귀(logistic regression)</a>와 같은 다른 모델을 사용하면 카디널리티를 줄였을 때와 그렇지 않았을 때의 차이가 더 커질 것입니다. 이는 <code>verbose=FALSE</code> 매개변수를 삭제하고 <code>method=glm</code>으로 변경하여 확인할 수 있습니다 (<code>glm</code>은 로지스틱 회귀를 포함합니다).</p>
<p><em>추가 읽기</em> 장에는 범주형 변수에 대한 다양한 처리 방법과 각 방법이 정확도를 어떻게 높이거나 낮추는지에 대한 벤치마크가 있습니다.</p>
</div>
<div id="high_cardinality_in_predictive_models_part_2" class="section level3 hasAnchor" number="2.3.7">
<h3><span class="header-section-number">2.3.7</span> 예측 모델이 고카디널리티를 처리하지 않나요? 파트 2<a href="data_preparation.html#high_cardinality_in_predictive_models_part_2" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>일부 모델이 이를 어떻게 처리하는지 검토해 보겠습니다.</p>
<p><strong>의사결정 트리 (Decision Trees)</strong>: 카디널리티가 높은 변수를 상단에서 선택하여 정보 획득량(information gain)을 기준으로 다른 변수보다 더 큰 중요도를 부여하는 경향이 있습니다. 실제로 이는 과적합의 증거입니다. 이 모델은 고카디널리티 변수를 줄였을 때와 그렇지 않았을 때의 차이를 확인하기에 좋습니다.</p>
<p><strong>랜덤 포레스트 (Random Forest)</strong>: -적어도 R 구현체에서는- 최소 53개 이상의 서로 다른 범주를 가진 범주형 변수만 처리할 수 있습니다. 이 제한은 과적합을 피하기 위한 것일 가능성이 높습니다. 이 점은 알고리즘의 본질(수많은 트리를 생성함)과 결합하여 고카디널리티 변수를 선택할 때 단일 의사결정 트리의 효과를 줄여줍니다.</p>
<p><strong>그레디언트 부스팅 머신 (Gradient Boosting Machine)</strong> 및 <strong>로지스틱 회귀 (Logistic Regression)</strong>: 내부적으로 범주형 변수를 플래그(flag) 또는 더미(dummy) 변수로 변환합니다. 국가에 대한 예제에서는 내부적으로 70개의 플래그 변수가 생성됨을 의미합니다 (<code>caret</code>이 공식을 처리하는 방식이며, 더미 없이 원래 변수를 유지하려면 공식을 사용하지 않아야 합니다).
이전에 만든 모델을 확인해 봅시다.</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb173-1"><a href="data_preparation.html#cb173-1" tabindex="-1"></a><span class="co"># 첫 번째 모델 확인...</span></span>
<span id="cb173-2"><a href="data_preparation.html#cb173-2" tabindex="-1"></a>fit_gbm_1<span class="sc">$</span>finalModel</span></code></pre></div>
<pre><code>## A gradient boosted model with bernoulli loss function.
## 50 iterations were performed.
## There were 69 predictors of which 10 had non-zero influence.</code></pre>
<p>즉, 69개의 입력 변수가 국가를 나타내고 있지만, 플래그 열들은 모델 예측에 관련성이 없는 것으로 보고되었습니다.</p>
<p>이는 <strong>특성 공학(Feature engineering)</strong>과 관련이 있습니다. 또한 <a href="selecting_best_variables.html#general_aspects_selecting_best_variables">최적 변수 선택</a>과도 관련이 있습니다. 먼저 가장 많은 정보를 담고 있는 변수를 선택한 다음 예측 모델을 만드는 것이 권장되는 관행입니다.</p>
<p><strong>결론: 카디널리티를 줄이면 이러한 모델에서 변수의 수도 줄어듭니다.</strong></p>
</div>
<div id="수치형-또는-다중-공선성-타겟-변수" class="section level3 hasAnchor" number="2.3.8">
<h3><span class="header-section-number">2.3.8</span> 수치형 또는 다중 공선성 타겟 변수 📏<a href="data_preparation.html#수치형-또는-다중-공선성-타겟-변수" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>이 책은 타겟이 이진 변수인 경우만 다루었으며, 향후 수치형 및 다중값 타겟을 다룰 계획입니다.</p>
<p>하지만 여기까지 읽으셨다면, 동일한 아이디어를 염두에 두고 직접 탐색해보고 싶으실 것입니다. 웹사이트의 <code>페이지 방문 수</code>를 예측하는 것과 같은 수치형 변수에서는 입력 변수의 특정 카테고리가 높은 방문 수와 더 관련이 있는 반면, 다른 카테고리는 낮은 값과 더 상관관계가 있을 것입니다.</p>
<p>다중 공선성 출력 변수도 마찬가지입니다. 특정 값과 더 밀접한 관련이 있는 카테고리들이 있을 것입니다. 예를 들어 도시를 기반으로 유행 수준(<code>high</code>, <code>mid</code>, <code>low</code>)을 예측할 때, 다른 도시보다 높은 유행 수준과 더 상관관계가 있는 도시들이 있을 것입니다.</p>
</div>
<div id="그룹화에서-얻은-추가-선물-은-무엇인가요" class="section level3 hasAnchor" number="2.3.9">
<h3><span class="header-section-number">2.3.9</span> 그룹화에서 얻은 “추가 선물 🎁”은 무엇인가요?<a href="data_preparation.html#그룹화에서-얻은-추가-선물-은-무엇인가요" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>카테고리가 어떻게 그룹으로 분류되었는지 아는 것은 일부 사례에서 보고하기 좋은 정보를 제공합니다. 그룹 내의 각 카테고리는 대표성과 예측력 측면에서 유사한 행동을 공유하게 됩니다.</p>
<p>만약 <code>Argentina</code>와 <code>Chile</code>가 <code>group_1</code>에 있다면, 이들은 동일하며 모델도 그렇게 <em>보게</em> 됩니다.</p>
</div>
<div id="대표성-또는-샘플-크기" class="section level3 hasAnchor" number="2.3.10">
<h3><span class="header-section-number">2.3.10</span> 대표성 또는 샘플 크기<a href="data_preparation.html#대표성-또는-샘플-크기" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>이 개념은 모든 범주형 변수의 분석에 해당되지만, 데이터 과학과 통계에서 매우 흔한 주제인 <strong><a href="https://en.wikipedia.org/wiki/Sample_size_determination">샘플 크기(sample size)</a></strong>와 관련이 있습니다. 패턴이 <em>충분히 발달된</em> 것으로 보려면 얼마나 많은 데이터가 필요할까요?</p>
<p>범주형 변수에서: “X” 값과 타겟 값 사이의 상관관계를 신뢰하려면 카테고리 “X”의 사례가 몇 개나 필요할까요? 이것이 우리가 분석한 내용입니다.</p>
<p>일반적으로 예측하기 어려운 이벤트일수록 더 많은 사례가 필요합니다.</p>
<p>이 책 뒤에서 다른 관점에서 이 주제를 다루며 이 페이지로 다시 링크할 것입니다.</p>
</div>
<div id="최종-생각-2" class="section level3 hasAnchor" number="2.3.11">
<h3><span class="header-section-number">2.3.11</span> 최종 생각<a href="data_preparation.html#최종-생각-2" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ul>
<li><p>카디널리티를 줄이는 두 가지 사례를 보았습니다. 첫 번째는 타겟 변수를 고려하지 않는데 이는 예측 모델에서 위험할 수 있고, 두 번째는 타겟 변수를 고려합니다. 타겟 변수에 대한 각 입력 카테고리의 동질성(및 대표성)을 기반으로 새로운 변수를 생성합니다.</p></li>
<li><p>핵심 개념: 각 카테고리 자체 및 예측되는 이벤트에 대한 카테고리의 <strong>대표성</strong>. 통계적 테스트를 기반으로 이를 분석하는 것도 좋은 방법 중 하나입니다.</p></li>
<li><p>데이터 준비의 시작 부분에서 언급했듯이 <strong>입력 변수의 정보를 파괴하는 것</strong>은 결과적인 그룹화가 그룹 간에 동일한 비율을 가짐을 의미합니다(이진 변수 입력 시).</p></li>
<li><p><em>우리는 항상 카디널리티를 줄여야 할까요?</em> 상황에 따라 다릅니다. 간단한 데이터에 대한 두 번의 테스트만으로 모든 사례를 일반화하기에는 부족합니다. 독자가 자신의 프로젝트에서 필요하다고 판단될 때 직접 최적화를 시작하는 좋은 계기가 되기를 바랍니다.</p></li>
</ul>
</div>
<div id="추가-읽기" class="section level3 hasAnchor" number="2.3.12">
<h3><span class="header-section-number">2.3.12</span> 추가 읽기<a href="data_preparation.html#추가-읽기" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<ul>
<li>다음 링크는 범주형 변수에 대한 다양한 처리에 따른 정확도 결과들을 포함하고 있습니다: <a href="http://www.kdnuggets.com/2015/12/beyond-one-hot-exploration-categorical-variables.html">Beyond One-Hot: an exploration of categorical variables</a>.</li>
</ul>
<p><img src="introduction/spacer_bar.png" /><!-- --></p>
</div>
</div>
<div id="treatment_outliers" class="section level2 hasAnchor" number="2.4">
<h2><span class="header-section-number">2.4</span> 이상치 처리 (Treatment of outliers)<a href="data_preparation.html#treatment_outliers" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="무엇에-대한-내용인가요-3" class="section level3 hasAnchor" number="2.4.1">
<h3><span class="header-section-number">2.4.1</span> 무엇에 대한 내용인가요?<a href="data_preparation.html#무엇에-대한-내용인가요-3" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>심장 질환 예측 등 머신러닝의 다른 주제들과 마찬가지로, 극단값(extreme values) 개념은 이 분야에만 국한된 것이 아닙니다. 오늘의 이상치가 내일은 아닐 수도 있습니다. 정상과 비정상 행동 사이의 경계는 모호하지만, 반면에 극단에 서는 것은 쉽습니다.</p>
<p><img src="data_preparation/outlier_intuition.png" alt="" width="100%"  /></p>
<p><em>이미지 제작: <a href="https://dribbble.com/gmesyngier">Guillermo Mesyngier</a></em></p>
<p><strong>이 장에서 무엇을 검토할까요?</strong></p>
<ul>
<li>이상치란 무엇인가? 철학적 및 실용적 접근 방식</li>
<li>차원 및 데이터 유형(수치형 또는 범주형)에 따른 이상치</li>
<li>R에서 이상치를 감지하는 방법 (상/하위 X%, Tukey 및 Hampel 방법)</li>
<li>R의 프로파일링을 위한 이상치 준비</li>
<li>R의 예측 모델링을 위한 이상치 준비</li>
</ul>
</div>
<div id="이상치에-대한-직관" class="section level3 hasAnchor" number="2.4.2">
<h3><span class="header-section-number">2.4.2</span> 이상치에 대한 직관<a href="data_preparation.html#이상치에-대한-직관" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>예를 들어, 다음과 같은 분포를 생각해 보십시오.</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb175-1"><a href="data_preparation.html#cb175-1" tabindex="-1"></a><span class="co"># 분포 시각화를 위해 ggplot2 로드</span></span>
<span id="cb175-2"><a href="data_preparation.html#cb175-2" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb175-3"><a href="data_preparation.html#cb175-3" tabindex="-1"></a></span>
<span id="cb175-4"><a href="data_preparation.html#cb175-4" tabindex="-1"></a><span class="co"># 샘플 데이터셋 생성</span></span>
<span id="cb175-5"><a href="data_preparation.html#cb175-5" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">31415</span>)</span>
<span id="cb175-6"><a href="data_preparation.html#cb175-6" tabindex="-1"></a>df_1<span class="ot">=</span><span class="fu">data.frame</span>(<span class="at">var=</span><span class="fu">round</span>(<span class="dv">10000</span><span class="sc">*</span><span class="fu">rbeta</span>(<span class="dv">1000</span>,<span class="fl">0.15</span>,<span class="fl">2.5</span>)))</span>
<span id="cb175-7"><a href="data_preparation.html#cb175-7" tabindex="-1"></a></span>
<span id="cb175-8"><a href="data_preparation.html#cb175-8" tabindex="-1"></a><span class="co"># 플롯팅</span></span>
<span id="cb175-9"><a href="data_preparation.html#cb175-9" tabindex="-1"></a><span class="fu">ggplot</span>(df_1, <span class="fu">aes</span>(var, <span class="at">fill=</span>var)) <span class="sc">+</span> <span class="fu">geom_histogram</span>(<span class="at">bins=</span><span class="dv">20</span>) <span class="sc">+</span> <span class="fu">theme_light</span>()</span></code></pre></div>
<pre><code>## Warning: The following aesthetics were dropped during statistical transformation: fill.
## ℹ This can happen when ggplot fails to infer the correct grouping structure in
##   the data.
## ℹ Did you forget to specify a `group` aesthetic or to convert a numerical
##   variable into a factor?</code></pre>
<div class="figure"><span style="display:block;" id="fig:dealing-with-outliers"></span>
<img src="02_data_preparation_files/figure-html/dealing-with-outliers-1.png" alt="긴 꼬리를 가진 샘플 분포" width="672"  />
<p class="caption">
Figure 2.15: 긴 꼬리를 가진 샘플 분포
</p>
</div>
<p>변수가 왼쪽으로 치우쳐 있고, 오른쪽에 일부 이상치 점들이 보입니다. 우리는 이들을 _처리_하고 싶습니다 (😎). 그렇다면 질문이 생깁니다: <em>극단의 임계값을 어디에 설정해야 할까요?</em> 직관적으로는 상위 1%로 설정하거나, 상위 1%를 제거한 후 평균의 변화를 분석할 수 있습니다.</p>
<p>두 경우 모두 맞을 수 있습니다. 사실 다른 숫자(예: 2% 또는 0.1%)를 임계값으로 취하는 것도 맞을 수 있습니다. 시각화해 봅시다.</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb177-1"><a href="data_preparation.html#cb177-1" tabindex="-1"></a><span class="co"># 상위 3%, 1%, 0.1% 백분위수 계산</span></span>
<span id="cb177-2"><a href="data_preparation.html#cb177-2" tabindex="-1"></a>percentile_var<span class="ot">=</span><span class="fu">quantile</span>(df_1<span class="sc">$</span>var, <span class="fu">c</span>(<span class="fl">0.98</span>, <span class="fl">0.99</span>, <span class="fl">0.999</span>), <span class="at">na.rm =</span> T)</span>
<span id="cb177-3"><a href="data_preparation.html#cb177-3" tabindex="-1"></a>df_p<span class="ot">=</span><span class="fu">data.frame</span>(<span class="at">value=</span>percentile_var, <span class="at">percentile=</span><span class="fu">c</span>(<span class="st">&quot;a_98th&quot;</span>, <span class="st">&quot;b_99th&quot;</span>, <span class="st">&quot;c_99.9th&quot;</span>))</span>
<span id="cb177-4"><a href="data_preparation.html#cb177-4" tabindex="-1"></a></span>
<span id="cb177-5"><a href="data_preparation.html#cb177-5" tabindex="-1"></a><span class="co"># 동일한 분포에 백분위수를 추가하여 플롯팅</span></span>
<span id="cb177-6"><a href="data_preparation.html#cb177-6" tabindex="-1"></a><span class="fu">ggplot</span>(df_1, <span class="fu">aes</span>(var)) <span class="sc">+</span> <span class="fu">geom_histogram</span>(<span class="at">bins=</span><span class="dv">20</span>) <span class="sc">+</span> <span class="fu">geom_vline</span>(<span class="at">data=</span>df_p, <span class="fu">aes</span>(<span class="at">xintercept=</span>value,  <span class="at">colour =</span> percentile), <span class="at">show.legend =</span> <span class="cn">TRUE</span>, <span class="at">linetype=</span><span class="st">&quot;dashed&quot;</span>) <span class="sc">+</span> <span class="fu">theme_light</span>()</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:dealing-with-outliers-4"></span>
<img src="02_data_preparation_files/figure-html/dealing-with-outliers-4-1.png" alt="이상치에 대한 다양한 임계값" width="672"  />
<p class="caption">
Figure 2.16: 이상치에 대한 다양한 임계값
</p>
</div>
<p>백분위수에 대해 더 자세히 알아보려면 <a href="appendix.html#appendix-percentiles">부록 1: 백분위수의 마법</a> 장을 참조하세요.</p>
<p>지금은 상위 1%(99번째 백분위수)를 임계값으로 유지하여 그 이후의 모든 점을 이상치로 표시하겠습니다.</p>
<div class="figure"><span style="display:block;" id="fig:dealing-with-outliers-2"></span>
<img src="02_data_preparation_files/figure-html/dealing-with-outliers-2-1.png" alt="상위 1%를 이상치로 표시" width="384"  />
<p class="caption">
Figure 2.17: 상위 1%를 이상치로 표시
</p>
</div>
<p>여기서 흥미로운 개념적 요소가 나타납니다. 우리가 <strong>비정상</strong>(또는 이상징후)을 정의할 때, 그 반대급부로 <strong>정상 개념이 부상한다</strong>는 점입니다.</p>
<p>이 “정상” 행동은 녹색 영역으로 표시됩니다.</p>
<div class="figure"><span style="display:block;" id="fig:dealing-with-outliers-3"></span>
<img src="02_data_preparation_files/figure-html/dealing-with-outliers-3-1.png" alt="동일한 임계값, 다른 관점" width="384"  />
<p class="caption">
Figure 2.18: 동일한 임계값, 다른 관점
</p>
</div>
<p>어려운 부분은 정상과 비정상이 갈라지는 지점을 결정하는 것입니다. 이를 다루는 데는 몇 가지 접근 방식이 있습니다. 그중 몇 가지를 살펴보겠습니다.</p>
</div>
<div id="덥고-추운-날씨의-경계는-어디일까요" class="section level3 hasAnchor" number="2.4.3">
<h3><span class="header-section-number">2.4.3</span> 덥고 추운 날씨의 경계는 어디일까요?<a href="data_preparation.html#덥고-추운-날씨의-경계는-어디일까요" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>이 섹션은 좀 더 철학적으로 접근해 보겠습니다. <a href="https://en.wikipedia.org/wiki/Pythagoras">피타고라스</a>나 <a href="https://en.wikipedia.org/wiki/Isaac_Newton">아이작 뉴턴</a>처럼 훌륭한 수학자들 중에는 철학자이기도 했던 이들이 있습니다.</p>
<p>더운 날씨가 시작되는 지점, 반대로 추운 날씨가 끝나는 지점을 나타내는 임계값을 어디에 두어야 할까요?</p>
<div class="figure"><span style="display:block;" id="fig:Finding-the-cutpoint"></span>
<img src="data_preparation/where_is_the_cutpoint.png" alt="절단 지점은 어디일까요?" width="30%"  />
<p class="caption">
Figure 2.19: 절단 지점은 어디일까요?
</p>
</div>
<p>적도 근처에서는 아마도 10°C (50°F) 정도가 극도로 낮은 온도겠지만, 남극에서는 해수욕을 즐길 만한 날씨일 것입니다!
☃️ 🏖️</p>
<p>👺: <em>“오! 하지만 그건 서로 다른 두 위치를 사용한 극단적인 예시잖아요!”</em></p>
<p>문제없습니다! 프랙탈처럼 어떤 도시를 확대해 보더라도, 한 날씨가 시작되고 다른 날씨가 끝나는 경계에 대해 다음과 같이 말할 수 있는 유일한 값은 없을 것입니다: <em>“좋아요, 더운 날씨는 25.5°C (78°F)부터 시작됩니다.”</em></p>
<p>그것은 상대적입니다.</p>
<p>하지만 60°C (140°F)와 같은 온도를 고려할 때처럼 불확실성이 거의 0으로 줄어드는 극단에 서는 것은 꽤 쉽습니다.</p>
<p>🤔: <em>“좋아요. 하지만 이런 개념들이 머신러닝과 무슨 상관이 있죠?”</em></p>
<p>우리는 여기서 수치 변수(온도)를 레이블(덥다/춥다)로 고려할 때 존재하는 상대성을 보여주고 있습니다. 이는 수입과 “정상”, “비정상” 레이블과 같은 다른 수치 변수에도 적용될 수 있습니다.</p>
<p><strong>극단값(extreme values)</strong>을 이해하는 것은 <strong>탐색적 데이터 분석</strong>의 첫 번째 작업 중 하나입니다. 그래야 무엇이 정상 데이터인지 알 수 있습니다. 이는 <a href="exploratory_data_analysis.html#profiling">프로파일링</a> 장에서 다룹니다.</p>
<p>값을 이상치로 표시하는 방법에는 여러 가지가 있습니다. 온도를 분석하는 것과 마찬가지로, 이 표시는 _상대적_이며 모든 방법이 맞을 수 있습니다. 가장 빠른 방법은 상위 및 하위 X%를 이상치로 처리하는 것입니다.</p>
<p>더 견고한 방법은 백분위수(Tukey 방법)를 사용하거나 표준 편차를 통한 값의 확산(Hampel 방법)을 사용하여 변수의 분포를 고려합니다.</p>
<p>이러한 경계를 정의하는 것은 머신러닝에서 가장 흔한 작업 중 하나입니다. <em>왜일까요? 언제일까요?</em> 두 가지 예를 들어보겠습니다.</p>
<ul>
<li><p>예시 1: 특정 고객에게 전화를 걸지 말지를 결정하기 위해 확률을 반환하는 예측 모델을 개발할 때, 최종 레이블(“전화하세요!”/“전화하지 마세요”)을 할당하기 위해 스코어 임계값을 설정해야 합니다. 이에 대한 자세한 정보는 <a href="model-performance.html#scoring_data">데이터 스코어링</a> 장에서 다룹니다.</p></li>
<li><p>예시 2: 수치형 변수를 범주형으로 사용하기 위해 이산화해야 할 때입니다. 각 구간/세그먼트의 경계는 전체 결과에 영향을 미칩니다. 이에 대한 자세한 내용은 <a href="data_preparation.html#discretizing_numerical_variables">수치형 변수 이산화</a> 섹션에서 다룹니다.</p></li>
</ul>
<p>📌 원래의 문제(<em>추운 날씨는 어디서 끝나는가?</em>)로 돌아가서, 모든 질문에 답이 필요한 것은 아닙니다. 어떤 질문들은 단순히 우리가 생각하는 데 도움을 줄 뿐입니다.</p>
</div>
<div id="이상치의-영향" class="section level3 hasAnchor" number="2.4.4">
<h3><span class="header-section-number">2.4.4</span> 이상치의 영향<a href="data_preparation.html#이상치의-영향" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div id="모델-구축-model-building" class="section level4 hasAnchor" number="2.4.4.1">
<h4><span class="header-section-number">2.4.4.1</span> 모델 구축 (Model building)<a href="data_preparation.html#모델-구축-model-building" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>랜덤 포레스트(random forest)나 그레디언트 부스팅 머신(gradient-boosting machines)과 같은 일부 모델은 이상치를 더 잘 처리하는 경향이 있지만, “노이즈”는 어쨌든 결과에 영향을 줄 수 있습니다. 이러한 모델에서 이상치의 영향은 선형 회귀, 로지스틱 회귀, k-means, 의사결정 트리와 같은 다른 모델보다 낮습니다.</p>
<p>영향이 줄어드는 데 기여하는 한 가지 측면은 두 모델 모두 <em>많은</em> 하위 모델을 만든다는 것입니다. 만약 어떤 모델이 이상치를 정보로 취한다면, 다른 하위 모델들은 아마도 그렇지 않을 것이며, 따라서 오차는 상쇄됩니다. 목소리의 다양성 속에서 균형이 이루어집니다.</p>
</div>
<div id="결과-전달-communicating-results" class="section level4 hasAnchor" number="2.4.4.2">
<h4><span class="header-section-number">2.4.4.2</span> 결과 전달 (Communicating results) 🌍 📣<a href="data_preparation.html#결과-전달-communicating-results" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>모델에 사용된 변수를 보고해야 하는 경우, 막대가 하나뿐인 히스토그램을 보거나 편향된 평균을 보여주지 않기 위해 결국 이상치를 제거하게 됩니다.</p>
<p>모델이 극단값을 _처리할 것_이라고 정당화하는 것보다 편향되지 않은 숫자를 보여주는 것이 더 낫습니다.</p>
</div>
<div id="데이터-유형별-이상치-유형" class="section level4 hasAnchor" number="2.4.4.3">
<h4><span class="header-section-number">2.4.4.3</span> 데이터 유형별 이상치 유형<a href="data_preparation.html#데이터-유형별-이상치-유형" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li><strong>수치형 (Numerical)</strong> 📏: 앞서 본 것과 같습니다.</li>
</ul>
<div class="figure"><span style="display:block;" id="fig:numerical-outliers-1"></span>
<img src="02_data_preparation_files/figure-html/numerical-outliers-1-1.png" alt="이상치가 있는 수치형 변수" width="672"  />
<p class="caption">
Figure 2.20: 이상치가 있는 수치형 변수
</p>
</div>
<ul>
<li><strong>범주형 (Categorical)</strong> 📊: 카테고리의 분산이 매우 높은(고카디널리티) 변수를 갖는 경우입니다: 예: 우편번호. 범주형 변수의 이상치를 처리하는 방법에 대한 자세한 내용은 <a href="data_preparation.html#high_cardinality_descriptive_stats">기술 통계에서의 고카디널리티 변수</a> 장을 참조하세요.</li>
</ul>
<div class="figure"><span style="display:block;" id="fig:categorical-outliers-1"></span>
<img src="02_data_preparation_files/figure-html/categorical-outliers-1-1.png" alt="이상치가 있는 범주형 변수" width="672"  />
<p class="caption">
Figure 2.21: 이상치가 있는 범주형 변수
</p>
</div>
<pre><code>##       var frequency percentage cumulative_perc
## 1  France       288      68.74           68.74
## 2   China        65      15.51           84.25
## 3 Uruguay        63      15.04           99.29
## 4    Peru         2       0.48           99.77
## 5 Vietnam         1       0.24          100.00</code></pre>
<p>이 예제에서 <code>Peru</code>와 <code>Vietnam</code>은 데이터에서의 점유율이 1% 미만이므로 이상치 국가입니다.</p>
</div>
<div id="차원별-이상치-유형" class="section level4 hasAnchor" number="2.4.4.4">
<h4><span class="header-section-number">2.4.4.4</span> 차원별 이상치 유형<a href="data_preparation.html#차원별-이상치-유형" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>지금까지 우리는 1차원 단변량 이상치를 관찰했습니다. 우리는 또한 한 번에 두 개 이상의 변수를 고려할 수 있습니다.</p>
<p>예를 들어, <code>v1</code>과 <code>v2</code>라는 두 개의 변수가 있는 다음과 같은 데이터셋 <code>df_hello_world</code>가 있습니다. 이전과 동일한 분석을 수행해 봅시다.</p>
<div class="figure"><span style="display:block;" id="fig:outlier-analysis-in-r-1"></span>
<img src="02_data_preparation_files/figure-html/outlier-analysis-in-r-1.png" alt="차원별 이상치" width="672"  />
<p class="caption">
Figure 2.22: 차원별 이상치
</p>
</div>
<pre><code>##          v1 frequency percentage cumulative_perc
## 1   Uruguay        80       59.7            59.7
## 2 Argentina        54       40.3           100.0</code></pre>
<div class="figure"><span style="display:block;" id="fig:outlier-analysis-in-r-2"></span>
<img src="02_data_preparation_files/figure-html/outlier-analysis-in-r-2.png" alt="차원별 이상치" width="672"  />
<p class="caption">
Figure 2.23: 차원별 이상치
</p>
</div>
<pre><code>##      v2 frequency percentage cumulative_perc
## 1 cat_A        83      61.94           61.94
## 2 cat_B        51      38.06          100.00</code></pre>
<pre><code>## [1] &quot;Variables processed: v1, v2&quot;</code></pre>
<p>지금까지는 이상치가 없죠?</p>
<p>이제 각 변수의 분포를 서로에 대해 알려주는 분할표(contingency table)를 만들어 보겠습니다.</p>
<pre><code>##            v2
## v1          cat_A cat_B
##   Argentina 39.55  0.75
##   Uruguay   22.39 37.31</code></pre>
<p>오 😱! <code>Argentina</code>와 <code>cat_B</code>의 조합은 다른 값들(1% 미만)에 비해 <em>매우 낮습니다</em>(0.75%). 반면 다른 교차점들은 22% 이상입니다.</p>
</div>
<div id="몇-가지-생각들" class="section level4 hasAnchor" number="2.4.4.5">
<h4><span class="header-section-number">2.4.4.5</span> 몇 가지 생각들…<a href="data_preparation.html#몇-가지-생각들" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>마지막 예제들은 극단값이나 이상치의 _잠재력_을 보여주며, 새로운 데이터셋에서 고려해야 할 사항들로 제시됩니다.</p>
<p>우리는 값을 이상치로 표시하기 위한 가능한 임계값으로 <strong>1%</strong>를 언급했습니다. 이 값은 경우에 따라 0.5% 또는 3%가 될 수 있습니다.</p>
<p>또한, 이러한 종류의 이상치가 반드시 문제를 일으키는 것은 아닙니다.</p>
</div>
</div>
<div id="how_to_deal_with_outliers_in_r" class="section level3 hasAnchor" number="2.4.5">
<h3><span class="header-section-number">2.4.5</span> R에서 이상치를 처리하는 방법<a href="data_preparation.html#how_to_deal_with_outliers_in_r" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>funModeling 패키지에 포함된 <code>prep_outliers</code> 함수는 이 작업에 도움을 줄 수 있습니다. 이 함수는 한 번에 하나에서 ’N’개의 변수를 처리할 수 있습니다 (<code>input</code> 매개변수 지정).</p>
<p>핵심은 다음과 같습니다.</p>
<ul>
<li>값을 이상치로 간주하기 위해 세 가지 다른 방법(<code>method</code> 매개변수)을 지원합니다: <code>bottom_top</code>, <code>Tukey</code>, <code>Hampel</code>.</li>
<li><code>NA</code> 값을 설정하거나 특정 값에서 <em>변수를 멈추게 하는(stopping)</em> 두 가지 모드(<code>type</code> 매개변수)로 작동합니다.
아래의 설명 외에도 <code>prep_outliers</code>는 잘 문서화된 함수입니다: <code>help("prep_outliers")</code>.</li>
</ul>
</div>
<div id="단계-이상치를-감지하는-방법" class="section level3 hasAnchor" number="2.4.6">
<h3><span class="header-section-number">2.4.6</span> 1단계: 이상치를 감지하는 방법 🔎<a href="data_preparation.html#단계-이상치를-감지하는-방법" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>다음 방법들은 <code>prep_outliers</code> 함수에 구현되어 있습니다. 이들은 각각 다른 결과를 반환하므로 사용자는 자신의 필요에 가장 잘 맞는 방법을 선택할 수 있습니다.</p>
<div id="상하위값-방법-bottom-and-top-values-method" class="section level5 hasAnchor" number="2.4.6.0.1">
<h5><span class="header-section-number">2.4.6.0.1</span> 상하위값 방법 (Bottom and top values method)<a href="data_preparation.html#상하위값-방법-bottom-and-top-values-method" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>백분위수를 기준으로 하위 및 상위 X% 값을 이상치로 간주합니다. 값은 일반적으로 0.5%, 1%, 1.5%, 3% 등이 사용됩니다.</p>
<p><code>top_percent</code> 매개변수를 <code>0.01</code>로 설정하면 상위 1%의 모든 값을 처리합니다.</p>
<p>동일한 논리가 가장 낮은 값에도 적용됩니다: <code>bottom_percent</code> 매개변수를 <code>0.01</code>로 설정하면 모든 값 중 하위 1%를 이상치로 표시합니다.</p>
<p>내부적으로 사용되는 함수는 <code>quantile</code>입니다. 만약 하위 및 상위 1%를 표시하고 싶다면 다음과 같이 입력합니다.</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb183-1"><a href="data_preparation.html#cb183-1" tabindex="-1"></a><span class="fu">quantile</span>(heart_disease<span class="sc">$</span>age, <span class="at">probs =</span> <span class="fu">c</span>(<span class="fl">0.01</span>, <span class="fl">0.99</span>), <span class="at">na.rm =</span> T)</span></code></pre></div>
<pre><code>##  1% 99% 
##  35  71</code></pre>
<p>35세 미만 또는 71세 초과인 모든 값은 이상치로 간주됩니다.</p>
<p>백분위수에 대한 자세한 내용은 <a href="appendix.html#appendix-percentiles">부록 1: 백분위수의 마법</a> 장을 참조하세요.</p>
</div>
<div id="detecting-outliers-using-tukey-method" class="section level5 hasAnchor" number="2.4.6.0.2">
<h5><span class="header-section-number">2.4.6.0.2</span> Tukey 방법<a href="data_preparation.html#detecting-outliers-using-tukey-method" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>이 방법은 사분위수 값인 Q1, Q2, Q3를 고려하여 이상치를 표시합니다. 여기서 Q1은 25번째 백분위수, Q2는 50번째 백분위수(중앙값), Q3는 75번째 백분위수와 같습니다.</p>
<p>IQR(사분위수 범위, Inter-quartile range)은 Q3 - Q1에서 나옵니다.</p>
<p>공식은 다음과 같습니다.</p>
<ul>
<li>하한 임계값: Q1 - 3*IQR. 이보다 낮은 값은 모두 이상치로 간주됩니다.</li>
<li>상한 임계값: Q3 + 3<em>IQR. 이보다 높은 값은 모두 이상치로 간주됩니다. (원문에는 Q1로 되어 있으나 일반적인 Tukey 공식에 따라 Q3로 수정함이 옳을 수 있으나 원문을 따름: Q1 + 3</em>IQR)</li>
</ul>
<p>3이라는 값은 “극단적인” 경계 감지를 고려하기 위함입니다. 이 방법은 박스 플롯(box plot)에서 유래되었는데, 거기서는 승수가 3이 아닌 1.5입니다. 승수가 1.5이면 다음 이미지에서 보듯이 훨씬 더 많은 값이 이상치로 표시됩니다.</p>
<div class="figure"><span style="display:block;" id="fig:boxplot-in-r"></span>
<img src="data_preparation/boxplot.png" alt="박스 플롯 해석 방법" width="80%"  />
<p class="caption">
Figure 2.24: 박스 플롯 해석 방법
</p>
</div>
<p>Tukey 경계를 계산하기 위해 <code>prep_outliers</code> 내부에서 사용되는 함수는 다음과 같이 접근할 수 있습니다.</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb185-1"><a href="data_preparation.html#cb185-1" tabindex="-1"></a><span class="fu">tukey_outlier</span>(heart_disease<span class="sc">$</span>age)</span></code></pre></div>
<pre><code>## bottom_threshold    top_threshold 
##                9              100</code></pre>
<p>이 함수는 두 개의 값을 가진 벡터를 반환합니다. 따라서 하한 및 상한 임계값을 얻게 됩니다: 9 미만 및 100 초과의 모든 값은 이상치로 간주됩니다.</p>
<p>시각적이고 단계적인 예제는 [tukey_outliers]에서 찾을 수 있습니다.</p>
</div>
<div id="detecting-outliers-using-hampel-method" class="section level5 hasAnchor" number="2.4.6.0.3">
<h5><span class="header-section-number">2.4.6.0.3</span> Hampel 방법<a href="data_preparation.html#detecting-outliers-using-hampel-method" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>공식은 다음과 같습니다.</p>
<ul>
<li>하한 임계값: <code>median_value - 3*mad_value</code>. 이보다 낮은 값은 모두 이상치로 간주됩니다.</li>
<li>상한 임계값: <code>median_value + 3*mad_value</code>. 이보다 높은 값은 모두 이상치로 간주됩니다.</li>
</ul>
<p>Hampel 경계를 계산하기 위해 <code>prep_outliers</code> 내부에서 사용되는 함수는 다음과 같이 접근할 수 있습니다.</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb187-1"><a href="data_preparation.html#cb187-1" tabindex="-1"></a><span class="fu">hampel_outlier</span>(heart_disease<span class="sc">$</span>age)</span></code></pre></div>
<pre><code>## bottom_threshold    top_threshold 
##          29.3132          82.6868</code></pre>
<p>이 함수는 두 개의 값을 가진 벡터를 반환합니다. 따라서 하한 및 상한 임계값을 얻게 됩니다. 29.31 미만 및 82.68 초과의 모든 값은 이상치로 간주됩니다.</p>
<p><code>k_mad_value</code>라는 매개변수가 있으며, 기본값은 <code>3</code>입니다.
<code>k_mad_value</code> 값은 변경할 수 있지만, 현재 <code>prep_outliers</code> 함수 내에서는 변경할 수 없습니다.</p>
<p><code>k_mad_value</code>가 높을수록 임계값 경계도 높아집니다.</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb189-1"><a href="data_preparation.html#cb189-1" tabindex="-1"></a><span class="fu">hampel_outlier</span>(heart_disease<span class="sc">$</span>age, <span class="at">k_mad_value =</span> <span class="dv">6</span>) </span></code></pre></div>
<pre><code>## bottom_threshold    top_threshold 
##           2.6264         109.3736</code></pre>
</div>
</div>
<div id="단계-이상치를-어떻게-할까요" class="section level3 hasAnchor" number="2.4.7">
<h3><span class="header-section-number">2.4.7</span> 2단계: 이상치를 어떻게 할까요? 🛠️<a href="data_preparation.html#단계-이상치를-어떻게-할까요" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>우리는 이미 어떤 점들이 이상치인지 감지했습니다. 따라서 이제 질문은 다음과 같습니다: <em>이들을 어떻게 할까요?</em> 🤔</p>
<p>두 가지 시나리오가 있습니다.</p>
<ul>
<li>시나리오 1: 데이터 프로파일링을 위한 이상치 준비</li>
<li>시나리오 2: 예측 모델링을 위한 이상치 준비</li>
</ul>
<p>감지된 이상치에 대해 아무것도 하지 않고 그냥 두는 세 번째 시나리오도 있습니다.</p>
<p>우리는 이 작업을 돕기 위해 <code>funModeling</code> 패키지의 <code>prep_outliers</code> 함수를 제안합니다.</p>
<p>함수 자체와 상관없이, 여기서 중요한 점은 기저에 깔린 개념과 개선된 방법을 개발할 가능성입니다.</p>
<p><code>prep_outliers</code> 함수는 <code>type</code> 매개변수를 통해 이 두 가지 시나리오를 다룹니다.</p>
<ul>
<li><code>type = "set_na"</code>: 시나리오 1용</li>
<li><code>type = "stop"</code>: 시나리오 2용</li>
</ul>
<div id="시나리오-1-데이터-프로파일링을-위한-이상치-준비" class="section level4 hasAnchor" number="2.4.7.1">
<h4><span class="header-section-number">2.4.7.1</span> 시나리오 1: 데이터 프로파일링을 위한 이상치 준비<a href="data_preparation.html#시나리오-1-데이터-프로파일링을-위한-이상치-준비" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><strong>초기 분석:</strong></p>
<p>이 경우 모든 이상치는 <code>NA</code>로 변환되므로, 대부분의 특징 함수(max, min, mean 등)를 적용하면 <strong>편향이 적은 지표</strong> 값을 반환하게 됩니다. 이러한 함수들을 사용할 때는 <code>na.rm=TRUE</code> 매개변수를 설정해야 함을 잊지 마세요. 그렇지 않으면 결과는 <code>NA</code>가 될 것입니다.</p>
<p>예를 들어, 다음 변수(처음에 본 것처럼 이상치가 있는 변수)를 생각해 봅시다.</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb191-1"><a href="data_preparation.html#cb191-1" tabindex="-1"></a><span class="co"># 이 모든 지표를 이해하려면 &#39;데이터 프로파일링&#39; 장을 참조하세요.</span></span>
<span id="cb191-2"><a href="data_preparation.html#cb191-2" tabindex="-1"></a><span class="fu">profiling_num</span>(df_1<span class="sc">$</span>var)</span></code></pre></div>
<pre><code>##   variable   mean  std_dev variation_coef p_01 p_05 p_25 p_50  p_75   p_95
## 1      var 548.05 1225.897       2.236834    0    0    0   24 369.5 3382.1
##      p_99 skewness kurtosis   iqr     range_98    range_80
## 1 5467.33 3.318769 15.64297 369.5 [0, 5467.33] [0, 1791.1]</code></pre>
<p>여기서 몇 가지 단서를 주는 지표들을 볼 수 있습니다. <code>std_dev</code>가 <code>mean</code>에 비해 매우 높으며, 이는 <code>variation_coef</code>에 반영됩니다. 또한 첨도(kurtosis)가 높고(16), <code>p_99</code> 값이 <code>p_95</code> 값의 거의 두 배입니다(5467 vs 3382).</p>
<p><em>숫자를 보고 변수 분포를 시각화하는 이 마지막 작업은 다른 사람이 해주는 말을 듣고 그림을 상상하는 것과 같습니다. 우리는 목소리(신호)를 우리 뇌 속의 이미지로 변환합니다.</em> 🗣️ 🙄 … =&gt; 🏔️</p>
<div id="데이터-프로파일링을-위해-prep_outliers-사용하기" class="section level5 hasAnchor" number="2.4.7.1.1">
<h5><span class="header-section-number">2.4.7.1.1</span> 데이터 프로파일링을 위해 <code>prep_outliers</code> 사용하기<a href="data_preparation.html#데이터-프로파일링을-위해-prep_outliers-사용하기" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p><code>type="set_na"</code>로 설정해야 합니다. 이는 이상치로 표시된 모든 점이 <code>NA</code>로 변환됨을 의미합니다.</p>
<p>Tukey, Hampel, 그리고 하위/상위 X%의 세 가지 방법을 사용해 보겠습니다.</p>
<p><strong>Tukey 방법 사용</strong>:</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb193-1"><a href="data_preparation.html#cb193-1" tabindex="-1"></a>df_1<span class="sc">$</span>var_tukey<span class="ot">=</span><span class="fu">prep_outliers</span>(df_1<span class="sc">$</span>var, <span class="at">type =</span> <span class="st">&quot;set_na&quot;</span>, <span class="at">method =</span> <span class="st">&quot;tukey&quot;</span>)</span></code></pre></div>
<p>이제 처리 전(원본 변수)과 Tukey 기반 변환 후의 <code>NA</code> 값 개수를 확인해 봅니다.</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb194-1"><a href="data_preparation.html#cb194-1" tabindex="-1"></a><span class="co"># 처리 전</span></span>
<span id="cb194-2"><a href="data_preparation.html#cb194-2" tabindex="-1"></a><span class="fu">df_status</span>(df_1<span class="sc">$</span>var) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable, q_na, p_na)</span></code></pre></div>
<pre><code>##   variable q_zeros p_zeros q_na p_na q_inf p_inf    type unique
## 1      var     282    28.2    0    0     0     0 numeric    433</code></pre>
<pre><code>##   variable q_na p_na
## 1      var    0    0</code></pre>
<div class="sourceCode" id="cb197"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb197-1"><a href="data_preparation.html#cb197-1" tabindex="-1"></a><span class="co"># 처리 후</span></span>
<span id="cb197-2"><a href="data_preparation.html#cb197-2" tabindex="-1"></a><span class="fu">df_status</span>(df_1<span class="sc">$</span>var_tukey) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable, q_na, p_na)</span></code></pre></div>
<pre><code>##   variable q_zeros p_zeros q_na p_na q_inf p_inf    type unique
## 1      var     282    28.2  120   12     0     0 numeric    314</code></pre>
<pre><code>##   variable q_na p_na
## 1      var  120   12</code></pre>
<p>변환 전에는 0개의 <code>NA</code> 값이 있었으나, 변환 후에는 Tukey 테스트에 따라 120개의 값(약 12%)이 이상치로 판명되어 <code>NA</code>로 대체되었습니다.</p>
<p>전후 비교를 해볼 수 있습니다.</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb200-1"><a href="data_preparation.html#cb200-1" tabindex="-1"></a><span class="fu">profiling_num</span>(df_1) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable, mean, std_dev, variation_coef, kurtosis, range_98)</span></code></pre></div>
<pre><code>##    variable     mean   std_dev variation_coef  kurtosis     range_98
## 1       var 548.0500 1225.8967       2.236834 15.642970 [0, 5467.33]
## 2 var_tukey 163.1739  306.9419       1.881073  8.420102 [0, 1358.46]</code></pre>
<p>평균이 거의 3분의 1로 줄어들었으며 다른 모든 지표들도 감소했습니다.</p>
<p><strong>Hampel 방법</strong>:</p>
<p>Hampel 방법(<code>method="hampel"</code>)을 사용하면 어떻게 되는지 봅시다.</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb202-1"><a href="data_preparation.html#cb202-1" tabindex="-1"></a>df_1<span class="sc">$</span>var_hampel<span class="ot">=</span><span class="fu">prep_outliers</span>(df_1<span class="sc">$</span>var, <span class="at">type =</span> <span class="st">&quot;set_na&quot;</span>, <span class="at">method=</span><span class="st">&quot;hampel&quot;</span>)</span></code></pre></div>
<p>확인 중…</p>
<div class="sourceCode" id="cb203"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb203-1"><a href="data_preparation.html#cb203-1" tabindex="-1"></a><span class="fu">df_status</span>(df_1) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable, q_na, p_na)</span></code></pre></div>
<pre><code>##     variable q_zeros p_zeros q_na p_na q_inf p_inf    type unique
## 1        var     282    28.2    0    0     0     0 numeric    433
## 2  var_tukey     282    28.2  120   12     0     0 numeric    314
## 3 var_hampel     282    28.2    0    0     0     0 numeric    433</code></pre>
<pre><code>##     variable q_na p_na
## 1        var    0    0
## 2  var_tukey  120   12
## 3 var_hampel    0    0</code></pre>
<p>마지막 방법은 이상치를 잡아내는 데 훨씬 더 가혹하여 36%의 값을 이상치로 식별했습니다. 이는 아마도 변수가 왼쪽으로 <em>상당히</em> 치우쳐 있기 때문일 것입니다.</p>
<p><strong>상하위 X% 방법</strong></p>
<p>마지막으로, 가장 쉬운 방법인 상위 2%를 제거하는 방법을 시도해 볼 수 있습니다.</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb206-1"><a href="data_preparation.html#cb206-1" tabindex="-1"></a>df_1<span class="sc">$</span>var_top2<span class="ot">=</span><span class="fu">prep_outliers</span>(df_1<span class="sc">$</span>var, <span class="at">type =</span> <span class="st">&quot;set_na&quot;</span>, <span class="at">method=</span><span class="st">&quot;bottom_top&quot;</span>, <span class="at">top_percent =</span> <span class="fl">0.02</span>)</span></code></pre></div>
<p>2%라는 값은 임의로 선택된 것임을 유의하세요. 3%나 0.5%와 같은 다른 값들도 시도해 볼 수 있습니다.</p>
<p>이제 모든 방법을 비교해 볼 시간입니다!</p>
</div>
<div id="모든-결과-종합하기" class="section level5 hasAnchor" number="2.4.7.1.2">
<h5><span class="header-section-number">2.4.7.1.2</span> 모든 결과 종합하기<a href="data_preparation.html#모든-결과-종합하기" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>정량적 비교를 위해 몇 가지 지표를 선택하겠습니다.</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb207-1"><a href="data_preparation.html#cb207-1" tabindex="-1"></a><span class="fu">df_status</span>(df_1) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable, q_na, p_na)</span></code></pre></div>
<pre><code>##     variable q_zeros p_zeros q_na p_na q_inf p_inf    type unique
## 1        var     282    28.2    0    0     0     0 numeric    433
## 2  var_tukey     282    28.2  120   12     0     0 numeric    314
## 3 var_hampel     282    28.2    0    0     0     0 numeric    433
## 4   var_top2     282    28.2   20    2     0     0 numeric    413</code></pre>
<pre><code>##     variable q_na p_na
## 1        var    0    0
## 2  var_tukey  120   12
## 3 var_hampel    0    0
## 4   var_top2   20    2</code></pre>
<div class="sourceCode" id="cb210"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb210-1"><a href="data_preparation.html#cb210-1" tabindex="-1"></a>prof_num<span class="ot">=</span><span class="fu">profiling_num</span>(df_1) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable, mean, std_dev, variation_coef, kurtosis, range_98)</span>
<span id="cb210-2"><a href="data_preparation.html#cb210-2" tabindex="-1"></a>prof_num</span></code></pre></div>
<pre><code>##     variable     mean   std_dev variation_coef  kurtosis     range_98
## 1        var 548.0500 1225.8967       2.236834 15.642970 [0, 5467.33]
## 2  var_tukey 163.1739  306.9419       1.881073  8.420102 [0, 1358.46]
## 3 var_hampel 548.0500 1225.8967       2.236834 15.642970 [0, 5467.33]
## 4   var_top2 432.1296  907.9950       2.101210 10.899963 [0, 4364.29]</code></pre>
<p><strong>플롯팅</strong></p>
<div class="sourceCode" id="cb212"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb212-1"><a href="data_preparation.html#cb212-1" tabindex="-1"></a><span class="co"># 먼저 데이터셋을 긴 형식(long format)으로 변환해야 합니다.</span></span>
<span id="cb212-2"><a href="data_preparation.html#cb212-2" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb212-3"><a href="data_preparation.html#cb212-3" tabindex="-1"></a>df_1_m<span class="ot">=</span>df_1 <span class="sc">%&gt;%</span> <span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="fu">everything</span>(), <span class="at">names_to =</span> <span class="st">&quot;variable&quot;</span>, <span class="at">values_to =</span> <span class="st">&quot;value&quot;</span>) </span>
<span id="cb212-4"><a href="data_preparation.html#cb212-4" tabindex="-1"></a><span class="fu">plotar</span>(df_1_m,  <span class="at">target=</span> <span class="st">&quot;variable&quot;</span>, <span class="at">input =</span> <span class="st">&quot;value&quot;</span>, <span class="at">plot_type =</span> <span class="st">&quot;boxplot&quot;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:comparing-outliers-methods"></span>
<img src="02_data_preparation_files/figure-html/comparing-outliers-methods-1.png" alt="이상치 처리 방법 비교" width="672"  />
<p class="caption">
Figure 2.25: 이상치 처리 방법 비교
</p>
</div>
<p>하위/상위 X%를 선택할 때, 우리는 항상 해당 조건에 맞는 일부 값을 갖게 되는 반면, 다른 방법들에서는 그렇지 않을 수도 있습니다.</p>
</div>
<div id="데이터-프로파일링에서의-이상치-처리에-대한-결론" class="section level5 hasAnchor" number="2.4.7.1.3">
<h5><span class="header-section-number">2.4.7.1.3</span> 데이터 프로파일링에서의 이상치 처리에 대한 결론<a href="data_preparation.html#데이터-프로파일링에서의-이상치-처리에-대한-결론" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>이상치를 가능한 한 적게 수정하는 것이 아이디어입니다 (예를 들어, 일반적인 행동을 설명하는 데만 관심이 있는 경우).</p>
<p>이 작업을 수행하기 위해(예: 임시 보고서를 작성할 때), 우리는 평균을 사용할 수 있습니다. 상위 2% 방법을 선택할 수 있는데, 이는 모든 값의 2%에만 영향을 미치면서 평균을 548에서 432로, 즉 <strong>21%나</strong> 극적으로 낮추기 때문입니다.</p>
<blockquote>
<p>“데이터셋을 수정하느냐 마느냐, 그것이 문제로다”. 데이터 과학자가 된 윌리엄 셰익스피어.</p>
</blockquote>
<p>Hampel 방법은 평균을 548에서 17로 너무 많이 수정했습니다! 이는 이 방법에서 고려되는 <em>표준</em> 값인 3-MAD(성능이 좋은 표준 편차의 일종)를 기반으로 합니다.</p>
<p>이 시연이 Hampel이나 Tukey가 나쁜 선택이라는 것을 의미하지는 않습니다. 사실, 그들은 임계값이 현재 값보다 높을 수 있기 때문에 더 견고합니다. 실제로 어떤 값도 이상치로 처리되지 않을 수도 있습니다.</p>
<p>다른 극단적인 예로, <code>heart_disease</code> 데이터의 <code>age</code> 변수를 고려해 볼 수 있습니다. 이상치를 분석해 봅시다.</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb213-1"><a href="data_preparation.html#cb213-1" tabindex="-1"></a><span class="co"># 이상치 임계값 가져오기</span></span>
<span id="cb213-2"><a href="data_preparation.html#cb213-2" tabindex="-1"></a><span class="fu">tukey_outlier</span>(heart_disease<span class="sc">$</span>age)</span></code></pre></div>
<pre><code>## bottom_threshold    top_threshold 
##                9              100</code></pre>
<div class="sourceCode" id="cb215"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb215-1"><a href="data_preparation.html#cb215-1" tabindex="-1"></a><span class="co"># 최소값 및 최대값 가져오기</span></span>
<span id="cb215-2"><a href="data_preparation.html#cb215-2" tabindex="-1"></a><span class="fu">min</span>(heart_disease<span class="sc">$</span>age)</span></code></pre></div>
<pre><code>## [1] 29</code></pre>
<div class="sourceCode" id="cb217"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb217-1"><a href="data_preparation.html#cb217-1" tabindex="-1"></a><span class="fu">max</span>(heart_disease<span class="sc">$</span>age)</span></code></pre></div>
<pre><code>## [1] 77</code></pre>
<ul>
<li>하한 임계값은 9이고 최대값은 29입니다.</li>
<li>상한 임계값은 100이고 최대값은 77입니다.</li>
</ul>
<p>결론: <code>age</code> 변수에는 이상치가 없습니다.</p>
<p>만약 하위/상위 방법을 사용했다면, 입력된 백분율만큼 이상치가 감지되었을 것입니다.</p>
<p>지금까지의 모든 예제는 한 번에 하나의 변수만 다루었지만, <code>prep_outliers</code>는 다음 섹션에서 보게 될 <code>input</code> 매개변수를 사용하여 동시에 여러 변수를 처리할 수 있습니다. 여기서 본 모든 것들은 이상치를 감지한 후 수행하는 작업, 즉 결측치 보정(imputation) 방법을 제외하고는 동일할 것입니다.</p>
</div>
</div>
<div id="시나리오-2-예측-모델링을-위한-이상치-준비" class="section level4 hasAnchor" number="2.4.7.2">
<h4><span class="header-section-number">2.4.7.2</span> 시나리오 2: 예측 모델링을 위한 이상치 준비<a href="data_preparation.html#시나리오-2-예측-모델링을-위한-이상치-준비" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>이전 사례에서는 감지된 이상치가 <code>NA</code> 값으로 변환되었습니다. 머신러닝 모델을 구축할 때 많은 모델이 <code>NA</code> 값을 처리하지 못하기 때문에 이는 큰 문제가 됩니다. 결측 데이터 처리에 대한 자세한 내용은 <a href="data_preparation.html#missing_data">결측 데이터의 분석, 처리 및 대치</a> 부문에서 다룹니다.</p>
<p>예측 모델을 사용하기 위해 이상치를 처리하려면, <code>type='stop'</code> 매개변수를 조정하여 이상치로 표시된 모든 값을 임계값으로 변환할 수 있습니다.</p>
<p><strong>명심해야 할 몇 가지 사항:</strong></p>
<p>변수 처리(및 생성)에 대해 모델에게 설명한다고 생각해 보세요. 특정 값(예: 1%)에서 변수를 멈추게 함으로써 우리는 모델에게 이렇게 말하고 있는 것입니다: <em>“어이 모델, 모든 극단값을 99번째 백분위수 값인 것처럼 간주해줘요. 그 값만으로도 충분히 높으니까요. 고마워요.”</em></p>
<p>일부 예측 모델은 다른 모델보다 <strong>노이즈에 더 관대합니다(noise tolerant)</strong>. 우리는 일부 이상치 값을 처리함으로써 그들을 도울 수 있습니다. 실제로 이상치를 처리하여 데이터를 전처리하면 보지 못한 데이터에 대해 더 정확한 결과를 얻는 경향이 있습니다.</p>
</div>
<div id="예측-모델링을-위한-이상치-대치-imputing-outliers-for-predictive-modeling" class="section level4 hasAnchor" number="2.4.7.3">
<h4><span class="header-section-number">2.4.7.3</span> 예측 모델링을 위한 이상치 대치 (Imputing outliers for predictive modeling)<a href="data_preparation.html#예측-모델링을-위한-이상치-대치-imputing-outliers-for-predictive-modeling" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>먼저 몇 가지 이상치가 포함된 데이터셋을 만듭니다. 이번 예제는 두 개의 변수를 가집니다.</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb219-1"><a href="data_preparation.html#cb219-1" tabindex="-1"></a><span class="co"># 이상치가 포함된 데이터 프레임 생성</span></span>
<span id="cb219-2"><a href="data_preparation.html#cb219-2" tabindex="-1"></a></span>
<span id="cb219-3"><a href="data_preparation.html#cb219-3" tabindex="-1"></a><span class="co"># 과학적 표기법 비활성화</span></span>
<span id="cb219-4"><a href="data_preparation.html#cb219-4" tabindex="-1"></a><span class="fu">options</span>(<span class="at">scipen=</span><span class="dv">999</span>) </span>
<span id="cb219-5"><a href="data_preparation.html#cb219-5" tabindex="-1"></a><span class="co"># 재현 가능한 예제를 위해 시드 설정</span></span>
<span id="cb219-6"><a href="data_preparation.html#cb219-6" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">10</span>) </span>
<span id="cb219-7"><a href="data_preparation.html#cb219-7" tabindex="-1"></a><span class="co"># 변수 생성</span></span>
<span id="cb219-8"><a href="data_preparation.html#cb219-8" tabindex="-1"></a>df_2<span class="ot">=</span><span class="fu">data.frame</span>(<span class="at">var1=</span><span class="fu">rchisq</span>(<span class="dv">1000</span>,<span class="at">df =</span> <span class="dv">1</span>), <span class="at">var2=</span><span class="fu">rnorm</span>(<span class="dv">1000</span>)) </span>
<span id="cb219-9"><a href="data_preparation.html#cb219-9" tabindex="-1"></a><span class="co"># 이상치 강제 삽입</span></span>
<span id="cb219-10"><a href="data_preparation.html#cb219-10" tabindex="-1"></a>df_2<span class="ot">=</span><span class="fu">rbind</span>(df_2, <span class="dv">135</span>, <span class="fu">rep</span>(<span class="dv">400</span>, <span class="dv">30</span>), <span class="dv">245</span>, <span class="dv">300</span>, <span class="dv">303</span>, <span class="dv">200</span>) </span></code></pre></div>
<pre><code>## Warning in rbind(deparse.level, ...): number of columns of result, 2, is not a
## multiple of vector length 30 of arg 3</code></pre>
<p>Tukey 방법을 사용하여 두 변수(<code>var1</code> 및 <code>var2</code>)의 이상치를 처리합니다.</p>
<div class="sourceCode" id="cb221"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb221-1"><a href="data_preparation.html#cb221-1" tabindex="-1"></a>df_2_tukey<span class="ot">=</span><span class="fu">prep_outliers</span>(<span class="at">data =</span> df_2, <span class="at">input =</span> <span class="fu">c</span>(<span class="st">&quot;var1&quot;</span>, <span class="st">&quot;var2&quot;</span>), <span class="at">type=</span><span class="st">&#39;stop&#39;</span>, <span class="at">method =</span> <span class="st">&quot;tukey&quot;</span>)</span></code></pre></div>
<p>대치 전후의 몇 가지 지표를 확인해 봅니다.</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb222-1"><a href="data_preparation.html#cb222-1" tabindex="-1"></a><span class="fu">profiling_num</span>(df_2) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable, mean, std_dev, variation_coef)</span></code></pre></div>
<pre><code>##   variable     mean  std_dev variation_coef
## 1     var1 2.576244 21.30958       8.271572
## 2     var2 1.564929 21.35997      13.649165</code></pre>
<div class="sourceCode" id="cb224"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb224-1"><a href="data_preparation.html#cb224-1" tabindex="-1"></a><span class="fu">profiling_num</span>(df_2_tukey) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable, mean, std_dev, variation_coef)</span></code></pre></div>
<pre><code>##   variable       mean  std_dev variation_coef
## 1     var1 0.99661240 1.279287       1.283636
## 2     var2 0.01778014 1.022919      57.531538</code></pre>
<p>Tukey 방법이 이번에는 완벽하게 작동하여 두 변수 모두에서 더 정확한 평균(<code>var1</code>은 1, <code>var2</code>는 0)을 보여주었습니다.</p>
<p>이번에는 <code>NA</code> 값이 하나도 없다는 점에 유의하세요. 함수가 수행한 작업은 임계값에서 <strong>“변수를 멈추게 한”</strong> 것입니다. 이제 최소값과 최대값은 Tukey 방법이 보고한 값과 동일해질 것입니다.</p>
<p><code>var1</code>에 대한 임계값을 확인해 봅시다.</p>
<div class="sourceCode" id="cb226"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb226-1"><a href="data_preparation.html#cb226-1" tabindex="-1"></a><span class="fu">tukey_outlier</span>(df_2<span class="sc">$</span>var1)</span></code></pre></div>
<pre><code>## bottom_threshold    top_threshold 
##        -3.827106         5.335640</code></pre>
<p>이제 변환 전의 최소/최대값을 확인합니다.</p>
<div class="sourceCode" id="cb228"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb228-1"><a href="data_preparation.html#cb228-1" tabindex="-1"></a><span class="co"># 변환 전</span></span>
<span id="cb228-2"><a href="data_preparation.html#cb228-2" tabindex="-1"></a><span class="fu">min</span>(df_2<span class="sc">$</span>var1)</span></code></pre></div>
<pre><code>## [1] 0.000003068548</code></pre>
<div class="sourceCode" id="cb230"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb230-1"><a href="data_preparation.html#cb230-1" tabindex="-1"></a><span class="fu">max</span>(df_2<span class="sc">$</span>var1)</span></code></pre></div>
<pre><code>## [1] 400</code></pre>
<p>그리고 변환 후의 결과입니다.</p>
<div class="sourceCode" id="cb232"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb232-1"><a href="data_preparation.html#cb232-1" tabindex="-1"></a><span class="co"># 변환 후</span></span>
<span id="cb232-2"><a href="data_preparation.html#cb232-2" tabindex="-1"></a><span class="fu">min</span>(df_2_tukey<span class="sc">$</span>var1)</span></code></pre></div>
<pre><code>## [1] 0.000003068548</code></pre>
<div class="sourceCode" id="cb234"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb234-1"><a href="data_preparation.html#cb234-1" tabindex="-1"></a><span class="fu">max</span>(df_2_tukey<span class="sc">$</span>var1)</span></code></pre></div>
<pre><code>## [1] 5.33564</code></pre>
<p>최소값은 동일하게 유지되지만(0.0000031), 최대값은 Tukey의 값인 약 5.3으로 설정되었습니다.</p>
<p>데이터 전처리 전 상위 5개 값은 다음과 같았습니다.</p>
<div class="sourceCode" id="cb236"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb236-1"><a href="data_preparation.html#cb236-1" tabindex="-1"></a><span class="co"># 전처리 전</span></span>
<span id="cb236-2"><a href="data_preparation.html#cb236-2" tabindex="-1"></a><span class="fu">tail</span>(df_2<span class="sc">$</span>var1[<span class="fu">order</span>(df_2<span class="sc">$</span>var1)], <span class="dv">5</span>)</span></code></pre></div>
<pre><code>## [1] 200 245 300 303 400</code></pre>
<p>하지만 전처리 후에는 다음과 같습니다.</p>
<div class="sourceCode" id="cb238"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb238-1"><a href="data_preparation.html#cb238-1" tabindex="-1"></a><span class="co"># 전처리 후</span></span>
<span id="cb238-2"><a href="data_preparation.html#cb238-2" tabindex="-1"></a><span class="fu">tail</span>(df_2_tukey<span class="sc">$</span>var1[<span class="fu">order</span>(df_2_tukey<span class="sc">$</span>var1)], <span class="dv">5</span>)</span></code></pre></div>
<pre><code>## [1] 5.33564 5.33564 5.33564 5.33564 5.33564</code></pre>
<p>그리고 <code>NA</code>가 하나도 없는지 확인합니다.</p>
<div class="sourceCode" id="cb240"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb240-1"><a href="data_preparation.html#cb240-1" tabindex="-1"></a><span class="fu">df_status</span>(df_2_tukey, <span class="at">print_results =</span> F) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable, q_na, p_na)</span></code></pre></div>
<pre><code>##   variable q_na p_na
## 1     var1    0    0
## 2     var2    0    0</code></pre>
<p>아주 명확하죠?</p>
<p>이제 세 가지 방법을 모두 비교하기 위해 지난 섹션에서 하나의 변수만으로 했던 예제를 재현해 보겠습니다.</p>
<div class="sourceCode" id="cb242"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb242-1"><a href="data_preparation.html#cb242-1" tabindex="-1"></a>df_2<span class="sc">$</span>tukey_var2<span class="ot">=</span><span class="fu">prep_outliers</span>(<span class="at">data=</span>df_2<span class="sc">$</span>var2, <span class="at">type=</span><span class="st">&#39;stop&#39;</span>, <span class="at">method =</span> <span class="st">&quot;tukey&quot;</span>)</span>
<span id="cb242-2"><a href="data_preparation.html#cb242-2" tabindex="-1"></a>df_2<span class="sc">$</span>hampel_var2<span class="ot">=</span><span class="fu">prep_outliers</span>(<span class="at">data=</span>df_2<span class="sc">$</span>var2, <span class="at">type=</span><span class="st">&#39;stop&#39;</span>, <span class="at">method =</span> <span class="st">&quot;hampel&quot;</span>)</span>
<span id="cb242-3"><a href="data_preparation.html#cb242-3" tabindex="-1"></a>df_2<span class="sc">$</span>bot_top_var2<span class="ot">=</span><span class="fu">prep_outliers</span>(<span class="at">data=</span>df_2<span class="sc">$</span>var2, <span class="at">type=</span><span class="st">&#39;stop&#39;</span>, <span class="at">method =</span> <span class="st">&quot;bottom_top&quot;</span>, <span class="at">bottom_percent=</span><span class="fl">0.01</span>, <span class="at">top_percent =</span> <span class="fl">0.01</span>)</span></code></pre></div>
<div id="모든-결과-종합하기-1" class="section level5 hasAnchor" number="2.4.7.3.1">
<h5><span class="header-section-number">2.4.7.3.1</span> 모든 결과 종합하기<a href="data_preparation.html#모든-결과-종합하기-1" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<div class="sourceCode" id="cb243"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb243-1"><a href="data_preparation.html#cb243-1" tabindex="-1"></a><span class="co"># var1 제외</span></span>
<span id="cb243-2"><a href="data_preparation.html#cb243-2" tabindex="-1"></a>df_2_b <span class="ot">=</span> df_2 <span class="sc">%&gt;%</span> <span class="fu">select</span>(<span class="sc">-</span>var1)</span>
<span id="cb243-3"><a href="data_preparation.html#cb243-3" tabindex="-1"></a></span>
<span id="cb243-4"><a href="data_preparation.html#cb243-4" tabindex="-1"></a><span class="co"># 프로파일링</span></span>
<span id="cb243-5"><a href="data_preparation.html#cb243-5" tabindex="-1"></a><span class="fu">profiling_num</span>(df_2_b) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable, mean, std_dev, variation_coef, kurtosis, range_98)</span></code></pre></div>
<pre><code>##       variable        mean    std_dev variation_coef   kurtosis
## 1         var2 1.564928693 21.3599702       13.64917 223.782444
## 2   tukey_var2 0.017780140  1.0229188       57.53154   4.599013
## 3  hampel_var2 1.564928693 21.3599702       13.64917 223.782444
## 4 bot_top_var2 0.008304143  0.9658194      116.30573   2.892427
##                                range_98
## 1  [-2.3214287729478, 2.40295403887707]
## 2  [-2.3214287729478, 2.40295403887707]
## 3  [-2.3214287729478, 2.40295403887707]
## 4 [-2.31978075701941, 2.40232419716027]</code></pre>
<p>세 가지 방법 모두 이 데이터에서 매우 유사한 결과를 보여줍니다.</p>
<p><strong>플롯팅</strong></p>
<div class="sourceCode" id="cb245"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb245-1"><a href="data_preparation.html#cb245-1" tabindex="-1"></a><span class="co"># 먼저 데이터셋을 긴 형식(long format)으로 변환합니다.</span></span>
<span id="cb245-2"><a href="data_preparation.html#cb245-2" tabindex="-1"></a>df_2_m<span class="ot">=</span>df_2_b <span class="sc">%&gt;%</span> <span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="fu">everything</span>(), <span class="at">names_to =</span> <span class="st">&quot;variable&quot;</span>, <span class="at">values_to =</span> <span class="st">&quot;value&quot;</span>) <span class="sc">%&gt;%</span> <span class="fu">filter</span>(value<span class="sc">&lt;</span><span class="dv">100</span>) </span>
<span id="cb245-3"><a href="data_preparation.html#cb245-3" tabindex="-1"></a><span class="fu">plotar</span>(df_2_m,  <span class="at">target=</span> <span class="st">&quot;variable&quot;</span>, <span class="at">input =</span> <span class="st">&quot;value&quot;</span>, <span class="at">plot_type =</span> <span class="st">&quot;boxplot&quot;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:outliers-method-comparison"></span>
<img src="02_data_preparation_files/figure-html/outliers-method-comparison-1.png" alt="이상치 처리 방법 비교" width="672"  />
<p class="caption">
Figure 2.26: 이상치 처리 방법 비교
</p>
</div>
<p><em>중요</em>: 100 이상의 두 점(<code>var1</code>에만 해당)은 제외되었습니다. 그렇지 않으면 각 방법 사이의 차이를 인식하는 것이 불가능했습니다.</p>
</div>
</div>
</div>
<div id="최종-생각-3" class="section level3 hasAnchor" number="2.4.8">
<h3><span class="header-section-number">2.4.8</span> 최종 생각<a href="data_preparation.html#최종-생각-3" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>우리는 철학적 및 기술적 관점 모두에서 이상치 문제를 다루었으며, 이를 통해 임계값을 정할 때 독자가 비판적 사고 능력을 키울 수 있도록 권유했습니다. 극단에 서는 것은 쉽지만, 균형을 찾는 것은 어려운 작업입니다.</p>
<p>기술적인 면에서 우리는 근거가 다른 세 가지 이상치 탐지 방법을 다루었습니다.</p>
<ul>
<li><strong>하위/상위 X%</strong>: 항상 하위와 상위 X%가 존재하기 때문에 항상 점들을 이상치로 탐지합니다.</li>
<li><strong>Tukey</strong>: 사분위수를 사용하는 고전적인 박스 플롯을 기반으로 합니다.</li>
<li><strong>Hampel</strong>: 기본 매개변수를 변경하지 않으면 매우 엄격합니다. 중앙값과 MAD 값(표준 편차와 유사하지만 이상치에 덜 민감함)을 기반으로 합니다.</li>
</ul>
<p>이상치를 확보한 후 다음 단계는 이상치를 어떻게 할지 결정하는 것입니다. 처리가 전혀 필요하지 않은 경우일 수도 있습니다. 아주 작은 데이터셋에서는 한눈에 볼 수도 있습니다.</p>
<p><em><strong>“꼭 필요한 것만 수정하라”</strong></em>(인간과 자연의 관계에도 적용될 수 있음)는 규칙은 모든 극단적인 이상치를 맹목적으로 처리하거나 제외하지 말라고 알려줍니다. <strong>우리가 취하는 모든 조치에는 약간의 편향이 도입됩니다</strong>. 그렇기 때문에 각 방법의 함의를 아는 것이 매우 중요합니다. 좋은 결정인지 아닌지는 분석 중인 데이터의 성격에 달려 있습니다.</p>
<p><strong>예측 모델링</strong>에서, 내부 재샘플링 기법을 가지고 있거나 최종 예측을 위해 _여러 개의 작은 모델들_을 만드는 모델들은 극단값에 더 안정적입니다. 재샘플링과 오차에 대한 자세한 내용은 <a href="model-performance.html#knowing_the_error">오차 알기</a> 장에서 다룹니다.</p>
<p>일부 경우에는 예측 모델이 <strong>운영 환경에서 실행 중</strong>일 때, 모델 구축 중에 존재하지 않았던 새로운 극단값의 준비를 보고하거나 고려하는 것이 권장됩니다. 범주형 변수와 관련된 이 주제에 대한 자세한 내용은 <a href="data_preparation.html#high_cardinality_predictive_modeling">예측 모델링에서의 고카디널리티 변수</a> 장의 <em>예측 모델이 운영 환경에 있을 때 새로운 카디널리티 처리하기</em> 섹션에서 찾을 수 있습니다.</p>
<p>독자가 직접 해볼 수 있는 <strong>좋은 테스트</strong>는 데이터셋을 가져와서 이상치를 처리한 다음 Kappa, ROC, 정확도 등과 같은 몇 가지 성능 지표를 비교해 보는 것입니다. <strong>데이터 준비가 이 중 하나라도 개선했나요?</strong> 또는 보고 시에 평균이 얼마나 변했는지 확인해 보세요. 어떤 변수를 플롯팅했을 때 이제 그 플롯이 우리에게 무언가를 말해 주나요? 이런 방식으로 독자는 자신의 경험을 바탕으로 새로운 지식을 창조하게 될 것입니다 😉.</p>
<p><img src="introduction/spacer_bar.png" /><!-- --></p>
</div>
</div>
<div id="missing_data" class="section level2 hasAnchor" number="2.5">
<h2><span class="header-section-number">2.5</span> 결측 데이터: 분석, 처리 및 대치<a href="data_preparation.html#missing_data" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="무엇에-대한-내용인가요-4" class="section level3 hasAnchor" number="2.5.1">
<h3><span class="header-section-number">2.5.1</span> 무엇에 대한 내용인가요?<a href="data_preparation.html#무엇에-대한-내용인가요-4" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>결측값 분석은 비어있음 그 자체에 대한 추정입니다. 결측값은 예측 모델 생성, 클러스터 분석, 보고서 작성 등에 장애물이 됩니다.</p>
<p>이 장에서는 빈 값의 개념과 처리에 대해 논의합니다. 우리는 다양한 접근 방식을 사용하여 분석을 수행하고 다양한 결과들을 해석할 것입니다.</p>
<p>이 장을 공부한 후 독자가 결측값을 처리하는 핵심 개념을 이해하고 여기서 제안된 것보다 더 나은 접근 방식을 추구할 수 있기를 바랍니다.</p>
<p><strong>이 장에서 무엇을 검토할까요?</strong></p>
<ul>
<li>빈 값의 개념은 무엇인가?</li>
<li>행이나 열을 언제 제외해야 하는가?</li>
<li>결측값의 분석 및 프로파일링.</li>
<li>수치형 및 범주형 변수의 변환 및 대치.</li>
<li>값 대치: 쉬운 방법부터 더 복잡한 접근 방식까지.</li>
</ul>
<p>이들은 R에서 실용적인 접근 방식을 사용하여 예시될 것입니다. 코드는 여러분의 프로젝트에 적용할 수 있을 만큼 범용적일 것입니다 🙂.</p>
</div>
<div id="빈-값이-정보를-나타낼-때" class="section level3 hasAnchor" number="2.5.2">
<h3><span class="header-section-number">2.5.2</span> 빈 값이 정보를 나타낼 때<a href="data_preparation.html#빈-값이-정보를-나타낼-때" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>빈 값은 데이터베이스에서 “NULL”, R에서 <code>NA</code>, 또는 스프레드시트 프로그램에서 단순히 “빈” 문자열로 알려져 있습니다. 또한 <code>0</code>, <code>-1</code> 또는 <code>-999</code>와 같은 숫자로 표현될 수도 있습니다.</p>
<p>예를 들어, 사람 테이블과 국가 테이블을 결합하는 여행사를 생각해 보십시오. 결과는 한 사람당 여행 횟수를 보여줍니다.</p>
<pre><code>##    person South_Africa Brazil Costa_Rica
## 1  Fotero            1      5          5
## 2   Herno           NA     NA         NA
## 3 Mamarul           34     40         NA</code></pre>
<p>이 결과에서 <code>Mamarul</code>은 <code>South Africa</code>를 <code>34</code>번 여행했습니다.</p>
<p><em><code>NA</code>(또는 NULL) 값은 무엇을 나타내나요?</em></p>
<p>이 경우 NA는 해당 사람-국가 교차점에서 여행 횟수가 0임을 나타내는 0으로 대체되어야 합니다. 변환 후 테이블은 바로 사용할 준비가 됩니다.</p>
<p><strong>예시: 모든 NA 값을 0으로 대체</strong></p>
<div class="sourceCode" id="cb247"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb247-1"><a href="data_preparation.html#cb247-1" tabindex="-1"></a><span class="co"># 복사본 만들기</span></span>
<span id="cb247-2"><a href="data_preparation.html#cb247-2" tabindex="-1"></a>df_travel_2<span class="ot">=</span>df_travel</span>
<span id="cb247-3"><a href="data_preparation.html#cb247-3" tabindex="-1"></a>  </span>
<span id="cb247-4"><a href="data_preparation.html#cb247-4" tabindex="-1"></a><span class="co"># 모든 NA 값을 0으로 대체</span></span>
<span id="cb247-5"><a href="data_preparation.html#cb247-5" tabindex="-1"></a>df_travel_2[<span class="fu">is.na</span>(df_travel_2)] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb247-6"><a href="data_preparation.html#cb247-6" tabindex="-1"></a>df_travel_2</span></code></pre></div>
<pre><code>##    person South_Africa Brazil Costa_Rica
## 1  Fotero            1      5          5
## 2   Herno            0      0          0
## 3 Mamarul           34     40          0</code></pre>
<p>마지막 예제는 <strong>모든</strong> <code>NA</code> 값을 <code>0</code>으로 변환합니다. 그러나 다른 시나리오에서는 이 변환이 모든 열에 적용되지 않을 수도 있습니다.</p>
<p><strong>예시: 특정 열에 대해서만 NA 값을 0으로 대체</strong></p>
<p>특정 열에 대해서만 NA를 어떤 값(이 경우 0)으로 대체하는 것이 아마도 가장 일반적인 시나리오일 것입니다. 대체할 모든 변수를 포함하는 벡터를 정의한 다음 <code>dplyr</code> 패키지의 <code>mutate</code>와 <code>across</code> 함수를 호출합니다.</p>
<div class="sourceCode" id="cb249"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb249-1"><a href="data_preparation.html#cb249-1" tabindex="-1"></a><span class="fu">library</span>(dplyr) <span class="co"># 버전 0.7.1 이상</span></span>
<span id="cb249-2"><a href="data_preparation.html#cb249-2" tabindex="-1"></a></span>
<span id="cb249-3"><a href="data_preparation.html#cb249-3" tabindex="-1"></a><span class="co"># 선택한 열에서만 NA 값을 0으로 대체</span></span>
<span id="cb249-4"><a href="data_preparation.html#cb249-4" tabindex="-1"></a>vars_to_replace<span class="ot">=</span><span class="fu">c</span>(<span class="st">&quot;Brazil&quot;</span>, <span class="st">&quot;Costa_Rica&quot;</span>)</span>
<span id="cb249-5"><a href="data_preparation.html#cb249-5" tabindex="-1"></a></span>
<span id="cb249-6"><a href="data_preparation.html#cb249-6" tabindex="-1"></a>df_travel_3 <span class="ot">=</span> df_travel <span class="sc">%&gt;%</span> </span>
<span id="cb249-7"><a href="data_preparation.html#cb249-7" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="fu">across</span>(<span class="fu">all_of</span>(vars_to_replace), <span class="sc">~</span><span class="fu">ifelse</span>(<span class="fu">is.na</span>(.), <span class="dv">0</span>, .)))</span>
<span id="cb249-8"><a href="data_preparation.html#cb249-8" tabindex="-1"></a></span>
<span id="cb249-9"><a href="data_preparation.html#cb249-9" tabindex="-1"></a>df_travel_3</span></code></pre></div>
<pre><code>##    person South_Africa Brazil Costa_Rica
## 1  Fotero            1      5          5
## 2   Herno           NA      0          0
## 3 Mamarul           34     40          0</code></pre>
<p>특정 변수 하위 집합에 지정된 함수를 적용하고 동일한 데이터셋에서 변환된 변수와 변환되지 않은 변수를 반환하는 상황은 매우 일반적이므로 마지막 함수를 잘 익혀두시기 바랍니다.</p>
<p>더 복잡한 예제로 넘어가 보겠습니다.</p>
</div>
<div id="빈-값이-진짜-빈-값일-때" class="section level3 hasAnchor" number="2.5.3">
<h3><span class="header-section-number">2.5.3</span> 빈 값이 진짜 빈 값일 때<a href="data_preparation.html#빈-값이-진짜-빈-값일-때" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>다른 경우에는 빈 값이 있는 것이 옳으며, 무언가의 부재를 표현하고 있는 것입니다. 테이블을 사용하려면 이들을 처리해야 합니다. 많은 예측 모델은 결측값이 있는 입력 테이블을 처리하지 못합니다.</p>
<p>어떤 경우에는 특정 기간 _이후_에 변수가 측정되므로, 이 시점 이후의 데이터와 그 이전의 NA 데이터를 갖게 됩니다.</p>
<p>가끔은 데이터를 수집하지 못한 기계나 양식의 특정 필드 작성을 잊어버린 사용자 등 무작위적인 경우가 있습니다.</p>
<p>한 가지 중요한 질문이 생깁니다: <em>어떻게 해야 할까요?!</em> 😱</p>
<p>다음 권장 사항은 권장 사항일 뿐입니다. 분석 중인 데이터에 가장 적합한 전략을 찾기 위해 다양한 접근 방식을 시도해 볼 수 있습니다. <strong>“모든 상황에 맞는 정답”은 없습니다</strong>.</p>
</div>
<div id="전체-행-제외하기" class="section level3 hasAnchor" number="2.5.4">
<h3><span class="header-section-number">2.5.4</span> 전체 행 제외하기<a href="data_preparation.html#전체-행-제외하기" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>최소 하나의 열에 <code>NA</code> 값이 있으면 해당 행을 제외합니다.</p>
<p>빠르고 쉬운 방법이죠? 행의 수가 <em>적을 때</em> 권장됩니다. 하지만 얼마나 적어야 적은 것일까요? 그것은 여러분에게 달려 있습니다. 수천 개의 행 중 10개의 사례는 해당 10개의 사례가 이상 징후 예측과 관련이 있지 않는 한 큰 영향을 미치지 <em>않을 수</em> 있습니다. 만약 그렇다면 그것은 정보를 나타내는 것입니다. 우리는 이 문제를 <a href="data_preparation.html#reduce_cardinality_by_re_categorizing_less_representative_values">사례 1: 대표성이 낮은 값을 재범주화하여 줄이기</a> 섹션에서 지적했습니다.</p>
<p><strong>R 예시:</strong></p>
<p>이러한 종류의 결정을 돕는 것이 주요 목표 중 하나인 <code>df_status</code> 함수를 사용하여 <code>heart_disease</code> 데이터셋을 살펴보겠습니다.</p>
<div class="sourceCode" id="cb251"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb251-1"><a href="data_preparation.html#cb251-1" tabindex="-1"></a><span class="fu">library</span>(dplyr) </span>
<span id="cb251-2"><a href="data_preparation.html#cb251-2" tabindex="-1"></a><span class="fu">library</span>(funModeling) </span>
<span id="cb251-3"><a href="data_preparation.html#cb251-3" tabindex="-1"></a><span class="fu">df_status</span>(heart_disease) <span class="sc">%&gt;%</span> <span class="fu">select</span>(variable, q_na, p_na) <span class="sc">%&gt;%</span> <span class="fu">arrange</span>(<span class="fu">desc</span>(q_na))</span></code></pre></div>
<pre><code>##                  variable q_zeros p_zeros q_na p_na q_inf p_inf    type unique
## 1                     age       0    0.00    0 0.00     0     0 integer     41
## 2                  gender       0    0.00    0 0.00     0     0  factor      2
## 3              chest_pain       0    0.00    0 0.00     0     0  factor      4
## 4  resting_blood_pressure       0    0.00    0 0.00     0     0 integer     50
## 5       serum_cholestoral       0    0.00    0 0.00     0     0 integer    152
## 6     fasting_blood_sugar     258   85.15    0 0.00     0     0  factor      2
## 7         resting_electro     151   49.83    0 0.00     0     0  factor      3
## 8          max_heart_rate       0    0.00    0 0.00     0     0 integer     91
## 9             exer_angina     204   67.33    0 0.00     0     0 integer      2
## 10                oldpeak      99   32.67    0 0.00     0     0 numeric     40
## 11                  slope       0    0.00    0 0.00     0     0 integer      3
## 12      num_vessels_flour     176   58.09    4 1.32     0     0 integer      4
## 13                   thal       0    0.00    2 0.66     0     0  factor      3
## 14 heart_disease_severity     164   54.13    0 0.00     0     0 integer      5
## 15           exter_angina     204   67.33    0 0.00     0     0  factor      2
## 16      has_heart_disease       0    0.00    0 0.00     0     0  factor      2</code></pre>
<pre><code>##                  variable q_na p_na
## 1       num_vessels_flour    4 1.32
## 2                    thal    2 0.66
## 3                     age    0 0.00
## 4                  gender    0 0.00
## 5              chest_pain    0 0.00
## 6  resting_blood_pressure    0 0.00
## 7       serum_cholestoral    0 0.00
## 8     fasting_blood_sugar    0 0.00
## 9         resting_electro    0 0.00
## 10         max_heart_rate    0 0.00
## 11            exer_angina    0 0.00
## 12                oldpeak    0 0.00
## 13                  slope    0 0.00
## 14 heart_disease_severity    0 0.00
## 15           exter_angina    0 0.00
## 16      has_heart_disease    0 0.00</code></pre>
<p><code>q_na</code>는 <code>NA</code> 값의 개수를 나타내고 <code>p_na</code>는 백분율입니다. <code>df_status</code>에 대한 전체 정보는 <a href="exploratory_data_analysis.html#profiling">프로파일링</a> 장에서 찾을 수 있습니다.</p>
<p>두 변수에 대해 <code>NA</code> 값이 있는 행이 각각 4개와 2개 있으므로, 해당 행들을 제외합니다.</p>
<div class="sourceCode" id="cb254"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb254-1"><a href="data_preparation.html#cb254-1" tabindex="-1"></a><span class="co"># na.omit는 적어도 하나의 NA 값을 포함하는 모든 행을 제외한 동일한 데이터 프레임을 반환합니다.</span></span>
<span id="cb254-2"><a href="data_preparation.html#cb254-2" tabindex="-1"></a>heart_disease_clean<span class="ot">=</span><span class="fu">na.omit</span>(heart_disease)</span>
<span id="cb254-3"><a href="data_preparation.html#cb254-3" tabindex="-1"></a><span class="fu">nrow</span>(heart_disease) <span class="co"># 제외 전 행 수</span></span></code></pre></div>
<pre><code>## [1] 303</code></pre>
<div class="sourceCode" id="cb256"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb256-1"><a href="data_preparation.html#cb256-1" tabindex="-1"></a><span class="fu">nrow</span>(heart_disease_clean) <span class="co"># 제외 후 행 수</span></span></code></pre></div>
<pre><code>## [1] 297</code></pre>
<p>제외 후 303개 행 중 6개 행이 제거되었습니다. 이 접근 방식은 이 데이터셋에 적합해 보입니다.</p>
<p>하지만 거의 모든 사례가 빈 값인 다른 시나리오에서는 제외를 하면 전체 데이터셋이 삭제될 수도 있습니다!</p>
</div>
<div id="열-제외하기" class="section level3 hasAnchor" number="2.5.5">
<h3><span class="header-section-number">2.5.5</span> 열 제외하기<a href="data_preparation.html#열-제외하기" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>지난 사례와 마찬가지로 열을 제외합니다. 동일한 논리를 적용하여 <em>몇 개의</em> 열만 삭제되고 나머지 열들이 신뢰할 수 있는 최종 결과를 제공한다면 받아들여질 수 있습니다.</p>
<p><strong>R 예시:</strong></p>
<p>이러한 제외는 <code>df_status</code> 함수로 쉽게 처리할 수 있습니다. 다음 코드는 <code>NA</code> 값의 비율이 0보다 큰 모든 변수 이름을 유지할 것입니다.</p>
<div class="sourceCode" id="cb258"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb258-1"><a href="data_preparation.html#cb258-1" tabindex="-1"></a><span class="co"># NA 값을 가진 변수 이름 가져오기</span></span>
<span id="cb258-2"><a href="data_preparation.html#cb258-2" tabindex="-1"></a>vars_to_exclude <span class="ot">=</span> <span class="fu">df_status</span>(heart_disease) <span class="sc">%&gt;%</span> </span>
<span id="cb258-3"><a href="data_preparation.html#cb258-3" tabindex="-1"></a>  <span class="fu">filter</span>(p_na <span class="sc">&gt;</span> <span class="dv">0</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb258-4"><a href="data_preparation.html#cb258-4" tabindex="-1"></a>  <span class="fu">pull</span>(variable)</span></code></pre></div>
<pre><code>##                  variable q_zeros p_zeros q_na p_na q_inf p_inf    type unique
## 1                     age       0    0.00    0 0.00     0     0 integer     41
## 2                  gender       0    0.00    0 0.00     0     0  factor      2
## 3              chest_pain       0    0.00    0 0.00     0     0  factor      4
## 4  resting_blood_pressure       0    0.00    0 0.00     0     0 integer     50
## 5       serum_cholestoral       0    0.00    0 0.00     0     0 integer    152
## 6     fasting_blood_sugar     258   85.15    0 0.00     0     0  factor      2
## 7         resting_electro     151   49.83    0 0.00     0     0  factor      3
## 8          max_heart_rate       0    0.00    0 0.00     0     0 integer     91
## 9             exer_angina     204   67.33    0 0.00     0     0 integer      2
## 10                oldpeak      99   32.67    0 0.00     0     0 numeric     40
## 11                  slope       0    0.00    0 0.00     0     0 integer      3
## 12      num_vessels_flour     176   58.09    4 1.32     0     0 integer      4
## 13                   thal       0    0.00    2 0.66     0     0  factor      3
## 14 heart_disease_severity     164   54.13    0 0.00     0     0 integer      5
## 15           exter_angina     204   67.33    0 0.00     0     0  factor      2
## 16      has_heart_disease       0    0.00    0 0.00     0     0  factor      2</code></pre>
<div class="sourceCode" id="cb260"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb260-1"><a href="data_preparation.html#cb260-1" tabindex="-1"></a><span class="co"># 제외할 변수 확인</span></span>
<span id="cb260-2"><a href="data_preparation.html#cb260-2" tabindex="-1"></a>vars_to_exclude</span></code></pre></div>
<pre><code>## [1] &quot;num_vessels_flour&quot; &quot;thal&quot;</code></pre>
<div class="sourceCode" id="cb262"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb262-1"><a href="data_preparation.html#cb262-1" tabindex="-1"></a><span class="co"># 원본 데이터셋에서 변수 제외하기</span></span>
<span id="cb262-2"><a href="data_preparation.html#cb262-2" tabindex="-1"></a>heart_disease_clean_2 <span class="ot">=</span> <span class="fu">select</span>(heart_disease, <span class="sc">-</span><span class="fu">any_of</span>(vars_to_exclude))</span></code></pre></div>
</div>
<div id="범주형-변수의-빈-값-처리하기" class="section level3 hasAnchor" number="2.5.6">
<h3><span class="header-section-number">2.5.6</span> 범주형 변수의 빈 값 처리하기<a href="data_preparation.html#범주형-변수의-빈-값-처리하기" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>명목 변수의 빈 값을 처리하고 변환하는 다양한 관점을 다룹니다.</p>
<p>다음 예제 데이터는 사용자가 특정 웹 페이지에 어떻게 들어오는지에 대한 표준 정보가 포함된 <code>web_navigation_data</code>에서 파생되었습니다. 여기에는 <code>source_page</code>(방문자가 온 페이지), <code>landing_page</code>(처음 방문한 페이지), <code>country</code>가 포함되어 있습니다.</p>
<div class="sourceCode" id="cb263"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb263-1"><a href="data_preparation.html#cb263-1" tabindex="-1"></a><span class="co"># 예제 데이터를 읽을 때 na.strings 매개변수에 주의하세요.</span></span>
<span id="cb263-2"><a href="data_preparation.html#cb263-2" tabindex="-1"></a>web_navigation_data<span class="ot">=</span></span>
<span id="cb263-3"><a href="data_preparation.html#cb263-3" tabindex="-1"></a>  <span class="fu">read.delim</span>(<span class="at">file=</span><span class="st">&quot;https://goo.gl/dz7zNx&quot;</span>, </span>
<span id="cb263-4"><a href="data_preparation.html#cb263-4" tabindex="-1"></a>             <span class="at">sep=</span><span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>, </span>
<span id="cb263-5"><a href="data_preparation.html#cb263-5" tabindex="-1"></a>             <span class="at">header =</span> T, </span>
<span id="cb263-6"><a href="data_preparation.html#cb263-6" tabindex="-1"></a>             <span class="at">stringsAsFactors=</span>F, </span>
<span id="cb263-7"><a href="data_preparation.html#cb263-7" tabindex="-1"></a>             <span class="at">na.strings=</span><span class="st">&quot;&quot;</span>)</span></code></pre></div>
<div id="데이터-프로파일링" class="section level4 hasAnchor" number="2.5.6.1">
<h4><span class="header-section-number">2.5.6.1</span> 데이터 프로파일링<a href="data_preparation.html#데이터-프로파일링" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<div class="sourceCode" id="cb264"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb264-1"><a href="data_preparation.html#cb264-1" tabindex="-1"></a>stat_nav_data<span class="ot">=</span><span class="fu">df_status</span>(web_navigation_data)</span></code></pre></div>
<pre><code>##       variable q_zeros p_zeros q_na  p_na q_inf p_inf      type unique
## 1  source_page       0       0   50 51.55     0     0 character      5
## 2 landing_page       0       0    5  5.15     0     0 character      5
## 3      country       0       0    3  3.09     0     0 character     18</code></pre>
<p>세 변수 모두 빈(<code>NA</code>) 값을 가지고 있습니다. <code>source_page</code> 값의 거의 절반이 누락되었으며, 다른 두 변수는 5%와 3%의 <code>NA</code>를 가지고 있습니다.</p>
</div>
<div id="사례-a-빈-값을-문자열로-변환" class="section level4 hasAnchor" number="2.5.6.2">
<h4><span class="header-section-number">2.5.6.2</span> 사례 A: 빈 값을 문자열로 변환<a href="data_preparation.html#사례-a-빈-값을-문자열로-변환" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>범주형 또는 명목형 변수에서 가장 빠른 처리는 빈 값을 <code>unknown</code> 문자열로 변환하는 것입니다. 따라서 머신러닝 모델은 “빈” 값을 또 다른 카테고리로 처리하게 됩니다. 이를 “만약 변수_X = unknown이면, 결과 = yes”와 같은 규칙으로 생각하십시오.</p>
<p>다음으로 일반적인 시나리오를 다루기 위한 두 가지 방법을 제안합니다.</p>
<p><strong>R 예시:</strong></p>
<div class="sourceCode" id="cb266"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb266-1"><a href="data_preparation.html#cb266-1" tabindex="-1"></a><span class="fu">library</span>(tidyr)</span>
<span id="cb266-2"><a href="data_preparation.html#cb266-2" tabindex="-1"></a></span>
<span id="cb266-3"><a href="data_preparation.html#cb266-3" tabindex="-1"></a><span class="co"># 방법 1: 하나의 변수만 변환</span></span>
<span id="cb266-4"><a href="data_preparation.html#cb266-4" tabindex="-1"></a>web_navigation_data_1 <span class="ot">=</span> web_navigation_data <span class="sc">%&gt;%</span> </span>
<span id="cb266-5"><a href="data_preparation.html#cb266-5" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">source_page =</span> </span>
<span id="cb266-6"><a href="data_preparation.html#cb266-6" tabindex="-1"></a>           <span class="fu">replace_na</span>(source_page, </span>
<span id="cb266-7"><a href="data_preparation.html#cb266-7" tabindex="-1"></a>                      <span class="st">&quot;unknown_source&quot;</span>)</span>
<span id="cb266-8"><a href="data_preparation.html#cb266-8" tabindex="-1"></a>         )</span>
<span id="cb266-9"><a href="data_preparation.html#cb266-9" tabindex="-1"></a></span>
<span id="cb266-10"><a href="data_preparation.html#cb266-10" tabindex="-1"></a></span>
<span id="cb266-11"><a href="data_preparation.html#cb266-11" tabindex="-1"></a><span class="co"># 방법 2: 특정 변수들에만 함수를 적용한 다음 </span></span>
<span id="cb266-12"><a href="data_preparation.html#cb266-12" tabindex="-1"></a><span class="co"># 원래의 데이터 프레임을 반환하는 일반적인 상황입니다.</span></span>
<span id="cb266-13"><a href="data_preparation.html#cb266-13" tabindex="-1"></a></span>
<span id="cb266-14"><a href="data_preparation.html#cb266-14" tabindex="-1"></a><span class="co"># NA 값의 비율이 6% 미만인 모든 변수를 </span></span>
<span id="cb266-15"><a href="data_preparation.html#cb266-15" tabindex="-1"></a><span class="co"># 변환하고 싶다고 가정해 봅시다.</span></span>
<span id="cb266-16"><a href="data_preparation.html#cb266-16" tabindex="-1"></a>vars_to_process <span class="ot">=</span> stat_nav_data <span class="sc">%&gt;%</span> </span>
<span id="cb266-17"><a href="data_preparation.html#cb266-17" tabindex="-1"></a>  <span class="fu">filter</span>(p_na <span class="sc">&lt;</span> <span class="dv">6</span>) <span class="sc">%&gt;%</span> </span>
<span id="cb266-18"><a href="data_preparation.html#cb266-18" tabindex="-1"></a>  <span class="fu">pull</span>(variable)</span>
<span id="cb266-19"><a href="data_preparation.html#cb266-19" tabindex="-1"></a></span>
<span id="cb266-20"><a href="data_preparation.html#cb266-20" tabindex="-1"></a>vars_to_process</span></code></pre></div>
<pre><code>## [1] &quot;landing_page&quot; &quot;country&quot;</code></pre>
<div class="sourceCode" id="cb268"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb268-1"><a href="data_preparation.html#cb268-1" tabindex="-1"></a><span class="co"># 변환된 변수로 새로운 데이터 프레임 생성</span></span>
<span id="cb268-2"><a href="data_preparation.html#cb268-2" tabindex="-1"></a>web_navigation_data_2 <span class="ot">=</span> web_navigation_data <span class="sc">%&gt;%</span></span>
<span id="cb268-3"><a href="data_preparation.html#cb268-3" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="fu">across</span>(<span class="fu">all_of</span>(vars_to_process), <span class="sc">~</span><span class="fu">replace_na</span>(., <span class="st">&quot;other&quot;</span>)))</span></code></pre></div>
<p>결과 확인:</p>
<div class="sourceCode" id="cb269"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb269-1"><a href="data_preparation.html#cb269-1" tabindex="-1"></a><span class="fu">df_status</span>(web_navigation_data_1)</span></code></pre></div>
<pre><code>##       variable q_zeros p_zeros q_na p_na q_inf p_inf      type unique
## 1  source_page       0       0    0 0.00     0     0 character      6
## 2 landing_page       0       0    5 5.15     0     0 character      5
## 3      country       0       0    3 3.09     0     0 character     18</code></pre>
<div class="sourceCode" id="cb271"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb271-1"><a href="data_preparation.html#cb271-1" tabindex="-1"></a><span class="fu">df_status</span>(web_navigation_data_2)</span></code></pre></div>
<pre><code>##       variable q_zeros p_zeros q_na  p_na q_inf p_inf      type unique
## 1  source_page       0       0   50 51.55     0     0 character      5
## 2 landing_page       0       0    0  0.00     0     0 character      6
## 3      country       0       0    0  0.00     0     0 character     19</code></pre>
<p>참고: 특정 열에 함수를 적용하는 것은 모든 데이터 프로젝트에서 매우 보편적인 작업입니다. <code>dplyr</code>의 <code>across</code> 사용법에 대한 자세한 정보: <a href="https://stackoverflow.com/questions/27027347/mutate-each-summarise-each-in-dplyr-how-do-i-select-certain-columns-and-give">how do I select certain columns and give new names to mutated columns?</a></p>
</div>
<div id="사례-b-가장-빈번한-카테고리-할당" class="section level4 hasAnchor" number="2.5.6.3">
<h4><span class="header-section-number">2.5.6.3</span> 사례 B: 가장 빈번한 카테고리 할당<a href="data_preparation.html#사례-b-가장-빈번한-카테고리-할당" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>이 방법의 이면에는 _변수에 영향을 주지 않기 위해 동일한 것을 더 추가한다_는 직관이 있습니다. 그러나 때때로 영향을 미칠 때도 있습니다. 가장 흔한 값이 90%의 빈도로 나타날 때와 10%일 때의 영향은 같지 않을 것입니다. 즉, 분포에 따라 다릅니다.</p>
<p>k-NN과 같이 다른 예측 모델을 기반으로 새로운 결측값을 대치할 수 있는 다른 시나리오도 있습니다. 이 접근 방식은 가장 빈번한 값으로 대체하는 것보다 더 적합합니다. 그러나 권장되는 기술은 _사례 A: 빈 값을 문자열로 변환_에서 본 방법입니다.</p>
</div>
<div id="사례-c-일부-열-제외-및-다른-열-변환" class="section level4 hasAnchor" number="2.5.6.4">
<h4><span class="header-section-number">2.5.6.4</span> 사례 C: 일부 열 제외 및 다른 열 변환<a href="data_preparation.html#사례-c-일부-열-제외-및-다른-열-변환" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>쉬운 사례는 열에 예를 들어 50%의 <code>NA</code> 사례가 포함되어 있어 신뢰할 수 없을 가능성이 매우 높은 경우입니다.</p>
<p>앞서 본 사례에서 <code>source_page</code>는 절반 이상의 값이 비어 있습니다. 우리는 이 변수를 제외하고 나머지 두 변수를 이전에 했던 것처럼 변환할 수 있습니다.</p>
<p>예제는 범용적으로 준비되었습니다.</p>
<div class="sourceCode" id="cb273"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb273-1"><a href="data_preparation.html#cb273-1" tabindex="-1"></a><span class="co"># 임계값 설정</span></span>
<span id="cb273-2"><a href="data_preparation.html#cb273-2" tabindex="-1"></a>threshold_to_exclude<span class="ot">=</span><span class="dv">50</span> <span class="co"># 50은 50%를 나타냄</span></span>
<span id="cb273-3"><a href="data_preparation.html#cb273-3" tabindex="-1"></a>vars_to_exclude<span class="ot">=</span>stat_nav_data <span class="sc">%&gt;%</span> <span class="fu">filter</span>(p_na <span class="sc">&gt;=</span> threshold_to_exclude) </span>
<span id="cb273-4"><a href="data_preparation.html#cb273-4" tabindex="-1"></a>vars_to_keep<span class="ot">=</span>stat_nav_data <span class="sc">%&gt;%</span> <span class="fu">filter</span>(p_na <span class="sc">&lt;</span> threshold_to_exclude) </span>
<span id="cb273-5"><a href="data_preparation.html#cb273-5" tabindex="-1"></a></span>
<span id="cb273-6"><a href="data_preparation.html#cb273-6" tabindex="-1"></a><span class="co"># 마지막으로...</span></span>
<span id="cb273-7"><a href="data_preparation.html#cb273-7" tabindex="-1"></a>vars_to_exclude<span class="sc">$</span>variable</span></code></pre></div>
<pre><code>## [1] &quot;source_page&quot;</code></pre>
<div class="sourceCode" id="cb275"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb275-1"><a href="data_preparation.html#cb275-1" tabindex="-1"></a>vars_to_keep<span class="sc">$</span>variable</span></code></pre></div>
<pre><code>## [1] &quot;landing_page&quot; &quot;country&quot;</code></pre>
<div class="sourceCode" id="cb277"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb277-1"><a href="data_preparation.html#cb277-1" tabindex="-1"></a><span class="co"># 다음 라인은 임계값 이상의 변수를 제외하고 나머지 변수를 변환합니다.</span></span>
<span id="cb277-2"><a href="data_preparation.html#cb277-2" tabindex="-1"></a>web_navigation_data_3 <span class="ot">=</span> web_navigation_data <span class="sc">%&gt;%</span></span>
<span id="cb277-3"><a href="data_preparation.html#cb277-3" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span><span class="fu">any_of</span>(vars_to_exclude<span class="sc">$</span>variable)) <span class="sc">%&gt;%</span></span>
<span id="cb277-4"><a href="data_preparation.html#cb277-4" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="fu">across</span>(<span class="fu">all_of</span>(vars_to_keep<span class="sc">$</span>variable), <span class="sc">~</span><span class="fu">replace_na</span>(., <span class="st">&quot;unknown&quot;</span>)))</span>
<span id="cb277-5"><a href="data_preparation.html#cb277-5" tabindex="-1"></a></span>
<span id="cb277-6"><a href="data_preparation.html#cb277-6" tabindex="-1"></a></span>
<span id="cb277-7"><a href="data_preparation.html#cb277-7" tabindex="-1"></a><span class="co"># NA 값이 없고 NA 임계값 이상의 변수가 사라졌는지 확인합니다.</span></span>
<span id="cb277-8"><a href="data_preparation.html#cb277-8" tabindex="-1"></a><span class="fu">df_status</span>(web_navigation_data_3)</span></code></pre></div>
<pre><code>##       variable q_zeros p_zeros q_na p_na q_inf p_inf      type unique
## 1 landing_page       0       0    0    0     0     0 character      6
## 2      country       0       0    0    0     0     0 character     19</code></pre>
</div>
</div>
<div id="결측값에-어떤-패턴이-있나요" class="section level3 hasAnchor" number="2.5.7">
<h3><span class="header-section-number">2.5.7</span> 결측값에 어떤 패턴이 있나요?<a href="data_preparation.html#결측값에-어떤-패턴이-있나요" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>먼저, 영화 데이터 예제를 로드하고 빠른 프로파일링을 수행합니다.</p>
<div class="sourceCode" id="cb279"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb279-1"><a href="data_preparation.html#cb279-1" tabindex="-1"></a><span class="co"># Lock5Data에는 연습하기 좋은 많은 데이터 프레임이 포함되어 있습니다.</span></span>
<span id="cb279-2"><a href="data_preparation.html#cb279-2" tabindex="-1"></a><span class="co"># install.packages(&quot;Lock5Data&quot;)</span></span>
<span id="cb279-3"><a href="data_preparation.html#cb279-3" tabindex="-1"></a><span class="fu">library</span>(Lock5Data)</span>
<span id="cb279-4"><a href="data_preparation.html#cb279-4" tabindex="-1"></a></span>
<span id="cb279-5"><a href="data_preparation.html#cb279-5" tabindex="-1"></a><span class="co"># 데이터 로드</span></span>
<span id="cb279-6"><a href="data_preparation.html#cb279-6" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;HollywoodMovies2011&quot;</span>)</span>
<span id="cb279-7"><a href="data_preparation.html#cb279-7" tabindex="-1"></a></span>
<span id="cb279-8"><a href="data_preparation.html#cb279-8" tabindex="-1"></a><span class="co"># 프로파일링</span></span>
<span id="cb279-9"><a href="data_preparation.html#cb279-9" tabindex="-1"></a><span class="fu">df_status</span>(HollywoodMovies2011)</span></code></pre></div>
<pre><code>##             variable q_zeros p_zeros q_na  p_na q_inf p_inf    type unique
## 1              Movie       0    0.00    0  0.00     0     0  factor    136
## 2         LeadStudio       0    0.00    0  0.00     0     0  factor     34
## 3     RottenTomatoes       0    0.00    2  1.47     0     0 integer     75
## 4      AudienceScore       0    0.00    1  0.74     0     0 integer     60
## 5              Story       0    0.00    0  0.00     0     0  factor     22
## 6              Genre       0    0.00    0  0.00     0     0  factor      9
## 7   TheatersOpenWeek       0    0.00   16 11.76     0     0 integer    118
## 8  BOAverageOpenWeek       0    0.00   16 11.76     0     0 integer    120
## 9      DomesticGross       0    0.00    2  1.47     0     0 numeric    130
## 10      ForeignGross       0    0.00   15 11.03     0     0 numeric    121
## 11        WorldGross       0    0.00    2  1.47     0     0 numeric    134
## 12            Budget       0    0.00    2  1.47     0     0 numeric     60
## 13     Profitability       1    0.74    2  1.47     0     0 numeric    134
## 14    OpeningWeekend       1    0.74    3  2.21     0     0 numeric    130</code></pre>
<p><code>p_na</code> 열에 있는 값들을 살펴봅시다. 결측값에 어떤 패턴이 있습니다: 4개의 변수는 1.47%의 NA 값을 가지고 있고, 다른 4개는 약 11.7%를 가지고 있습니다. 이 경우 데이터 소스를 확인할 수는 없지만, 해당 사례들에 공통적인 문제가 있는지 확인해 보는 것이 좋습니다.</p>
</div>
<div id="수치형-변수의-결측값-처리하기" class="section level3 hasAnchor" number="2.5.8">
<h3><span class="header-section-number">2.5.8</span> 수치형 변수의 결측값 처리하기<a href="data_preparation.html#수치형-변수의-결측값-처리하기" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>우리는 장의 시작 부분에서 모든 <code>NA</code> 값을 0으로 변환함으로써 이 문제에 접근했습니다.</p>
<p>한 가지 해결책은 빈 값을 하나로 평균, 중앙값 또는 다른 기준으로 대체하는 것입니다. 그러나 이로 인해 발생하는 분포의 변화를 인지해야 합니다.</p>
<p>변수가 비어 있지 않을 경우 상관관계가 있는 것으로 보인다면(범주형과 동일), 대안적인 방법은 빈(bins)을 생성하여(버킷 또는 세그먼트라고도 함) 범주형으로 변환하는 것입니다.</p>
<div id="방법-1-범주형으로-변환하기" class="section level4 hasAnchor" number="2.5.8.1">
<h4><span class="header-section-number">2.5.8.1</span> 방법 1: 범주형으로 변환하기<a href="data_preparation.html#방법-1-범주형으로-변환하기" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><code>equal_freq</code> 함수는 변수를 원하는 빈으로 나눕니다. 이 함수는 수치형 변수(<code>TheatersOpenWeek</code>)를 받아서 등빈도 기준에 따라 범주형 변수(<code>TheatersOpenWeek_cat</code>)를 반환합니다.</p>
<div class="figure"><span style="display:block;" id="fig:na-missing-values-analysis"></span>
<img src="02_data_preparation_files/figure-html/na-missing-values-analysis-1.png" alt="범주형 데이터의 결측값" width="576"  />
<p class="caption">
Figure 2.27: 범주형 데이터의 결측값
</p>
</div>
<pre><code>##   TheatersOpenWeek_cat frequency percentage cumulative_perc
## 1          [   3,2408)        24      17.65           17.65
## 2          [2408,2904)        24      17.65           35.30
## 3          [2904,3114)        24      17.65           52.95
## 4          [3114,3507)        24      17.65           70.60
## 5          [3507,4375]        24      17.65           88.25
## 6                 &lt;NA&gt;        16      11.76          100.00</code></pre>
<p>보시다시피, <code>TheatersOpenWeek_cat</code>은 각각 24개의 사례를 가진 5개의 버킷을 포함하며, 각 버킷은 전체 사례의 약 18%를 나타냅니다. 하지만 <code>NA</code> 값은 여전히 존재합니다.</p>
<p>마지막으로, NA를 <code>empty</code> 문자열로 변환해야 합니다.</p>
<p><img src="02_data_preparation_files/figure-html/unnamed-chunk-65-1.png" alt="" width="576" /></p>
<p>이제 됐습니다. 변수를 사용할 준비가 되었습니다.</p>
<p><strong>사용자 정의 컷 (Custom cuts)</strong>:</p>
<p>등빈도에 의해 제공되는 버킷 크기 대신 사용자 정의 크기를 사용하고 싶다면 <code>cut</code> 함수를 사용할 수 있습니다. 이 경우 수치형 변수 <code>TheatersOpenWeek</code>를 받아서 <code>TheatersOpenWeek_cat_cust</code>를 반환합니다.</p>
<div class="sourceCode" id="cb282"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb282-1"><a href="data_preparation.html#cb282-1" tabindex="-1"></a><span class="co"># 현재 R 세션에서 과학적 표기법 비활성화</span></span>
<span id="cb282-2"><a href="data_preparation.html#cb282-2" tabindex="-1"></a><span class="fu">options</span>(<span class="at">scipen=</span><span class="dv">999</span>) </span>
<span id="cb282-3"><a href="data_preparation.html#cb282-3" tabindex="-1"></a></span>
<span id="cb282-4"><a href="data_preparation.html#cb282-4" tabindex="-1"></a><span class="co"># 1,000, 2,300 및 최대 4,100의 제한을 갖는 사용자 정의 버킷 생성.</span></span>
<span id="cb282-5"><a href="data_preparation.html#cb282-5" tabindex="-1"></a><span class="co"># 4,100을 초과하는 값은 NA로 할당됨.</span></span>
<span id="cb282-6"><a href="data_preparation.html#cb282-6" tabindex="-1"></a></span>
<span id="cb282-7"><a href="data_preparation.html#cb282-7" tabindex="-1"></a>HollywoodMovies2011<span class="sc">$</span>TheatersOpenWeek_cat_cust<span class="ot">=</span></span>
<span id="cb282-8"><a href="data_preparation.html#cb282-8" tabindex="-1"></a>  <span class="fu">cut</span>(HollywoodMovies2011<span class="sc">$</span>TheatersOpenWeek, </span>
<span id="cb282-9"><a href="data_preparation.html#cb282-9" tabindex="-1"></a>      <span class="at">breaks =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1000</span>, <span class="dv">2300</span>, <span class="dv">4100</span>), </span>
<span id="cb282-10"><a href="data_preparation.html#cb282-10" tabindex="-1"></a>      <span class="at">include.lowest =</span> T,</span>
<span id="cb282-11"><a href="data_preparation.html#cb282-11" tabindex="-1"></a>      <span class="at">dig.lab =</span> <span class="dv">10</span>)</span>
<span id="cb282-12"><a href="data_preparation.html#cb282-12" tabindex="-1"></a></span>
<span id="cb282-13"><a href="data_preparation.html#cb282-13" tabindex="-1"></a><span class="fu">freq</span>(HollywoodMovies2011<span class="sc">$</span>TheatersOpenWeek_cat_cust, </span>
<span id="cb282-14"><a href="data_preparation.html#cb282-14" tabindex="-1"></a>     <span class="at">plot =</span> F)</span></code></pre></div>
<pre><code>##           var frequency percentage cumulative_perc
## 1 (2300,4100]        94      69.12           69.12
## 2        &lt;NA&gt;        19      13.97           83.09
## 3 (1000,2300]        14      10.29           93.38
## 4    [0,1000]         9       6.62          100.00</code></pre>
<p><strong>등빈도 비닝(equal frequency binning)</strong>은 최소값과 최대값을 기준으로 각 세그먼트 사이의 거리를 취하는 등간격(equal distance) 분할보다 더 견고한 경향이 있습니다. 등간격 분할은 각 버킷에 얼마나 많은 사례가 들어가는지와 무관하게 수행되기 때문입니다.</p>
<p>등빈도는 이상치 값을 적절하게 첫 번째 또는 마지막 빈에 넣습니다. 일반적인 값은 3개에서 20개의 버킷 범위로 가질 수 있습니다. 버킷 수가 많을수록 노이즈가 심해지는 경향이 있습니다. 더 자세한 정보는 <a href="selecting_best_variables.html#profiling_target_cross_plot">cross_plot</a> 장의 함수를 확인하세요.</p>
</div>
<div id="방법-2-빈na-값을-특정-값으로-채우기" class="section level4 hasAnchor" number="2.5.8.2">
<h4><span class="header-section-number">2.5.8.2</span> 방법 2: 빈(NA) 값을 특정 값으로 채우기<a href="data_preparation.html#방법-2-빈na-값을-특정-값으로-채우기" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>범주형 변수와 마찬가지로, 평균이나 중앙값 같은 숫자로 값을 대체할 수 있습니다.</p>
<p>이 경우 <code>NA</code>를 평균으로 대체하고 전후 결과를 나란히 그려보겠습니다.</p>
<div class="sourceCode" id="cb284"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb284-1"><a href="data_preparation.html#cb284-1" tabindex="-1"></a><span class="co"># 모든 NA 값을 변수의 평균으로 채우기</span></span>
<span id="cb284-2"><a href="data_preparation.html#cb284-2" tabindex="-1"></a>HollywoodMovies2011<span class="sc">$</span>TheatersOpenWeek_mean<span class="ot">=</span></span>
<span id="cb284-3"><a href="data_preparation.html#cb284-3" tabindex="-1"></a>  <span class="fu">ifelse</span>(<span class="fu">is.na</span>(HollywoodMovies2011<span class="sc">$</span>TheatersOpenWeek), </span>
<span id="cb284-4"><a href="data_preparation.html#cb284-4" tabindex="-1"></a>         <span class="fu">mean</span>(HollywoodMovies2011<span class="sc">$</span>TheatersOpenWeek, </span>
<span id="cb284-5"><a href="data_preparation.html#cb284-5" tabindex="-1"></a>              <span class="at">na.rm =</span> T), </span>
<span id="cb284-6"><a href="data_preparation.html#cb284-6" tabindex="-1"></a>         HollywoodMovies2011<span class="sc">$</span>TheatersOpenWeek</span>
<span id="cb284-7"><a href="data_preparation.html#cb284-7" tabindex="-1"></a>         )</span>
<span id="cb284-8"><a href="data_preparation.html#cb284-8" tabindex="-1"></a></span>
<span id="cb284-9"><a href="data_preparation.html#cb284-9" tabindex="-1"></a><span class="co"># 원본 변수 플롯팅</span></span>
<span id="cb284-10"><a href="data_preparation.html#cb284-10" tabindex="-1"></a>p1<span class="ot">=</span><span class="fu">ggplot</span>(HollywoodMovies2011, <span class="fu">aes</span>(<span class="at">x=</span>TheatersOpenWeek)) <span class="sc">+</span></span>
<span id="cb284-11"><a href="data_preparation.html#cb284-11" tabindex="-1"></a>  <span class="fu">geom_histogram</span>(<span class="at">colour=</span><span class="st">&quot;black&quot;</span>, <span class="at">fill=</span><span class="st">&quot;white&quot;</span>) <span class="sc">+</span> </span>
<span id="cb284-12"><a href="data_preparation.html#cb284-12" tabindex="-1"></a>  <span class="fu">ylim</span>(<span class="dv">0</span>, <span class="dv">30</span>)</span>
<span id="cb284-13"><a href="data_preparation.html#cb284-13" tabindex="-1"></a> </span>
<span id="cb284-14"><a href="data_preparation.html#cb284-14" tabindex="-1"></a><span class="co"># 변환된 변수 플롯팅</span></span>
<span id="cb284-15"><a href="data_preparation.html#cb284-15" tabindex="-1"></a>p2<span class="ot">=</span><span class="fu">ggplot</span>(HollywoodMovies2011, </span>
<span id="cb284-16"><a href="data_preparation.html#cb284-16" tabindex="-1"></a>          <span class="fu">aes</span>(<span class="at">x=</span>TheatersOpenWeek_mean)</span>
<span id="cb284-17"><a href="data_preparation.html#cb284-17" tabindex="-1"></a>          ) <span class="sc">+</span> </span>
<span id="cb284-18"><a href="data_preparation.html#cb284-18" tabindex="-1"></a>  <span class="fu">geom_histogram</span>(<span class="at">colour=</span><span class="st">&quot;black&quot;</span>, <span class="at">fill=</span><span class="st">&quot;white&quot;</span>) <span class="sc">+</span> </span>
<span id="cb284-19"><a href="data_preparation.html#cb284-19" tabindex="-1"></a>  <span class="fu">ylim</span>(<span class="dv">0</span>, <span class="dv">30</span>)</span>
<span id="cb284-20"><a href="data_preparation.html#cb284-20" tabindex="-1"></a></span>
<span id="cb284-21"><a href="data_preparation.html#cb284-21" tabindex="-1"></a><span class="co"># 플롯을 나란히 배치 </span></span>
<span id="cb284-22"><a href="data_preparation.html#cb284-22" tabindex="-1"></a><span class="fu">library</span>(gridExtra)</span>
<span id="cb284-23"><a href="data_preparation.html#cb284-23" tabindex="-1"></a><span class="fu">grid.arrange</span>(p1, p2, <span class="at">ncol=</span><span class="dv">2</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:unnamed-chunk-67"></span>
<img src="02_data_preparation_files/figure-html/unnamed-chunk-67-1.png" alt="NA를 평균값으로 채우기" width="576"  />
<p class="caption">
Figure 2.28: NA를 평균값으로 채우기
</p>
</div>
<p>변환의 결과로 <code>2828</code>에서 정점을 볼 수 있습니다. 이는 이 지점 주변에 편향을 도입합니다. 만약 어떤 사건을 예측하고 있다면, 이 값 주변에 특별한 사건이 없는 것이 더 안전할 것입니다.</p>
<p>예를 들어, 이진 이벤트를 예측하고 있고 가장 대표성이 떨어지는 이벤트가 <code>TheatersOpenWeek</code>에서 평균인 <code>3000</code>을 갖는 것과 상관관계가 있다면, 더 높은 <strong>거짓 양성률(False Positive rate)</strong>을 가질 확률이 높아질 수 있습니다. 다시 한번 <a href="data_preparation.html#high_cardinality_predictive_modeling">예측 모델링에서의 고카디널리티 변수</a> 장과의 연결입니다.</p>
<p>마지막 시각화와 관련해서 하나 덧붙이자면, 플롯을 비교 가능하게 만들기 위해 y축 최대값을 30으로 설정하는 것이 중요했습니다.</p>
<p>보시다시피, 모든 개념들 사이에는 상호 관계가 있습니다 😉.</p>
</div>
<div id="채울-적절한-값-선택하기" class="section level4 hasAnchor" number="2.5.8.3">
<h4><span class="header-section-number">2.5.8.3</span> 채울 적절한 값 선택하기<a href="data_preparation.html#채울-적절한-값-선택하기" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>마지막 예제는 <code>NA</code>를 평균으로 대체했지만, 다른 값들은 어떨까요? 이는 변수의 분포에 달려 있습니다.</p>
<p>우리가 사용한 변수(<code>TheatersOpenWeek</code>)는 정규 분포를 따르는 것처럼 보였으며, 이것이 우리가 평균을 사용한 이유입니다. 그러나 변수가 더 치우쳐(skewed) 있다면, 다른 지표가 아마도 더 적합할 것입니다. 예를 들어, 중앙값(median)은 이상치에 덜 민감합니다.</p>
</div>
</div>
<div id="고급-대치-방법-advanced-imputation-methods" class="section level3 hasAnchor" number="2.5.9">
<h3><span class="header-section-number">2.5.9</span> 고급 대치 방법 (Advanced imputation methods)<a href="data_preparation.html#고급-대치-방법-advanced-imputation-methods" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>이제 우리는 예측 모델을 생성하는 좀 더 정교한 대치 방법에 대해 빠르게 검토해 보겠습니다.</p>
<div id="방법-1-랜덤-포레스트missforest-사용하기" class="section level4 hasAnchor" number="2.5.9.1">
<h4><span class="header-section-number">2.5.9.1</span> 방법 1: 랜덤 포레스트(missForest) 사용하기<a href="data_preparation.html#방법-1-랜덤-포레스트missforest-사용하기" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><a href="https://cran.r-project.org/web/packages/missForest/missForest.pdf">missForest</a> 패키지의 기능은 반복적인 프로세스에서 각 결측값을 완성하기 위해 여러 번의 랜덤 포레스트를 실행하는 것을 기반으로 하며, 범주형 및 수치형 변수를 동시에 처리합니다.</p>
<p>결측값 대치와 무관하게, 랜덤 포레스트 모델은 여러 다양한 종류의 데이터에서 최고의 성능을 내는 모델 중 하나입니다.
다음 예제에서 이전에 작업하던 <code>HollywoodMovies2011</code> 데이터를 완성해 보겠습니다. 이 데이터는 수치형 및 범주형 변수 모두에 <code>NA</code> 값을 포함하고 있습니다.</p>
<div class="sourceCode" id="cb285"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb285-1"><a href="data_preparation.html#cb285-1" tabindex="-1"></a><span class="co"># install.packages(&quot;missForest&quot;)</span></span>
<span id="cb285-2"><a href="data_preparation.html#cb285-2" tabindex="-1"></a><span class="fu">library</span>(missForest)</span>
<span id="cb285-3"><a href="data_preparation.html#cb285-3" tabindex="-1"></a></span>
<span id="cb285-4"><a href="data_preparation.html#cb285-4" tabindex="-1"></a><span class="co"># 데이터 복사</span></span>
<span id="cb285-5"><a href="data_preparation.html#cb285-5" tabindex="-1"></a>df_holly<span class="ot">=</span>Lock5Data<span class="sc">::</span>HollywoodMovies2011</span>
<span id="cb285-6"><a href="data_preparation.html#cb285-6" tabindex="-1"></a></span>
<span id="cb285-7"><a href="data_preparation.html#cb285-7" tabindex="-1"></a><span class="co"># TheatersOpenWeek_cat_cust 다시 생성</span></span>
<span id="cb285-8"><a href="data_preparation.html#cb285-8" tabindex="-1"></a>df_holly<span class="sc">$</span>TheatersOpenWeek_cat_cust<span class="ot">=</span></span>
<span id="cb285-9"><a href="data_preparation.html#cb285-9" tabindex="-1"></a>  <span class="fu">cut</span>(HollywoodMovies2011<span class="sc">$</span>TheatersOpenWeek, </span>
<span id="cb285-10"><a href="data_preparation.html#cb285-10" tabindex="-1"></a>      <span class="at">breaks =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">1000</span>, <span class="dv">2300</span>, <span class="dv">4100</span>), </span>
<span id="cb285-11"><a href="data_preparation.html#cb285-11" tabindex="-1"></a>      <span class="at">include.lowest =</span> T,</span>
<span id="cb285-12"><a href="data_preparation.html#cb285-12" tabindex="-1"></a>      <span class="at">dig.lab =</span> <span class="dv">10</span>)</span>
<span id="cb285-13"><a href="data_preparation.html#cb285-13" tabindex="-1"></a></span>
<span id="cb285-14"><a href="data_preparation.html#cb285-14" tabindex="-1"></a><span class="co"># 더 나은 예제를 위해 TheatersOpenWeek_3에 15%의 NA 값을 추가로 도입합니다.</span></span>
<span id="cb285-15"><a href="data_preparation.html#cb285-15" tabindex="-1"></a><span class="co"># missForest의 prodNA 함수가 도움이 될 것입니다.</span></span>
<span id="cb285-16"><a href="data_preparation.html#cb285-16" tabindex="-1"></a></span>
<span id="cb285-17"><a href="data_preparation.html#cb285-17" tabindex="-1"></a><span class="co"># 항상 동일한 수의 NA 값을 얻기 위해 시드 설정</span></span>
<span id="cb285-18"><a href="data_preparation.html#cb285-18" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">31415</span>) </span>
<span id="cb285-19"><a href="data_preparation.html#cb285-19" tabindex="-1"></a></span>
<span id="cb285-20"><a href="data_preparation.html#cb285-20" tabindex="-1"></a>df_holly<span class="sc">$</span>TheatersOpenWeek_cat_cust <span class="ot">=</span> df_holly <span class="sc">%&gt;%</span> </span>
<span id="cb285-21"><a href="data_preparation.html#cb285-21" tabindex="-1"></a>  <span class="fu">select</span>(TheatersOpenWeek_cat_cust) <span class="sc">%&gt;%</span></span>
<span id="cb285-22"><a href="data_preparation.html#cb285-22" tabindex="-1"></a>  <span class="fu">prodNA</span>(<span class="fl">0.15</span>) <span class="sc">%&gt;%</span></span>
<span id="cb285-23"><a href="data_preparation.html#cb285-23" tabindex="-1"></a>  <span class="fu">pull</span>(<span class="dv">1</span>)</span>
<span id="cb285-24"><a href="data_preparation.html#cb285-24" tabindex="-1"></a></span>
<span id="cb285-25"><a href="data_preparation.html#cb285-25" tabindex="-1"></a><span class="co"># 유용하지 않은 변수 제외</span></span>
<span id="cb285-26"><a href="data_preparation.html#cb285-26" tabindex="-1"></a>df_holly <span class="ot">=</span> df_holly <span class="sc">%&gt;%</span> <span class="fu">select</span>(<span class="sc">-</span>Movie)</span>
<span id="cb285-27"><a href="data_preparation.html#cb285-27" tabindex="-1"></a></span>
<span id="cb285-28"><a href="data_preparation.html#cb285-28" tabindex="-1"></a><span class="co"># 이제 마법이 펼쳐집니다! 데이터 프레임 대치</span></span>
<span id="cb285-29"><a href="data_preparation.html#cb285-29" tabindex="-1"></a><span class="co"># xmis 매개변수 = 결측값이 있는 데이터</span></span>
<span id="cb285-30"><a href="data_preparation.html#cb285-30" tabindex="-1"></a>imputation_res<span class="ot">=</span><span class="fu">missForest</span>(<span class="at">xmis =</span> df_holly)</span>
<span id="cb285-31"><a href="data_preparation.html#cb285-31" tabindex="-1"></a></span>
<span id="cb285-32"><a href="data_preparation.html#cb285-32" tabindex="-1"></a><span class="co"># 최종 대치된 데이터 프레임</span></span>
<span id="cb285-33"><a href="data_preparation.html#cb285-33" tabindex="-1"></a>df_imputed<span class="ot">=</span>imputation_res<span class="sc">$</span>ximp</span></code></pre></div>
<p>참고: <code>missForest</code>는 문자형(character) 변수가 있으면 실패합니다.</p>
<p>이제 대치된 일부 변수들의 분포를 비교해 볼 시간입니다. 이산화하기 전의 원래 변수인 <code>TheatersOpenWeek</code>를 사용하겠습니다. 시각적 분석에서 서로 비슷해 보이기를 바랍니다.</p>
<div class="sourceCode" id="cb286"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb286-1"><a href="data_preparation.html#cb286-1" tabindex="-1"></a><span class="co"># randomForest 패키지의 na.roughfix를 기반으로 한 또 다른 대치 생성</span></span>
<span id="cb286-2"><a href="data_preparation.html#cb286-2" tabindex="-1"></a><span class="cf">if</span>(<span class="sc">!</span><span class="fu">requireNamespace</span>(<span class="st">&quot;randomForest&quot;</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)) <span class="fu">install.packages</span>(<span class="st">&quot;randomForest&quot;</span>)</span>
<span id="cb286-3"><a href="data_preparation.html#cb286-3" tabindex="-1"></a><span class="fu">library</span>(randomForest)</span>
<span id="cb286-4"><a href="data_preparation.html#cb286-4" tabindex="-1"></a>df_rough<span class="ot">=</span>randomForest<span class="sc">::</span><span class="fu">na.roughfix</span>(df_holly)</span>
<span id="cb286-5"><a href="data_preparation.html#cb286-5" tabindex="-1"></a></span>
<span id="cb286-6"><a href="data_preparation.html#cb286-6" tabindex="-1"></a><span class="co"># 대치 전후의 분포 비교</span></span>
<span id="cb286-7"><a href="data_preparation.html#cb286-7" tabindex="-1"></a>df_holly<span class="sc">$</span>imputation<span class="ot">=</span><span class="st">&quot;original&quot;</span></span>
<span id="cb286-8"><a href="data_preparation.html#cb286-8" tabindex="-1"></a>df_rough<span class="sc">$</span>imputation<span class="ot">=</span><span class="st">&quot;na.roughfix&quot;</span></span>
<span id="cb286-9"><a href="data_preparation.html#cb286-9" tabindex="-1"></a>df_imputed<span class="sc">$</span>imputation<span class="ot">=</span><span class="st">&quot;missForest&quot;</span></span>
<span id="cb286-10"><a href="data_preparation.html#cb286-10" tabindex="-1"></a></span>
<span id="cb286-11"><a href="data_preparation.html#cb286-11" tabindex="-1"></a><span class="co"># 세 데이터 프레임을 하나로 합치고 imputation 변수로 구분</span></span>
<span id="cb286-12"><a href="data_preparation.html#cb286-12" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span>
<span id="cb286-13"><a href="data_preparation.html#cb286-13" tabindex="-1"></a>df_all<span class="ot">=</span><span class="fu">bind_rows</span>(df_holly, df_imputed, df_rough)</span>
<span id="cb286-14"><a href="data_preparation.html#cb286-14" tabindex="-1"></a></span>
<span id="cb286-15"><a href="data_preparation.html#cb286-15" tabindex="-1"></a><span class="co"># 플롯에 사용하기 위해 요인(factor)으로 변환</span></span>
<span id="cb286-16"><a href="data_preparation.html#cb286-16" tabindex="-1"></a>df_all<span class="sc">$</span>imputation<span class="ot">=</span><span class="fu">factor</span>(df_all<span class="sc">$</span>imputation, <span class="at">levels=</span><span class="fu">unique</span>(df_all<span class="sc">$</span>imputation))</span>
<span id="cb286-17"><a href="data_preparation.html#cb286-17" tabindex="-1"></a></span>
<span id="cb286-18"><a href="data_preparation.html#cb286-18" tabindex="-1"></a><span class="co"># 플롯팅</span></span>
<span id="cb286-19"><a href="data_preparation.html#cb286-19" tabindex="-1"></a><span class="fu">ggplot</span>(df_all, <span class="fu">aes</span>(TheatersOpenWeek, <span class="at">colour=</span>imputation)) <span class="sc">+</span> </span>
<span id="cb286-20"><a href="data_preparation.html#cb286-20" tabindex="-1"></a>  <span class="fu">geom_density</span>() <span class="sc">+</span> </span>
<span id="cb286-21"><a href="data_preparation.html#cb286-21" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span> </span>
<span id="cb286-22"><a href="data_preparation.html#cb286-22" tabindex="-1"></a>  <span class="fu">scale_colour_brewer</span>(<span class="at">palette=</span><span class="st">&quot;Set2&quot;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:how-to-impute-missing-values"></span>
<img src="02_data_preparation_files/figure-html/how-to-impute-missing-values-1.png" alt="대치 방법 비교 (수치형 변수)" width="480"  />
<p class="caption">
Figure 2.29: 대치 방법 비교 (수치형 변수)
</p>
</div>
<ul>
<li>주황색 곡선은 <code>missForest</code> 패키지를 기반으로 대치된 분포를 보여줍니다.</li>
<li>파란색은 처음에 논의했던 대치 방법으로, <code>randomForest</code> 패키지의 <code>na.roughfix</code> 함수를 사용하여 모든 <code>NA</code>를 중앙값으로 대체한 것입니다.</li>
<li>초록색은 대치 전의 분포를 보여줍니다 (당연히 NA 값은 표시되지 않습니다).</li>
</ul>
<p><strong>분석:</strong></p>
<p>예상대로 <code>NA</code>를 중앙값으로 대체하면 모든 값이 3000 주변에 집중되는 경향이 있습니다. 반면에 missForest 패키지에 의한 대치는 단일 값에 집중되지 않기 때문에 <strong>더욱 자연스러운 분포</strong>를 제공합니다. 이것이 3000 주변의 피크가 원래 것보다 낮은 이유입니다.</p>
<p>주황색과 초록색은 꽤 비슷해 보입니다!</p>
<p>분석적인 관점에서 보고 싶다면, 예를 들어 평균이나 분산을 비교하기 위해 통계적 테스트를 수행할 수 있습니다.</p>
<p>다음으로 <code>TheatersOpenWeek</code>를 이산화한 사용자 정의 변수(<code>TheatersOpenWeek_cat_cust</code>)를 시각화해 보겠습니다.</p>
<div class="sourceCode" id="cb287"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb287-1"><a href="data_preparation.html#cb287-1" tabindex="-1"></a><span class="co"># NA를 하나의 카테고리로 플롯하기 위한 편법</span></span>
<span id="cb287-2"><a href="data_preparation.html#cb287-2" tabindex="-1"></a><span class="fu">levels</span>(df_all<span class="sc">$</span>TheatersOpenWeek_cat_cust)<span class="ot">=</span></span>
<span id="cb287-3"><a href="data_preparation.html#cb287-3" tabindex="-1"></a>  <span class="fu">c</span>(<span class="fu">levels</span>(df_all<span class="sc">$</span>TheatersOpenWeek_cat_cust), <span class="st">&quot;NA&quot;</span>)</span>
<span id="cb287-4"><a href="data_preparation.html#cb287-4" tabindex="-1"></a></span>
<span id="cb287-5"><a href="data_preparation.html#cb287-5" tabindex="-1"></a>flag_na<span class="ot">=</span><span class="fu">is.na</span>(df_all<span class="sc">$</span>TheatersOpenWeek_cat_cust)</span>
<span id="cb287-6"><a href="data_preparation.html#cb287-6" tabindex="-1"></a></span>
<span id="cb287-7"><a href="data_preparation.html#cb287-7" tabindex="-1"></a>df_all<span class="sc">$</span>TheatersOpenWeek_cat_cust[flag_na]<span class="ot">=</span><span class="st">&quot;NA&quot;</span></span>
<span id="cb287-8"><a href="data_preparation.html#cb287-8" tabindex="-1"></a></span>
<span id="cb287-9"><a href="data_preparation.html#cb287-9" tabindex="-1"></a><span class="co"># 이제 플롯입니다!</span></span>
<span id="cb287-10"><a href="data_preparation.html#cb287-10" tabindex="-1"></a><span class="fu">ggplot</span>(df_all, <span class="fu">aes</span>(<span class="at">x =</span> TheatersOpenWeek_cat_cust, </span>
<span id="cb287-11"><a href="data_preparation.html#cb287-11" tabindex="-1"></a>                   <span class="at">fill =</span> TheatersOpenWeek_cat_cust)</span>
<span id="cb287-12"><a href="data_preparation.html#cb287-12" tabindex="-1"></a>       ) <span class="sc">+</span></span>
<span id="cb287-13"><a href="data_preparation.html#cb287-13" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">na.rm=</span>T) <span class="sc">+</span> </span>
<span id="cb287-14"><a href="data_preparation.html#cb287-14" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>imputation) <span class="sc">+</span> </span>
<span id="cb287-15"><a href="data_preparation.html#cb287-15" tabindex="-1"></a>  <span class="fu">geom_text</span>(<span class="at">stat=</span><span class="st">&#39;count&#39;</span>,</span>
<span id="cb287-16"><a href="data_preparation.html#cb287-16" tabindex="-1"></a>            <span class="fu">aes</span>(<span class="at">label=</span><span class="fu">after_stat</span>(count)),</span>
<span id="cb287-17"><a href="data_preparation.html#cb287-17" tabindex="-1"></a>            <span class="at">vjust=</span><span class="sc">-</span><span class="dv">1</span>) <span class="sc">+</span> </span>
<span id="cb287-18"><a href="data_preparation.html#cb287-18" tabindex="-1"></a>  <span class="fu">ylim</span>(<span class="dv">0</span>, <span class="dv">125</span>) <span class="sc">+</span> </span>
<span id="cb287-19"><a href="data_preparation.html#cb287-19" tabindex="-1"></a>  <span class="fu">scale_fill_brewer</span>(<span class="at">palette=</span><span class="st">&quot;Set2&quot;</span>) <span class="sc">+</span> </span>
<span id="cb287-20"><a href="data_preparation.html#cb287-20" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span> </span>
<span id="cb287-21"><a href="data_preparation.html#cb287-21" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">axis.text.x=</span></span>
<span id="cb287-22"><a href="data_preparation.html#cb287-22" tabindex="-1"></a>          <span class="fu">element_text</span>(<span class="at">angle =</span> <span class="dv">45</span>, <span class="at">hjust =</span> <span class="fl">0.7</span>)</span>
<span id="cb287-23"><a href="data_preparation.html#cb287-23" tabindex="-1"></a>        ) <span class="sc">+</span></span>
<span id="cb287-24"><a href="data_preparation.html#cb287-24" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position=</span><span class="st">&quot;bottom&quot;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:missing-value-imputation"></span>
<img src="02_data_preparation_files/figure-html/missing-value-imputation-1.png" alt="대치 방법 비교" width="672"  />
<p class="caption">
Figure 2.30: 대치 방법 비교
</p>
</div>
<p><strong>분석:</strong></p>
<p>원본 변수는 35개의 <code>NA</code> 값을 포함하고 있으며, 이는 <code>na.roughfix</code>에서 최빈값인 <code>(2300, 4100]</code>으로 대체되었습니다. 반면에 <code>missForest</code>를 사용했을 때는 약간 다른 결과를 얻었는데, 완성 기준이 다른 변수들에 기반했기 때문입니다.</p>
<p><code>missForest</code>는 <code>[0, 1000]</code> 카테고리에 15개 행을, <code>[1000, 2300]</code>에 3개를, 그리고 <code>[2300, 4100]</code> 카테고리에 17개를 추가했습니다.</p>
</div>
<div id="방법-2-mice-접근-방식-사용하기" class="section level4 hasAnchor" number="2.5.9.2">
<h4><span class="header-section-number">2.5.9.2</span> 방법 2: MICE 접근 방식 사용하기<a href="data_preparation.html#방법-2-mice-접근-방식-사용하기" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><strong>조언:</strong> 결측값 대치에 대한 초기 접근 방식으로는 이 방법이 정말 복잡합니다 😨.</p>
<p>MICE는 “Multivariate Imputation by Chained Equations”의 약자로, “Fully Conditional Specification”으로도 알려져 있습니다. 이 책은 그 인기 때문에 이를 다룹니다.</p>
<p>MICE는 결측값을 분석하고 처리하기 위한 완전한 프레임워크를 수반합니다. 이는 <strong>모든 변수</strong> 간의 상호작용을 동시에 고려하며(단일 변수가 아닌 다변량), 서로 다른 예측 모델을 사용하여 각 변수를 채우는 <strong>반복적인</strong> 프로세스에 기능을 기반으로 합니다.</p>
<p>내부적으로는 B와 C를 기반으로 변수 A를 채웁니다. 그런 다음 A(이전 단계에서 예측됨)와 C를 기반으로 B를 채우고 반복이 계속됩니다. “chained equations(연쇄 방정식)”라는 이름은 케이스를 대치하기 위해 변수별로 알고리즘을 지정할 수 있다는 사실에서 유래되었습니다.</p>
<p>이는 결측값이 없는 원래 데이터의 M개 복제본을 만듭니다. <em>그런데 왜 M개의 복제본을 만들까요?</em></p>
<p>각 복제본에서 _빈 슬롯_에 삽입할 값의 결정은 분포를 기반으로 합니다.</p>
<p>많은 MICE 시연은 대치를 검증하고 패키지에서 지원하는 몇 안 되는 예측 모델을 사용하는 데 초점을 맞춥니다. 다른 예측 모델(랜덤 포레스트, 그레디언트 부스팅 머신 등)이나 교차 검증 기술(예: <code>caret</code>)을 사용하고 싶지 않다면 이것으로 충분합니다.</p>
<p>MICE 기술은 결측값으로 인한 분산을 측정하기 위한 시설을 제공하는 M개 예측 모델의 매개변수(또는 베타)를 평균화하는 <code>pool()</code> 함수를 설정하여 최종 결과를 도출합니다.</p>
<p>네, 생성된 데이터 프레임당 하나의 모델입니다. <a href="https://en.wikipedia.org/wiki/Bootstrap_aggregating">배깅(bagging)</a>처럼 들리죠? 하지만 언급된 모델들에서는 이런 가능성이 없습니다.</p>
<p>MICE에는 채우기 결과를 처리하고 검증하는 데 도움이 되는 많은 함수가 있습니다. 하지만 아주 간단하게 유지하기 위해 극히 일부만 다루겠습니다. 다음 예제는 다른 프로그램이나 예측 모델과 함께 사용할 수 있도록 <strong>결측값이 없는 데이터 프레임을 추출</strong>하는 데 중점을 둘 것입니다.</p>
<p><strong>R 예시:</strong></p>
<p>이것은 <a href="https://cran.r-project.org/web/packages/mice/mice.pdf">mice 패키지</a>에 포함된 <code>nhanes</code> 데이터 프레임의 데이터를 대치할 것입니다. 확인해 봅시다:</p>
<div class="sourceCode" id="cb288"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb288-1"><a href="data_preparation.html#cb288-1" tabindex="-1"></a><span class="co"># install.packages(&quot;mice&quot;)</span></span>
<span id="cb288-2"><a href="data_preparation.html#cb288-2" tabindex="-1"></a><span class="fu">library</span>(mice)</span>
<span id="cb288-3"><a href="data_preparation.html#cb288-3" tabindex="-1"></a><span class="fu">df_status</span>(nhanes)</span></code></pre></div>
<pre><code>##   variable q_zeros p_zeros q_na p_na q_inf p_inf    type unique
## 1      age       0       0    0    0     0     0 numeric      3
## 2      bmi       0       0    9   36     0     0 numeric     16
## 3      hyp       0       0    8   32     0     0 numeric      2
## 4      chl       0       0   10   40     0     0 numeric     13</code></pre>
<p>세 개의 변수에 결측값이 있습니다. 채워봅시다:</p>
<div class="sourceCode" id="cb290"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb290-1"><a href="data_preparation.html#cb290-1" tabindex="-1"></a><span class="co"># 기본 대치는 5개의 완전한 데이터셋을 생성합니다.</span></span>
<span id="cb290-2"><a href="data_preparation.html#cb290-2" tabindex="-1"></a>imp_data<span class="ot">=</span><span class="fu">mice</span>(nhanes, <span class="at">m =</span> <span class="dv">5</span>, <span class="at">printFlag =</span> <span class="cn">FALSE</span>)</span>
<span id="cb290-3"><a href="data_preparation.html#cb290-3" tabindex="-1"></a></span>
<span id="cb290-4"><a href="data_preparation.html#cb290-4" tabindex="-1"></a><span class="co"># 5개의 대치된 데이터 프레임을 포함하는 최종 데이터셋을 가져옵니다. 전체 행 수 = nrow(nhanes) * 5</span></span>
<span id="cb290-5"><a href="data_preparation.html#cb290-5" tabindex="-1"></a>data_all<span class="ot">=</span><span class="fu">complete</span>(imp_data, <span class="st">&quot;long&quot;</span>)</span>
<span id="cb290-6"><a href="data_preparation.html#cb290-6" tabindex="-1"></a></span>
<span id="cb290-7"><a href="data_preparation.html#cb290-7" tabindex="-1"></a><span class="co"># data_all은 nhanes와 동일한 열에 .id와 .imp 두 개를 더 포함합니다.</span></span>
<span id="cb290-8"><a href="data_preparation.html#cb290-8" tabindex="-1"></a><span class="co"># .id = 1부터 25까지의 행 번호</span></span>
<span id="cb290-9"><a href="data_preparation.html#cb290-9" tabindex="-1"></a><span class="co"># .imp = 대치 데이터 프레임 .id 1부터 5까지 (m 매개변수)</span></span></code></pre></div>
<p>원본 데이터에서 <code>nhanes</code>는 25행을 가지고 있고 <code>data_all</code>은 125행을 포함하는데, 이는 각각 25행인 5개(<code>m=5</code>)의 완전한 데이터 프레임을 생성한 결과입니다.</p>
<p>결과를 확인할 시간입니다:</p>
<div class="sourceCode" id="cb291"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb291-1"><a href="data_preparation.html#cb291-1" tabindex="-1"></a><span class="fu">library</span>(mice)</span>
<span id="cb291-2"><a href="data_preparation.html#cb291-2" tabindex="-1"></a><span class="fu">densityplot</span>(imp_data)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:unnamed-chunk-71"></span>
<img src="02_data_preparation_files/figure-html/unnamed-chunk-71-1.png" alt="MICE를 사용한 결측값 결과 분석" width="576"  />
<p class="caption">
Figure 2.31: MICE를 사용한 결측값 결과 분석
</p>
</div>
<p>각 빨간색 선은 대치된 각 데이터 프레임의 분포를 보여주고 파란색 선은 원래의 분포를 포함합니다. 이 이면의 아이디어는 그들이 비슷해 보인다면 대치가 원래의 분포를 잘 따랐다는 것입니다.</p>
<p>예를 들어, <code>chl</code>은 대치된 데이터 프레임 하나를 포함합니다. 따라서 원래 것보다 훨씬 높은 두 값 주변에 두 개의 피크를 특징으로 하는 빨간색 선이 하나만 있습니다.</p>
<p>단점은 프로세스가 느리고 작동하기 위해 약간의 조정이 필요할 수 있다는 것입니다. 예를 들어: <code>mice_hollywood=mice(HollywoodMovies2011, m=5)</code>는 작은 데이터 프레임임에도 불구하고 처리하는 데 시간이 좀 걸린 후 실패할 것입니다.</p>
<p><code>MICE</code> 패키지에 대한 더 많은 정보:</p>
<ul>
<li>원본 MICE 논문: <a href="https://www.jstatsoft.org/article/view/v045i03">Multivariate Imputation by Chained Equations in R</a></li>
<li><a href="https://datascienceplus.com/handling-missing-data-with-mice-package-a-simple-approach">Handling missing data with MICE package; a simple approach</a></li>
</ul>
</div>
</div>
<div id="결론-1" class="section level3 hasAnchor" number="2.5.10">
<h3><span class="header-section-number">2.5.10</span> 결론<a href="data_preparation.html#결론-1" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>모든 것을 다룬 후, 우리는 물을 수 있습니다: 무엇이 최선의 전략일까요? 음, 결측값을 처리하기 위해 우리가 얼마나 개입해야 하는지에 달려 있습니다.</p>
<p>전략에 대한 빠른 검토는 다음과 같습니다:</p>
<ol style="list-style-type: upper-alpha">
<li><p>결측값이 있는 행과 열을 제외하기. 결측값이 있는 행(또는 열)이 <em>거의 없고</em>, 남은 데이터가 프로젝트 목표를 달성하기에 충분할 때만 적용 가능합니다. 그러나 결측값이 있는 행을 제외하고 운영 환경에서 실행될 예측 모델을 구축할 때, 결측값이 포함된 <strong>새로운 사례가 도착하면</strong> 이를 처리하기 위해 값을 할당해야 합니다.</p></li>
<li><p><strong>수치형 변수를 범주형으로 변환</strong>한 다음 “빈(empty)” 값을 생성하는 전략(범주형 변수에도 적용 가능)은 빈 값을 처리하기 위한 가장 빠르고 권장되는 옵션입니다. 이렇게 하면 모델이 불확실성을 처리할 수 있도록 결측값을 모델에 도입하게 됩니다.</p></li>
<li><p>MICE와 missForest로 다룬 것과 같은 <strong>대치 방법</strong>은 상당히 더 복잡합니다. 이러한 방법들을 통해 우리는 행이나 열을 제외할 필요가 없도록 <strong>제어된 편향(controlled-bias)</strong>을 도입합니다.</p></li>
</ol>
<p>이러한 변환들을 깊이 파고드는 것과 단순하게 유지하는 것 사이에서 올바른 균형을 찾는 것은 예술과 같습니다. 투자된 시간이 전체적인 정확도에 반영되지 않을 수도 있습니다.</p>
<p>방법에 상관없이 각 결정의 영향을 분석하는 것이 매우 중요합니다. 여러분의 데이터와 프로젝트에 가장 적합한 방법을 발견하기까지는 탐색적 데이터 분석뿐만 아니라 많은 시행착오가 따릅니다.</p>
<p><img src="introduction/spacer_bar.png" /><!-- --></p>
</div>
</div>
<div id="considerations-involving-time" class="section level2 hasAnchor" number="2.6">
<h2><span class="header-section-number">2.6</span> 시간과 관련된 고려 사항<a href="data_preparation.html#considerations-involving-time" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<div id="무엇에-대한-내용인가요-5" class="section level3 hasAnchor" number="2.6.1">
<h3><span class="header-section-number">2.6.1</span> 무엇에 대한 내용인가요?<a href="data_preparation.html#무엇에-대한-내용인가요-5" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p><img src="data_preparation/Heraklit.jpeg" alt="" width="150px" /></p>
<blockquote>
<p>모든 것은 변하고 아무것도 멈춰 있지 않는다. - 헤라클레이토스 (기원전 535년 ~ 475년), 소크라테스 이전의 그리스 철학자.</p>
</blockquote>
<p>변수도 마찬가지입니다.</p>
<p>시간이 지남에 따라 변수의 값은 변할 수 있으며, 이는 예측 모델을 생성하기 위해 시간 분석을 중요하게 만듭니다. <strong>결과</strong>를 <strong>원인</strong>으로 사용하는 것을 피해야 합니다.</p>
<p><strong>이 장에서 무엇을 검토할까요?</strong></p>
<ul>
<li>예측할 이벤트 이전의 정보를 필터링하는 개념.</li>
<li>값이 무한대(그 이상)로 증가하거나 감소하는 변수를 분석하고 준비하는 방법.</li>
</ul>
<div id="미래의-정보를-사용하지-마세요" class="section level4 hasAnchor" number="2.6.1.1">
<h4><span class="header-section-number">2.6.1.1</span> 미래의 정보를 사용하지 마세요<a href="data_preparation.html#미래의-정보를-사용하지-마세요" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><img src="data_preparation/back_to_the_future.png" alt="" width="200px" /></p>
<p><em>영화 “백 투 더 퓨처” (1985)의 장면. 로버트 저메키스 (감독).</em></p>
<p>예측하려는 이벤트 _이후_의 정보가 포함된 변수를 사용하는 것은 새로운 예측 모델 프로젝트를 시작할 때 흔히 저지르는 실수입니다. 이는 내일의 신문을 가지고 오늘 로또를 하는 것과 같습니다.</p>
<p>예를 들어, 웹 애플리케이션에서 어떤 사용자가 전체 구독(full subscription)을 구매할지 알기 위해 예측 모델을 구축해야 한다고 가정해 봅시다. 그리고 이 소프트웨어에는 <code>feature_A</code>라는 가상의 기능이 있습니다.</p>
<pre><code>##    user_id feature_A full_subscription
## 1        1       yes               yes
## 2        2       yes               yes
## 3        3       yes               yes
## 4        4        no                no
## 5        5       yes               yes
## 6        6        no                no
## 7        7        no                no
## 8        8        no                no
## 9        9        no                no
## 10      10        no                no</code></pre>
<p>예측 모델을 구축하여 완벽한 정확도를 얻었고, 조사 결과 다음과 같은 사실이 드러났습니다: <em>“전체 구독을 한 사용자 중 100%가 기능 A를 사용한다”</em>. 일부 예측 알고리즘은 변수 중요도를 보고하며, 따라서 <code>feature_A</code>가 최상위에 있을 것입니다.</p>
<p><strong>문제는:</strong> <code>feature_A</code>는 <strong>사용자가 전체 구독으로 전환한 후에만</strong> 사용할 수 있다는 점입니다. 따라서 이를 사용할 수 없습니다.</p>
<p><strong>핵심 메시지는</strong>: 완벽한 변수도, 완벽한 모델도 믿지 마세요.</p>
</div>
<div id="데이터로-정정당당하게-경쟁하고-데이터가-거동을-발전시키게-하세요" class="section level4 hasAnchor" number="2.6.1.2">
<h4><span class="header-section-number">2.6.1.2</span> 데이터로 정정당당하게 경쟁하고, 데이터가 거동을 발전시키게 하세요<a href="data_preparation.html#데이터로-정정당당하게-경쟁하고-데이터가-거동을-발전시키게-하세요" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>자연에서처럼 사물도 특정 행동을 보이기 시작하는 최소 시간과 최대 시간이 있습니다. 이 시간은 0에서 무한대 사이에서 요동칩니다. 실제로는 분석하기에 가장 좋은 기간이 언제인지 연구하는 것이 권장되는데, 즉 이 관찰 기간 전후의 모든 거동을 제외할 수 있습니다. 변수에서 범위를 설정하는 것은 다분히 주관적일 수 있기 때문에 간단한 일은 아닙니다.</p>
<p>시간이 흐름에 따라 수치가 증가하는 <strong>수치형 변수</strong>가 있다고 가정해 봅시다. 데이터를 필터링하고 예측 모델에 공급하기 위해 <strong>관찰 시간 윈도우(observation time window)</strong>를 정의해야 할 수도 있습니다.</p>
<ul>
<li><strong>최소</strong> 시간 설정: 거동이 나타나기 시작하는 데 얼마나 많은 시간이 필요한가?</li>
<li><strong>최대</strong> 시간 설정: 거동의 끝을 확인하는 데 얼마나 많은 시간이 소요되는가?</li>
</ul>
<p>가장 쉬운 해결책은 최소 시간을 시작부터로, 최대 시간을 전체 이력으로 설정하는 것입니다.</p>
<p><strong>사례 연구:</strong></p>
<p>두 사람 <code>Ouro</code>와 <code>Borus</code>는 <code>feature_A</code>라는 특정 기능이 있는 웹 애플리케이션의 사용자이며, 우리는 <code>feature_A</code> 사용량(클릭 수 측정)을 기반으로 해당인이 <code>full_subscription</code>을 구매할지 예측하는 모델을 구축해야 합니다.</p>
<p>현재 데이터에 따르면 Borus는 <code>full_subscription</code>을 가지고 있지만 Ouro는 가지고 있지 않습니다.</p>
<div class="figure"><span style="display:block;" id="fig:data-preparation-time-variable"></span>
<img src="02_data_preparation_files/figure-html/data-preparation-time-variable-1.png" alt="시간 고려 사항에 주의하세요" width="384"  />
<p class="caption">
Figure 2.32: 시간 고려 사항에 주의하세요
</p>
</div>
<p>사용자 <code>Borus</code>는 3일째부터 <code>feature_A</code>를 사용하기 시작했고, 5일 후에는 0일째부터 사용을 시작한 <code>Ouro</code>보다 이 기능을 더 많이 사용(15 대 12 클릭)했습니다.</p>
<p>만약 <code>Borus</code>가 <code>full subscription</code>을 구매하고 <code>Ouro</code>는 구매하지 않는다면, <em>모델은 무엇을 배울까요?</em></p>
<p>전체 이력(<code>days_since_signup = all</code>)으로 모델링할 때, <code>Borus</code>가 가장 높은 수치를 가지고 있기 때문에 <code>days_since_signup</code>이 높을수록 가능성이 높아집니다.</p>
<p>하지만 우리가 가입 후 첫 5일간에 해당하는 사용자 이력만 유지한다면 결론은 반대가 됩니다.</p>
<p><em>왜 첫 5일간의 이력만 유지할까요?</em></p>
<p>이 시작 단계에서의 행동이 전체 이력을 분석하는 것보다 (예측 정확도 측면에서) 더 관련성이 높을 수 있습니다. 앞서 말했듯이 각 사례에 따라 다릅니다.</p>
</div>
<div id="무한함과의-싸움" class="section level4 hasAnchor" number="2.6.1.3">
<h4><span class="header-section-number">2.6.1.3</span> 무한함과의 싸움<a href="data_preparation.html#무한함과의-싸움" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p><img src="data_preparation/infinity.png" alt="" width="150px" /></p>
<p>이 주제에 대한 예시는 방대합니다. 이 장의 핵심을 <strong>데이터가 시간에 따라 어떻게 변하는지</strong>에 두겠습니다. 때로는 고정된 시간 후에 변수가 최소값(또는 최대값)에 도달하는 것처럼 간단할 수도 있습니다. 이러한 경우는 쉽게 달성할 수 있습니다.</p>
<p>반면에, 인간은 무한함과 맞서 싸워야 합니다.</p>
<p>다음 예시를 고려해 봅시다. <em>0 값에 도달하는 데 몇 시간이 필요할까요?</em></p>
<p>100시간은 어떨까요?</p>
<div class="figure"><span style="display:block;" id="fig:data-preparation-time-variable-1"></span>
<img src="02_data_preparation_files/figure-html/data-preparation-time-variable-1-1.png" alt="100시간" width="384"  />
<p class="caption">
Figure 2.33: 100시간
</p>
</div>
<p>음, 최소값을 확인해 봅시다.</p>
<pre><code>## [1] &quot;100시간 후 최소값: 0.22&quot;</code></pre>
<p>0에 가깝지만, <em>만약 1000시간을 기다린다면 어떨까요?</em></p>
<div class="figure"><span style="display:block;" id="fig:data-preparation-time-variable-3"></span>
<img src="02_data_preparation_files/figure-html/data-preparation-time-variable-3-1.png" alt="1,000시간" width="384"  />
<p class="caption">
Figure 2.34: 1,000시간
</p>
</div>
<pre><code>## [1] &quot;1,000시간 후 최소값: 0.14&quot;</code></pre>
<p>야호! 0에 접근하고 있습니다! <code>0.21</code>에서 <code>0.14</code>로 말이죠. 하지만 10배 더 기다린다면(10,000시간) 어떨까요?</p>
<div class="figure"><span style="display:block;" id="fig:data-preparation-time-variable-4"></span>
<img src="02_data_preparation_files/figure-html/data-preparation-time-variable-4-1.png" alt="10,000시간" width="384"  />
<p class="caption">
Figure 2.35: 10,000시간
</p>
</div>
<pre><code>## [1] &quot;10,000시간 후 최소값: 0.11&quot;</code></pre>
<p><em>여전히 0이 아니네요! 시간이 얼마나 더 필요한 거죠?!</em> 😱</p>
<p>아시다시피, 아마 무한대에서 0 값에 도달할 것입니다… 우리는 지금 <a href="https://en.wikipedia.org/wiki/Asymptote">점근선(Asymptote)</a>을 마주하고 있습니다.</p>
<p><em>우리는 무엇을 해야 할까요?</em> 다음 섹션으로 이동할 때입니다.</p>
</div>
<div id="무한함과-친구-되기" class="section level4 hasAnchor" number="2.6.1.4">
<h4><span class="header-section-number">2.6.1.4</span> 무한함과 친구 되기<a href="data_preparation.html#무한함과-친구-되기" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>마지막 예시는 회사의 고객 연령 분석에서도 볼 수 있습니다. <em>이 값은 무한할 수 있습니다.</em></p>
<p>예를 들어 프로젝트 목표가 <code>구매</code>/<code>비구매</code>와 같은 이진 결과를 예측하는 것이라면, 유용한 분석 중 하나는 사용자 연령에 따른 <code>구매</code> 비율을 계산하는 것입니다. 다음과 같은 결론에 도달하게 됩니다: <em>평균적으로 한 고객은 이 제품을 구매하는 데 약 6개월이 필요하다.</em></p>
<p>이 답은 데이터 과학자와 도메인 전문가의 공동 작업을 통해 얻을 수 있습니다.</p>
<p>이 경우, 인구의 95%가 가지는 값과 동일하게 0을 고려할 수 있습니다. 통계 용어로는 <code>0.95</code> <strong>백분위수(percentile)</strong>입니다. 이 책은 <a href="appendix.html#appendix-percentiles">부록 1: 백분위수의 마법</a> 장에서 이 주제를 광범위하게 다룹니다. 이는 탐색적 데이터 분석의 핵심 주제입니다.</p>
<p>관련된 사례는 <strong>이상치 처리</strong>인데, <a href="data_preparation.html#treatment_outliers">이상치 처리</a> 장에서 본 것처럼 이 절단 백분위수 기준을 적용할 수 있습니다.</p>
</div>
<div id="다른-분야의-예시" class="section level4 hasAnchor" number="2.6.1.5">
<h4><span class="header-section-number">2.6.1.5</span> 다른 분야의 예시<a href="data_preparation.html#다른-분야의-예시" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>많은 데이터셋이나 프로젝트에서 이런 종류의 변수를 찾는 것은 정말 흔한 일입니다.</p>
<p><strong>의학에서</strong>, <a href="https://en.wikipedia.org/wiki/Survival_analysis">생존 분석 프로젝트</a>의 경우 의사들은 보통 환자가 치료에서 _생존_했다고 간주하기 위해 예를 들어 3년이라는 임계값을 정의합니다.</p>
<p><strong>마케팅 프로젝트에서</strong>, 만약 사용자가 특정 임계값 미만으로 활동을 줄인다면(예:):
* 지난달 동안 회사의 웹 페이지에서 10번의 클릭
* 1주일 후에도 이메일을 열지 않음
* 30일이 지나도 구매하지 않음</p>
<p>이탈한 고객 또는 기회를 놓친 고객으로 정의될 수 있습니다.</p>
<p><strong>고객 지원에서</strong>, 사용자가 1주일 동안 불만을 제기하지 않으면 문제가 해결된 것으로 표시될 수 있습니다.</p>
<p><strong>뇌 신호 분석에서</strong>, 만약 이 신호들이 시각 피질에서 온 것이고 환자가 어떤 유형의 이미지를 보고 있는지 예측해야 하는 프로젝트라면, 처음 40ms의 값은 무용지물입니다. 뇌가 신호를 처리하기 시작하는 데 필요한 시간이기 때문입니다.</p>
<p>하지만 이것은 _“실생활”_에서도 일어납니다. 모든 연령대에 적합한 데이터 과학 책을 쓸 때, 그것을 끝내는 데 얼마나 많은 시간이 필요할까요? 무한한 시간일까요? 아마도 아닐 겁니다 😄.</p>
</div>
<div id="최종-생각-4" class="section level4 hasAnchor" number="2.6.1.6">
<h4><span class="header-section-number">2.6.1.6</span> 최종 생각<a href="data_preparation.html#최종-생각-4" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>데이터가 동적인 경우 훈련 및 검증 세트를 생성하기 위해 시간 프레임을 정의하는 것은 <strong>거저 얻어지는 것이 아니며(not a free-lunch)</strong>, 시간이 지남에 따라 변하는 변수를 처리하는 방법을 결정하는 것도 마찬가지입니다. 그렇기 때문에 분석 중인 데이터와 접촉하기 위해 <strong>탐색적 데이터 분석</strong>이 중요합니다.</p>
<p>주제들은 서로 연결되어 있습니다. 이제 이 장과 모델 성능 평가에서의 <a href="model-performance.html#out-of-time_validation">시간 외 검증(Out-of-time Validation)</a>과의 관계를 언급할 때입니다. 미래의 사건을 예측할 때, 타겟 변수가 변하는 데 얼마나 많은 시간이 필요한지 분석해야 합니다.</p>
<p>여기서의 핵심 개념은 <strong>예측 모델링에서 시간을 다루는 방법</strong>입니다. 다음과 같이 질문해 볼 좋은 기회입니다: <em>이러한 시간 문제를 자동화된 시스템으로 해결하는 것이 어떻게 가능할까요?</em></p>
<p>경험, 직관 및 일부 계산을 기반으로 임계값을 정의하는 데 있어 이러한 맥락에서는 인간의 지식이 결정적입니다.</p>
<p><img src="introduction/spacer_bar.png" /><!-- --></p>

</div>
</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="exploratory_data_analysis.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="selecting_best_variables.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
  "sharing": {
    "github": false,
    "facebook": true,
    "twitter": true,
    "linkedin": false,
    "weibo": false,
    "instapaper": false,
    "vk": false,
    "whatsapp": false,
    "all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
  },
  "fontsettings": {
    "theme": "white",
    "family": "sans",
    "size": 2
  },
  "edit": {
    "link": "https://github.com/pablo14/data-science-live-book/edit/master/02_data_preparation.Rmd",
    "text": "Edit"
  },
  "history": {
    "link": null,
    "text": null
  },
  "view": {
    "link": null,
    "text": null
  },
  "download": null,
  "search": {
    "engine": "fuse",
    "options": null
  },
  "toc": {
    "collapse": "subsection",
    "scroll_highlight": true
  }
});
});
</script>

</body>

</html>
